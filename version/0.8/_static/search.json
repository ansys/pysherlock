[
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionDeleteData.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PolygonalShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x.html#legend_x",
        "title": "legend_x",
        "section": "legend_x",
        "text": "x coordinate of the upper left corner\nfloat\nlegend_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x.html#ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "title": "legend_x > legend_x > legend_x",
        "section": "legend_x > legend_x",
        "text": "LegendBounds.legend_x\n\nx coordinate of the upper left corner\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegion.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_units",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_units.html#list_units",
        "title": "list_units",
        "section": "list_units",
        "text": "List units for a unit type.\nAvailable Since: 2023R2\nunit_type (ListUnitsRequestUnitType) – Unit type.\nUnits for the unit type.\nstr\nlist_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_units",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_units.html#ansys.sherlock.core.common.Common.list_units",
        "title": "list_units > list_units > list_units",
        "section": "list_units > list_units",
        "text": "Common.list_units(unit_type: ListUnitsRequestUnitType) -> str\n\nList units for a unit type.\n\nAvailable Since: 2023R2\n\nParameters\n\nunit_type (ListUnitsRequestUnitType) – Unit type.\n\nReturns\n\nUnits for the unit type.\n\nReturn type\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL.html#update_parts_from_avl",
        "title": "update_parts_from_AVL",
        "section": "update_parts_from_AVL",
        "text": "Update the parts list from the Approved Vendor List (AVL).\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nmatching_mode (str) – Determines how parts are matched against the AVL\nduplication_mode (PartsListSearchDuplicationMode) – Determines how duplicate part matches are handled when found\navl_part_num (AVLPartNum) – Determines what part number info in the parts list is updated from the AVL\navl_description (AVLDescription) – Determines if the part description is updated or not\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nIndicates general errors that occurred while attempting to update parts\n\nnumPartsUpdated: int\n\nNumber of parts updated\n\nupdateErrors: list<str>\n\nErrors found when updating part\nStatus code of the response. 0 for success.\nIndicates general errors that occurred while attempting to update parts\nNumber of parts updated\nErrors found when updating part\nUpdatePartsListFromAVLResponse\nupdate_parts_from_AVL"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL.html#ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "title": "update_parts_from_AVL > update_parts_from_AVL > update_parts_from_AVL",
        "section": "update_parts_from_AVL > update_parts_from_AVL",
        "text": "Parts.update_parts_from_AVL(project: str, cca_name: str, matching_mode: str, duplication_mode: PartsListSearchDuplicationMode, avl_part_num: AVLPartNum, avl_description: AVLDescription) -> SherlockPartsService_pb2.UpdatePartsListFromAVLResponse\n\nUpdate the parts list from the Approved Vendor List (AVL).\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nmatching_mode (str) – Determines how parts are matched against the AVL\n\nduplication_mode (PartsListSearchDuplicationMode) – Determines how duplicate part matches are handled when found\n\navl_part_num (AVLPartNum) – Determines what part number info in the parts list is updated from the AVL\n\navl_description (AVLDescription) – Determines if the part description is updated or not\n\nReturns\n\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nIndicates general errors that occurred while attempting to update parts\n\nnumPartsUpdated: int\n\nNumber of parts updated\n\nupdateErrors: list<str>\n\nErrors found when updating part\n\nReturn type\n\nUpdatePartsListFromAVLResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.parts_types import (\n    AVLDescription,\n    AVLPartNum,\n    PartsListSearchDuplicationMode,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"C:\\\\Program Files\\\\ANSYS Inc\\\\v241\\\\sherlock\\\\tutorial\\\\ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_from_AVL(\n    project=\"Test\",\n    cca_name=\"Card\",\n    matching_mode=\"Both\",\n    duplication=PartsListSearchDuplicationMode.FIRST,\n    avl_part_num=AVLPartNum.ASSIGN_INTERNAL_PART_NUM,\n    avl_description=AVLDescription.ASSIGN_APPROVED_DESCRIPTION\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod UpdatePottingRegionRequest.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region.html#update_modeling_region",
        "title": "update_modeling_region",
        "section": "update_modeling_region",
        "text": "Update one or more modeling regions in a specific project.\nproject (str) – Name of the Sherlock project.\nmodeling_regions (list[dict]) – Modeling regions to update. Each dictionary should contain:cca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type: str\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size: float, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\n\nregion_id_replacement: str, optional\n\nRepresents a unique region id that will replace the existing regionId value during\na modeling region update if a value exists.\nModeling regions to update. Each dictionary should contain:\nName of the CCA.\nUnique region ID of the modeling region.\nUnits of the modeling region.\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\nThe shape of the modeling region.\nPCB model parameters consisting of these properties:\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum size of the mesh to be used in the region.\nUnits for the maximum mesh size.\nWhether to generate quad-shaped elements when creating the mesh if true.\nTrace model parameters consisting of these properties:\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\nUnits for the maximum mesh size when trace modeling is enabled.\nRepresents a unique region id that will replace the existing regionId value during\na modeling region update if a value exists.\nint –    Status code of the response. 0 for success.\n\nExample\n\n——-\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n\n>>> sherlock = launch_sherlock()\n\n>>> sherlock.project.import_odb_archive( – “ODB++ Tutorial.tgz”,\nTrue,\nTrue,\nTrue,\nTrue,\nproject=”Tutorial Project”,\ncca_name=”Card”,\n\n)\n\n>>> modeling_regions = [\n\n>>>     {\n\n>>>         “cca_name” (“Card”,)\n\n>>>         “region_id” (“Region001”,)\n\n>>>         “region_units” (“mm”,)\n\n>>>         “model_mode” (“Enabled”,)\n\n>>>         “shape” (PolygonalShape(points=[(0, 0), (1, 1)], rotation=0),)\n\n>>>         “pcb_model_props” ({)\n\n>>>             “export_model_type” (“Sherlock”,)\n\n>>>             “elem_order” (“Second_Order”,)\n\n>>>             “max_mesh_size” (0.5,)\n\n>>>             “max_mesh_size_units” (“mm”,)\n\n>>>             “quads_preferred” (True,)\n\n>>>         },\n\n>>>         “trace_model_props” ({)\n\n>>>             “trace_model_type” (“Enabled”,)\n\n>>>             “elem_order” (“Second_Order”,)\n\n>>>             “trace_mesh_size” (0.1,)\n\n>>>             “trace_mesh_size_units” (“mm”,)\n\n>>>         },\n\n>>>         “region_id_replacement” (“NewRegion001”,)\n\n>>>     }\n\n>>> ]\n\n>>> result = sherlock.layer.update_modeling_region(“Tutorial Project”, modeling_regions)\nint –    Status code of the response. 0 for success.\nExample\n——-\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive( – “ODB++ Tutorial.tgz”,\nTrue,\nTrue,\nTrue,\nTrue,\nproject=”Tutorial Project”,\ncca_name=”Card”,\n)\n>>> modeling_regions = [\n>>>     {\n>>>         “cca_name” (“Card”,)\n>>>         “region_id” (“Region001”,)\n>>>         “region_units” (“mm”,)\n>>>         “model_mode” (“Enabled”,)\n>>>         “shape” (PolygonalShape(points=[(0, 0), (1, 1)], rotation=0),)\n>>>         “pcb_model_props” ({)\n>>>             “export_model_type” (“Sherlock”,)\n>>>             “elem_order” (“Second_Order”,)\n>>>             “max_mesh_size” (0.5,)\n>>>             “max_mesh_size_units” (“mm”,)\n>>>             “quads_preferred” (True,)\n>>>         },\n>>>         “trace_model_props” ({)\n>>>             “trace_model_type” (“Enabled”,)\n>>>             “elem_order” (“Second_Order”,)\n>>>             “trace_mesh_size” (0.1,)\n>>>             “trace_mesh_size_units” (“mm”,)\n>>>         },\n>>>         “region_id_replacement” (“NewRegion001”,)\n>>>     }\n>>> ]\n>>> result = sherlock.layer.update_modeling_region(“Tutorial Project”, modeling_regions)\nupdate_modeling_region\nEnabled\nDisabled\nExcluded\nDefault\nSherlock\nSweep\nNone\nFirst_Order\nSecond_Order\nSolid_Shell\nDefault\nEnabled\nDisabled\nFirst_Order\nSecond_Order\nSolid_Shell"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region.html#ansys.sherlock.core.layer.Layer.update_modeling_region",
        "title": "update_modeling_region > update_modeling_region > update_modeling_region",
        "section": "update_modeling_region > update_modeling_region",
        "text": "Layer.update_modeling_region(project: str, modeling_regions: list[dict[str, bool | float | str | dict[str, bool | float | str]]]) -> int\n\nUpdate one or more modeling regions in a specific project.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nmodeling_regions (list[dict]) – Modeling regions to update. Each dictionary should contain:cca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type: str\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size: float, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\n\nregion_id_replacement: str, optional\n\nRepresents a unique region id that will replace the existing regionId value during\na modeling region update if a value exists.\n\nReturns\n\nint –    Status code of the response. 0 for success.\n\nExample\n\n——-\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n\n>>> sherlock = launch_sherlock()\n\n>>> sherlock.project.import_odb_archive( – “ODB++ Tutorial.tgz”,\nTrue,\nTrue,\nTrue,\nTrue,\nproject=”Tutorial Project”,\ncca_name=”Card”,\n\n)\n\n>>> modeling_regions = [\n\n>>>     {\n\n>>>         “cca_name” (“Card”,)\n\n>>>         “region_id” (“Region001”,)\n\n>>>         “region_units” (“mm”,)\n\n>>>         “model_mode” (“Enabled”,)\n\n>>>         “shape” (PolygonalShape(points=[(0, 0), (1, 1)], rotation=0),)\n\n>>>         “pcb_model_props” ({)\n\n>>>             “export_model_type” (“Sherlock”,)\n\n>>>             “elem_order” (“Second_Order”,)\n\n>>>             “max_mesh_size” (0.5,)\n\n>>>             “max_mesh_size_units” (“mm”,)\n\n>>>             “quads_preferred” (True,)\n\n>>>         },\n\n>>>         “trace_model_props” ({)\n\n>>>             “trace_model_type” (“Enabled”,)\n\n>>>             “elem_order” (“Second_Order”,)\n\n>>>             “trace_mesh_size” (0.1,)\n\n>>>             “trace_mesh_size_units” (“mm”,)\n\n>>>         },\n\n>>>         “region_id_replacement” (“NewRegion001”,)\n\n>>>     }\n\n>>> ]\n\n>>> result = sherlock.layer.update_modeling_region(“Tutorial Project”, modeling_regions)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model.html#export_fea_model",
        "title": "export_FEA_model",
        "section": "export_FEA_model",
        "text": "Export a FEA model.\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nexport_file (str) – Full path for saving exported files to. The file extension must be .wbjn.\nanalysis (str) – The type of analysis that is being exported. Valid values are NaturalFreq,\nHarmonicVibe, ICTAnalysis, MechanicalShock or RandomVibe.\ndrill_hole_parameters (list[dict[str, str | Measurement]]) – List of the drill hole parameters consisting of these properties:drill_hole_modeling: str\n\nThe status of the drill hole modeling feature. If enabled, automatically enable\ndrill hole modeling. Valid values are ENABLED/enabled or\nDISABLED/disabled.\n\nmin_hole_diameter: MinHoleDiameter\n\nThe properties of the minimum hole diameter.\n\nmax_edge_length: MaxEdgeLength\n\nThe properties of the maximum edge length.\nList of the drill hole parameters consisting of these properties:\nThe status of the drill hole modeling feature. If enabled, automatically enable\ndrill hole modeling. Valid values are ENABLED/enabled or\nDISABLED/disabled.\nThe properties of the minimum hole diameter.\nThe properties of the maximum edge length.\ndetect_lead_modeling (str) – The status of the detect lead modeling feature. If enabled, automatically enable lead\nmodeling if any part has lead geometry defined. Valid values are ENABLED or\nDISABLED.\nlead_model_parameters (list[dict[str, int | str | Measurement]]) – List of the lead model parameters consisting of these properties:lead_modeling: str\n\nThe status of the lead modeling feature. If enabled, automatically enable lead\nmodeling. Valid values are ENABLED or DISABLED.\n\nlead_element_order: str\n\nThe type of the element order. Valid values are First Order (Linear),\nSecond Order (Quadratic), or Solid Shell.\n\nmax_mesh_size: MaxMeshSize\n\nThe properties of the maximum mesh size.\n\nvertical_mesh_size: VerticalMeshSize\n\nThe properties of the vertical mesh size.\n\nthicknessCount: int, optional\n\nThe number of elements through the lead thickness that will be created per lead.\n\nThe default value is 3 and the maximum is 5. Only used when the advanced lead\nmesh setting is enabled.\n\naspectRatio: int, optional\n\nThe aspect ratio is multiplied by the lead thickness divided by the through\nthickness count to give the lead element height. The default value is 2 and the\nmaximum is 10. Only used when the advanced lead mesh setting is enabled.\nList of the lead model parameters consisting of these properties:\nThe status of the lead modeling feature. If enabled, automatically enable lead\nmodeling. Valid values are ENABLED or DISABLED.\nThe type of the element order. Valid values are First Order (Linear),\nSecond Order (Quadratic), or Solid Shell.\nThe properties of the maximum mesh size.\nThe properties of the vertical mesh size.\nThe default value is 3 and the maximum is 5. Only used when the advanced lead\nmesh setting is enabled.\nThe aspect ratio is multiplied by the lead thickness divided by the through\nthickness count to give the lead element height. The default value is 2 and the\nmaximum is 10. Only used when the advanced lead mesh setting is enabled.\ndisplay_model (bool) – Whether to display the model after export.\nclear_FEA_database (bool) – Whether to clear FEA database before defining model.\nuse_FEA_model_id (bool) – Whether to use FEA model ID.\ncoordinate_units (str) – Units of the model coordinates to use when exporting a model.\nStatus code of the response. 0 for success.\nint\nexport_FEA_model\n.wbjn\nNaturalFreq\nHarmonicVibe\nICTAnalysis\nMechanicalShock\nRandomVibe\nENABLED/enabled\nDISABLED/disabled\nENABLED\nDISABLED\nENABLED\nDISABLED\nFirst Order (Linear)\nSecond Order (Quadratic)\nSolid Shell"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model.html#ansys.sherlock.core.model.Model.export_FEA_model",
        "title": "export_FEA_model > export_FEA_model > export_FEA_model",
        "section": "export_FEA_model > export_FEA_model",
        "text": "Model.export_FEA_model(project: str, cca_name: str, export_file: str, analysis: str, drill_hole_parameters: list[dict[str, str | Measurement]], detect_lead_modeling: str, lead_model_parameters: list[dict[str, int | str | Measurement]], display_model: bool, clear_FEA_database: bool, use_FEA_model_id: bool, coordinate_units: str) -> int\n\nExport a FEA model.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nexport_file (str) – Full path for saving exported files to. The file extension must be .wbjn.\n\nanalysis (str) – The type of analysis that is being exported. Valid values are NaturalFreq,\nHarmonicVibe, ICTAnalysis, MechanicalShock or RandomVibe.\n\ndrill_hole_parameters (list[dict[str, str | Measurement]]) – List of the drill hole parameters consisting of these properties:drill_hole_modeling: str\n\nThe status of the drill hole modeling feature. If enabled, automatically enable\ndrill hole modeling. Valid values are ENABLED/enabled or\nDISABLED/disabled.\n\nmin_hole_diameter: MinHoleDiameter\n\nThe properties of the minimum hole diameter.\n\nmax_edge_length: MaxEdgeLength\n\nThe properties of the maximum edge length.\n\ndetect_lead_modeling (str) – The status of the detect lead modeling feature. If enabled, automatically enable lead\nmodeling if any part has lead geometry defined. Valid values are ENABLED or\nDISABLED.\n\nlead_model_parameters (list[dict[str, int | str | Measurement]]) – List of the lead model parameters consisting of these properties:lead_modeling: str\n\nThe status of the lead modeling feature. If enabled, automatically enable lead\nmodeling. Valid values are ENABLED or DISABLED.\n\nlead_element_order: str\n\nThe type of the element order. Valid values are First Order (Linear),\nSecond Order (Quadratic), or Solid Shell.\n\nmax_mesh_size: MaxMeshSize\n\nThe properties of the maximum mesh size.\n\nvertical_mesh_size: VerticalMeshSize\n\nThe properties of the vertical mesh size.\n\nthicknessCount: int, optional\n\nThe number of elements through the lead thickness that will be created per lead.\n\nThe default value is 3 and the maximum is 5. Only used when the advanced lead\nmesh setting is enabled.\n\naspectRatio: int, optional\n\nThe aspect ratio is multiplied by the lead thickness divided by the through\nthickness count to give the lead element height. The default value is 2 and the\nmaximum is 10. Only used when the advanced lead mesh setting is enabled.\n\ndisplay_model (bool) – Whether to display the model after export.\n\nclear_FEA_database (bool) – Whether to clear FEA database before defining model.\n\nuse_FEA_model_id (bool) – Whether to use FEA model ID.\n\ncoordinate_units (str) – Units of the model coordinates to use when exporting a model.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.common_types import (\n    Measurement,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.model.export_FEA_model(\n        project=\"Test Project\",\n        cca_name=\"Main Board\",\n        export_file=\"C:/Temp/export.wbjn\",\n        analysis=\"NaturalFreq\",\n        drill_hole_parameters=[\n            {\n                \"drill_hole_modeling\": \"ENABLED\",\n                \"min_hole_diameter\": Measurement(value=0.5, unit=\"mm\"),\n                \"max_edge_length\": Measurement(value=1.0, unit=\"mm\")\n            }\n        ],\n        detect_lead_modeling=\"ENABLED\",\n        lead_model_parameters=[\n            {\n                \"lead_modeling\": \"ENABLED\",\n                \"lead_element_order\": \"First Order (Linear)\",\n                \"max_mesh_size\": Measurement(value=0.5, unit=\"mm\"),\n                \"vertical_mesh_size\": Measurement(value=0.1, unit=\"mm\"),\n                \"thicknessCount\": 3,\n                \"aspectRatio\": 2\n            }\n        ],\n        display_model=True,\n        clear_FEA_database=True,\n        use_FEA_model_id=True,\n        coordinate_units=\"mm\"\n    )"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.html#ansyssherlockcoretypesproject_typesimagefile",
        "title": "ansys.sherlock.core.types.project_types.ImageFile",
        "section": "ansys.sherlock.core.types.project_types.ImageFile",
        "text": "Contains the properties for a thermal map image file.\nImageFile.board_bounds\nboard_bounds\nImageFile.coordinate_units\ncoordinate_units\nImageFile.image_bounds\nimage_bounds\nImageFile.legend_bounds\nlegend_bounds\nImageFile.legend_orientation\nlegend_orientation\nImageFile.max_temperature\nmax_temperature\nImageFile.max_temperature_units\nmax_temperature_units\nImageFile.min_temperature\nmin_temperature\nImageFile.min_temperature_units\nmin_temperature_units\nansys.sherlock.core.types.project_types.ImageFile\nImageFile.board_bounds\nImageFile.coordinate_units\nImageFile.image_bounds\nImageFile.legend_bounds\nImageFile.legend_orientation\nImageFile.max_temperature\nImageFile.max_temperature_units\nImageFile.min_temperature\nImageFile.min_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.html#ansys.sherlock.core.types.project_types.ImageFile",
        "title": "ansys.sherlock.core.types.project_types.ImageFile > ansys.sherlock.core.types.project_types.ImageFile > ImageFile",
        "section": "ansys.sherlock.core.types.project_types.ImageFile > ImageFile",
        "text": "class ansys.sherlock.core.types.project_types.ImageFile(board_bounds: BoardBounds, coordinate_units: str, image_bounds: ImageBounds, legend_bounds: LegendBounds, legend_orientation: LegendOrientation, max_temperature: float, max_temperature_units: str, min_temperature: float, min_temperature_units: str)\n\nContains the properties for a thermal map image file.\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nImageFile.board_bounds\n\nboard_bounds\n\nImageFile.coordinate_units\n\ncoordinate_units\n\nImageFile.image_bounds\n\nimage_bounds\n\nImageFile.legend_bounds\n\nlegend_bounds\n\nImageFile.legend_orientation\n\nlegend_orientation\n\nImageFile.max_temperature\n\nmax_temperature\n\nImageFile.max_temperature_units\n\nmax_temperature_units\n\nImageFile.min_temperature\n\nmin_temperature\n\nImageFile.min_temperature_units\n\nmin_temperature_units\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CircularShape.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.html#ansyssherlockcorepartsparts",
        "title": "ansys.sherlock.core.parts.Parts",
        "section": "ansys.sherlock.core.parts.Parts",
        "text": "Contains all parts management capabilities.\nParts.enable_lead_modeling(project, cca_name)\nEnable lead modeling for leaded parts.\nParts.export_net_list(project, cca_name, ...)\nExport a net list to a delimited output file.\nParts.export_parts_list(project, cca_name, ...)\nExport a parts list for a CCA.\nParts.get_part_location(project, cca_name, ...)\nReturn the location properties for one or more part.\nParts.import_parts_list(project, cca_name, ...)\nImport a parts list for a CCA.\nParts.update_parts_from_AVL(project, ...)\nUpdate the parts list from the Approved Vendor List (AVL).\nParts.update_parts_list(project, cca_name, ...)\nUpdate a parts list based on matching and duplication preferences.\nParts.update_parts_list_properties(project, ...)\nUpdate one or more properties of one or more parts in a parts list.\nParts.update_parts_locations(project, ...)\nUpdate one or more part locations.\nParts.update_parts_locations_by_file(...[, ...])\nUpdate one or more part locations using a CSV file.\nansys.sherlock.core.parts.Parts\nParts.enable_lead_modeling\nParts.export_net_list\nParts.export_parts_list\nParts.get_part_location\nParts.import_parts_list\nParts.update_parts_from_AVL\nParts.update_parts_list\nParts.update_parts_list_properties\nParts.update_parts_locations\nParts.update_parts_locations_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.html#ansys.sherlock.core.parts.Parts",
        "title": "ansys.sherlock.core.parts.Parts > ansys.sherlock.core.parts.Parts > Parts",
        "section": "ansys.sherlock.core.parts.Parts > Parts",
        "text": "class ansys.sherlock.core.parts.Parts(channel, server_version)\n\nContains all parts management capabilities.\n\nMethods\n\n\n\n\n\n\n\nParts.enable_lead_modeling(project, cca_name)\n\nEnable lead modeling for leaded parts.\n\nParts.export_net_list(project, cca_name, ...)\n\nExport a net list to a delimited output file.\n\nParts.export_parts_list(project, cca_name, ...)\n\nExport a parts list for a CCA.\n\nParts.get_part_location(project, cca_name, ...)\n\nReturn the location properties for one or more part.\n\nParts.import_parts_list(project, cca_name, ...)\n\nImport a parts list for a CCA.\n\nParts.update_parts_from_AVL(project, ...)\n\nUpdate the parts list from the Approved Vendor List (AVL).\n\nParts.update_parts_list(project, cca_name, ...)\n\nUpdate a parts list based on matching and duplication preferences.\n\nParts.update_parts_list_properties(project, ...)\n\nUpdate one or more properties of one or more parts in a parts list.\n\nParts.update_parts_locations(project, ...)\n\nUpdate one or more part locations.\n\nParts.update_parts_locations_by_file(...[, ...])\n\nUpdate one or more part locations using a CSV file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PCBShape.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionDeleteData.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionUpdateData.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.html#ansyssherlockcoretypeslayer_typesdeletepottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "text": "Request to delete 1 or more potting regions.\nDeletePottingRegionRequest.construct([...])\n\nDeletePottingRegionRequest.copy(*[, ...])\nReturns a copy of the model.\nDeletePottingRegionRequest.dict(*[, ...])\n\nDeletePottingRegionRequest.from_orm(obj)\n\nDeletePottingRegionRequest.json(*[, ...])\n\nDeletePottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nDeletePottingRegionRequest.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nDeletePottingRegionRequest.model_dump(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nDeletePottingRegionRequest.model_dump_json(*)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nDeletePottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nDeletePottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nDeletePottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nDeletePottingRegionRequest.model_rebuild(*)\nTry to rebuild the pydantic-core schema for the model.\nDeletePottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nDeletePottingRegionRequest.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nDeletePottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nDeletePottingRegionRequest.parse_file(path, *)\n\nDeletePottingRegionRequest.parse_obj(obj)\n\nDeletePottingRegionRequest.parse_raw(b, *[, ...])\n\nDeletePottingRegionRequest.schema([...])\n\nDeletePottingRegionRequest.schema_json(*[, ...])\n\nDeletePottingRegionRequest.str_validation(...)\nValidate string fields listed.\nDeletePottingRegionRequest.update_forward_refs(...)\n\nDeletePottingRegionRequest.validate(value)\n\nDeletePottingRegionRequest.model_computed_fields\n\nDeletePottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nDeletePottingRegionRequest.model_extra\nGet extra fields set during validation.\nDeletePottingRegionRequest.model_fields\n\nDeletePottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nDeletePottingRegionRequest.project\nName of the project containing the potting regions to delete.\nDeletePottingRegionRequest.potting_region_delete_data\nData identifying which potting regions should be deleted.\nansys.sherlock.core.types.layer_types.DeletePottingRegionRequest\nDeletePottingRegionRequest.construct\nDeletePottingRegionRequest.copy\nDeletePottingRegionRequest.dict\nDeletePottingRegionRequest.from_orm\nDeletePottingRegionRequest.json\nDeletePottingRegionRequest.model_construct\nDeletePottingRegionRequest.model_copy\nDeletePottingRegionRequest.model_dump\nDeletePottingRegionRequest.model_dump_json\nDeletePottingRegionRequest.model_json_schema\nDeletePottingRegionRequest.model_parametrized_name\nDeletePottingRegionRequest.model_post_init\nDeletePottingRegionRequest.model_rebuild\nDeletePottingRegionRequest.model_validate\nDeletePottingRegionRequest.model_validate_json\nDeletePottingRegionRequest.model_validate_strings\nDeletePottingRegionRequest.parse_file\nDeletePottingRegionRequest.parse_obj\nDeletePottingRegionRequest.parse_raw\nDeletePottingRegionRequest.schema\nDeletePottingRegionRequest.schema_json\nDeletePottingRegionRequest.str_validation\nDeletePottingRegionRequest.update_forward_refs\nDeletePottingRegionRequest.validate\nDeletePottingRegionRequest.model_computed_fields\nDeletePottingRegionRequest.model_config\nDeletePottingRegionRequest.model_extra\nDeletePottingRegionRequest.model_fields\nDeletePottingRegionRequest.model_fields_set\nDeletePottingRegionRequest.project\nDeletePottingRegionRequest.potting_region_delete_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > DeletePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > DeletePottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest(*, project: str, potting_region_delete_data: list[PottingRegionDeleteData])\n\nRequest to delete 1 or more potting regions.\n\nMethods\n\n\n\n\n\n\n\nDeletePottingRegionRequest.construct([...])\n\n\n\nDeletePottingRegionRequest.copy(*[, ...])\n\nReturns a copy of the model.\n\nDeletePottingRegionRequest.dict(*[, ...])\n\n\n\nDeletePottingRegionRequest.from_orm(obj)\n\n\n\nDeletePottingRegionRequest.json(*[, ...])\n\n\n\nDeletePottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nDeletePottingRegionRequest.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nDeletePottingRegionRequest.model_dump(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nDeletePottingRegionRequest.model_dump_json(*)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nDeletePottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nDeletePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nDeletePottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nDeletePottingRegionRequest.model_rebuild(*)\n\nTry to rebuild the pydantic-core schema for the model.\n\nDeletePottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nDeletePottingRegionRequest.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nDeletePottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nDeletePottingRegionRequest.parse_file(path, *)\n\n\n\nDeletePottingRegionRequest.parse_obj(obj)\n\n\n\nDeletePottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nDeletePottingRegionRequest.schema([...])\n\n\n\nDeletePottingRegionRequest.schema_json(*[, ...])\n\n\n\nDeletePottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nDeletePottingRegionRequest.update_forward_refs(...)\n\n\n\nDeletePottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nDeletePottingRegionRequest.model_computed_fields\n\n\n\nDeletePottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nDeletePottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nDeletePottingRegionRequest.model_fields\n\n\n\nDeletePottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nDeletePottingRegionRequest.project\n\nName of the project containing the potting regions to delete.\n\nDeletePottingRegionRequest.potting_region_delete_data\n\nData identifying which potting regions should be deleted.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the Sherlock project.\nproject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "UpdatePottingRegionRequest.project: str\n\nName of the Sherlock project."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod RectangularShape.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points.html#export_all_test_points",
        "title": "export_all_test_points",
        "section": "export_all_test_points",
        "text": "Export the test point properties for a CCA.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nexport_file (str) – Full path for the CSV file to export the test points list to.\nlength_units (str, optional) – Length units to use when exporting the test points.\nThe default is DEFAULT.\ndisplacement_units (str, optional) – Displacement units to use when exporting the test points.\nThe default is DEFAULT.\nforce_units (str, optional) – Force units to use when exporting the test points.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_test_points\nDEFAULT\nDEFAULT\nDEFAULT"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points.html#ansys.sherlock.core.layer.Layer.export_all_test_points",
        "title": "export_all_test_points > export_all_test_points > export_all_test_points",
        "section": "export_all_test_points > export_all_test_points",
        "text": "Layer.export_all_test_points(project: str, cca_name: str, export_file: str, length_units: str = 'DEFAULT', displacement_units: str = 'DEFAULT', force_units: str = 'DEFAULT') -> int\n\nExport the test point properties for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nexport_file (str) – Full path for the CSV file to export the test points list to.\n\nlength_units (str, optional) – Length units to use when exporting the test points.\nThe default is DEFAULT.\n\ndisplacement_units (str, optional) – Displacement units to use when exporting the test points.\nThe default is DEFAULT.\n\nforce_units (str, optional) – Force units to use when exporting the test points.\nThe default is DEFAULT.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Tutorial Project\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.export_all_test_points(\n    \"Tutorial Project\",\n    \"Card\",\n    \"TestPointsExport.csv\",\n    \"DEFAULT\",\n    \"DEFAULT\",\n    \"DEFAULT\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units.html#coordinate_units",
        "title": "coordinate_units",
        "section": "coordinate_units",
        "text": "coordinate_units\nstr\ncoordinate_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units.html#ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "title": "coordinate_units > coordinate_units > coordinate_units",
        "section": "coordinate_units > coordinate_units",
        "text": "ImageFile.coordinate_units\n\ncoordinate_units\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.html#ansyssherlockcoretypeslayer_typespottingregioncopydata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "text": "Data identifying which potting regions to copy.\nPottingRegionCopyData.construct([_fields_set])\n\nPottingRegionCopyData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionCopyData.dict(*[, include, ...])\n\nPottingRegionCopyData.from_orm(obj)\n\nPottingRegionCopyData.json(*[, include, ...])\n\nPottingRegionCopyData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionCopyData.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPottingRegionCopyData.model_dump(*[, mode, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPottingRegionCopyData.model_dump_json(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPottingRegionCopyData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionCopyData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionCopyData.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionCopyData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionCopyData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionCopyData.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPottingRegionCopyData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionCopyData.parse_file(path, *[, ...])\n\nPottingRegionCopyData.parse_obj(obj)\n\nPottingRegionCopyData.parse_raw(b, *[, ...])\n\nPottingRegionCopyData.schema([by_alias, ...])\n\nPottingRegionCopyData.schema_json(*[, ...])\n\nPottingRegionCopyData.str_validation(value, info)\nValidate string fields listed.\nPottingRegionCopyData.update_forward_refs(...)\n\nPottingRegionCopyData.validate(value)\n\nPottingRegionCopyData.validate_ids()\nValidate that the potting IDs are not the same between the original and copy.\nPottingRegionCopyData.model_computed_fields\n\nPottingRegionCopyData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionCopyData.model_extra\nGet extra fields set during validation.\nPottingRegionCopyData.model_fields\n\nPottingRegionCopyData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionCopyData.cca_name\nName of the cca.\nPottingRegionCopyData.potting_id\nId to assign to the new potting region.\nPottingRegionCopyData.copy_potting_id\nId of the potting region to copy.\nPottingRegionCopyData.center_x\nX coordinate for the center of the new potting region.\nPottingRegionCopyData.center_y\nY coordinate for the center of the new potting region.\nansys.sherlock.core.types.layer_types.PottingRegionCopyData\nPottingRegionCopyData.construct\nPottingRegionCopyData.copy\nPottingRegionCopyData.dict\nPottingRegionCopyData.from_orm\nPottingRegionCopyData.json\nPottingRegionCopyData.model_construct\nPottingRegionCopyData.model_copy\nPottingRegionCopyData.model_dump\nPottingRegionCopyData.model_dump_json\nPottingRegionCopyData.model_json_schema\nPottingRegionCopyData.model_parametrized_name\nPottingRegionCopyData.model_post_init\nPottingRegionCopyData.model_rebuild\nPottingRegionCopyData.model_validate\nPottingRegionCopyData.model_validate_json\nPottingRegionCopyData.model_validate_strings\nPottingRegionCopyData.parse_file\nPottingRegionCopyData.parse_obj\nPottingRegionCopyData.parse_raw\nPottingRegionCopyData.schema\nPottingRegionCopyData.schema_json\nPottingRegionCopyData.str_validation\nPottingRegionCopyData.update_forward_refs\nPottingRegionCopyData.validate\nPottingRegionCopyData.validate_ids\nPottingRegionCopyData.model_computed_fields\nPottingRegionCopyData.model_config\nPottingRegionCopyData.model_extra\nPottingRegionCopyData.model_fields\nPottingRegionCopyData.model_fields_set\nPottingRegionCopyData.cca_name\nPottingRegionCopyData.potting_id\nPottingRegionCopyData.copy_potting_id\nPottingRegionCopyData.center_x\nPottingRegionCopyData.center_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData > ansys.sherlock.core.types.layer_types.PottingRegionCopyData > PottingRegionCopyData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData > PottingRegionCopyData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionCopyData(*, cca_name: str, potting_id: str, copy_potting_id: str, center_x: float, center_y: float)\n\nData identifying which potting regions to copy.\n\nMethods\n\n\n\n\n\n\n\nPottingRegionCopyData.construct([_fields_set])\n\n\n\nPottingRegionCopyData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionCopyData.dict(*[, include, ...])\n\n\n\nPottingRegionCopyData.from_orm(obj)\n\n\n\nPottingRegionCopyData.json(*[, include, ...])\n\n\n\nPottingRegionCopyData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionCopyData.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPottingRegionCopyData.model_dump(*[, mode, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPottingRegionCopyData.model_dump_json(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPottingRegionCopyData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionCopyData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionCopyData.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionCopyData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionCopyData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionCopyData.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPottingRegionCopyData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionCopyData.parse_file(path, *[, ...])\n\n\n\nPottingRegionCopyData.parse_obj(obj)\n\n\n\nPottingRegionCopyData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionCopyData.schema([by_alias, ...])\n\n\n\nPottingRegionCopyData.schema_json(*[, ...])\n\n\n\nPottingRegionCopyData.str_validation(value, info)\n\nValidate string fields listed.\n\nPottingRegionCopyData.update_forward_refs(...)\n\n\n\nPottingRegionCopyData.validate(value)\n\n\n\nPottingRegionCopyData.validate_ids()\n\nValidate that the potting IDs are not the same between the original and copy.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionCopyData.model_computed_fields\n\n\n\nPottingRegionCopyData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionCopyData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionCopyData.model_fields\n\n\n\nPottingRegionCopyData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionCopyData.cca_name\n\nName of the cca.\n\nPottingRegionCopyData.potting_id\n\nId to assign to the new potting region.\n\nPottingRegionCopyData.copy_potting_id\n\nId of the potting region to copy.\n\nPottingRegionCopyData.center_x\n\nX coordinate for the center of the new potting region.\n\nPottingRegionCopyData.center_y\n\nY coordinate for the center of the new potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod SlotShape.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CopyPottingRegionRequest.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionDeleteData.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height.html#height",
        "title": "height",
        "section": "height",
        "text": "height of the legend\nfloat\nheight"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height.html#ansys.sherlock.core.types.project_types.LegendBounds.height",
        "title": "height > height > height",
        "section": "height > height",
        "text": "LegendBounds.height\n\nheight of the legend\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CopyPottingRegionRequest.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PolygonalShape.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PolygonalShape.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionUpdateData.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material.html#potting_material",
        "title": "potting_material",
        "section": "potting_material",
        "text": "The potting material.\npotting_material"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "title": "potting_material > potting_material > potting_material",
        "section": "potting_material > potting_material",
        "text": "PottingRegion.potting_material: str\n\nThe potting material."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props.html#update_part_modeling_props",
        "title": "update_part_modeling_props",
        "section": "update_part_modeling_props",
        "text": "Update part modeling properties for a given project’s CCA.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\npart_modeling_props (dict[str, bool | float | str]) – Part modeling properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\npart_enabled: bool\n\nWhether to enable part modeling. All other fields are ignored if disabled.\n\npart_min_size: float, optional\n\nMinimum part size.\n\npart_min_size_units: str, optional\n\nMinimum part size units.\n\npart_elem_order: str, optional\n\nPart element order.\nOptions are \"First Order (Linear)\", \"Second Order (Quadratic)\",\nor \"Solid Shell\".\n\npart_max_edge_length: float, optional\n\nPart max edge length.\n\npart_max_edge_length_units: str, optional\n\nPart max edge length units.\n\npart_max_vertical: float, optional\n\nPart max vertical.\n\npart_max_vertical_units: str, optional\n\nPart max vertical units.\n\npart_results_filtered: bool, optional\n\nWhether to enable filtered part results.\nPart modeling properties for a CCA consisting of these properties:\nName of the CCA.\nWhether to enable part modeling. All other fields are ignored if disabled.\nMinimum part size.\nMinimum part size units.\nPart element order.\nOptions are \"First Order (Linear)\", \"Second Order (Quadratic)\",\nor \"Solid Shell\".\nPart max edge length.\nPart max edge length units.\nPart max vertical.\nPart max vertical units.\nWhether to enable filtered part results.\nStatus code of the response. 0 for success.\nint\nupdate_part_modeling_props\n\"First Order (Linear)\"\n\"Second Order (Quadratic)\"\n\"Solid Shell\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props.html#ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "title": "update_part_modeling_props > update_part_modeling_props > update_part_modeling_props",
        "section": "update_part_modeling_props > update_part_modeling_props",
        "text": "Analysis.update_part_modeling_props(project: str, part_modeling_props: dict[str, bool | float | str]) -> int\n\nUpdate part modeling properties for a given project’s CCA.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\npart_modeling_props (dict[str, bool | float | str]) – Part modeling properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\npart_enabled: bool\n\nWhether to enable part modeling. All other fields are ignored if disabled.\n\npart_min_size: float, optional\n\nMinimum part size.\n\npart_min_size_units: str, optional\n\nMinimum part size units.\n\npart_elem_order: str, optional\n\nPart element order.\nOptions are \"First Order (Linear)\", \"Second Order (Quadratic)\",\nor \"Solid Shell\".\n\npart_max_edge_length: float, optional\n\nPart max edge length.\n\npart_max_edge_length_units: str, optional\n\nPart max edge length units.\n\npart_max_vertical: float, optional\n\nPart max vertical.\n\npart_max_vertical_units: str, optional\n\nPart max vertical units.\n\npart_results_filtered: bool, optional\n\nWhether to enable filtered part results.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_part_modeling_props(\n    \"Test\",\n    {\n        \"cca_name\": \"Card\",\n        \"part_enabled\": True,\n        \"part_min_size\": 1,\n        \"part_min_size_units\": \"in\",\n        \"part_elem_order\": \"First Order (Linear)\",\n        \"part_max_edge_length\": 1,\n        \"part_max_edge_length_units\": \"in\",\n        \"part_max_vertical\": 1,\n        \"part_max_vertical_units\": \"in\",\n        \"part_results_filtered\": True\n    }\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod UpdatePottingRegionRequest.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca.html#add_cca",
        "title": "add_cca",
        "section": "add_cca",
        "text": "Add one or more CCAs to a project.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\ncca_properties (list[dict[str, bool | float | str]]) – List of CCAs to be added consisting of these properties:cca_name: str\n\nName of the CCA.\n\ndescription: str\n\nDescription of the CCA. The default is None.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties_enabled: bool\n\nWhether to enable guess part properties. The default is None.\nList of CCAs to be added consisting of these properties:\nName of the CCA.\nDescription of the CCA. The default is None.\nThe default solder type. The default is None.\nThe default stencil thickness. The default is None.\nUnits for default stencil thickness. The default is None.\nDefault part temp rise. The default is None.\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nWhether to enable guess part properties. The default is None.\nStatus code of the response. 0 for success.\nint\nadd_cca\nNone\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca.html#ansys.sherlock.core.project.Project.add_cca",
        "title": "add_cca > add_cca > add_cca",
        "section": "add_cca > add_cca",
        "text": "Project.add_cca(project: str, cca_properties: list[dict[str, bool | float | str]]) -> int\n\nAdd one or more CCAs to a project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_properties (list[dict[str, bool | float | str]]) – List of CCAs to be added consisting of these properties:cca_name: str\n\nName of the CCA.\n\ndescription: str\n\nDescription of the CCA. The default is None.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties_enabled: bool\n\nWhether to enable guess part properties. The default is None.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.project.add_cca(\n    \"Test\",\n    [{\n        'cca_name': 'Card 2',\n        'description': 'Second CCA',\n        'default_solder_type': 'SAC305',\n        'default_stencil_thickness': 10,\n        'default_stencil_thickness_units': 'mm',\n        'default_part_temp_rise': 20,\n        'default_part_temp_rise_units': 'C',\n        'guess_part_properties_enabled': False,\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "RectangularShape.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#analysis-types",
        "title": "Analysis Types",
        "section": "Analysis Types",
        "text": "Module containing types for the Analysis Service.\nAnalysis Types"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#constants",
        "title": "Analysis Types > Constants",
        "section": "Constants",
        "text": "Constants for Element Order.\nLINEAR\nQUADRATIC\nSOLID_SHELL\nConstants for Model Source.\nGENERATED\nSTRAIN_MAP\nConstants for type of analysis in the Run Analysis request.\nCOMPONENT_FAILURE_MODE\nDFMEA\nHARMONIC_VIBE\nICT\nMECHANICAL_SHOCK\nNATURAL_FREQ\nPART_VALIDATION\nPTH_FATIQUE\nRANDOM_VIBE\nSEMICINDUCTOR_WEAROUT\nSOLDER_JOINT_FATIGUE\nTHERMAL_DERATING\nTHERMAL_MECH\nConstants for type of analysis in the Run Strain Map Analysis request.\nHARMONIC_VIBE\nMECHANICAL_SHOCK\nRANDOM_VIBE\nConstants for type of analysis in the Update PCB Modeling Properties Analysis request.\nHARMONIC_VIBE\nICT\nMECHANICAL_SHOCK\nNATURAL_FREQUENCY\nRANDOM_VIBE\nTHERMAL_MECH\nConstants for PCB Material Model in the Update PCB Modeling Properties Analysis request.\nLAYERED\nLAYERED_ELEMENTS\nUNIFORM\nUNIFORM_ELEMENTS\nConstants for PCB Model Type in the Update PCB Modeling Properties Analysis request.\nBONDED\nConstants"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder",
        "title": "Analysis Types > Constants > ElementOrder",
        "section": "Constants > ElementOrder",
        "text": "class ansys.sherlock.core.types.analysis_types.ElementOrder\n\nConstants for Element Order.\n\n\n\nLINEAR\n\nLINEAR\n\n\n\nQUADRATIC\n\nQUADRATIC\n\n\n\nSOLID_SHELL\n\nSOLID_SHELL"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.LINEAR",
        "title": "Analysis Types > Constants > LINEAR",
        "section": "Constants > LINEAR",
        "text": "LINEAR\n\nLINEAR"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.QUADRATIC",
        "title": "Analysis Types > Constants > QUADRATIC",
        "section": "Constants > QUADRATIC",
        "text": "QUADRATIC\n\nQUADRATIC"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.SOLID_SHELL",
        "title": "Analysis Types > Constants > SOLID_SHELL",
        "section": "Constants > SOLID_SHELL",
        "text": "SOLID_SHELL\n\nSOLID_SHELL"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource",
        "title": "Analysis Types > Constants > ModelSource",
        "section": "Constants > ModelSource",
        "text": "class ansys.sherlock.core.types.analysis_types.ModelSource\n\nConstants for Model Source.\n\n\n\nGENERATED\n\nGENERATED\n\n\n\nSTRAIN_MAP\n\nSTRAIN_MAP"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource.GENERATED",
        "title": "Analysis Types > Constants > GENERATED",
        "section": "Constants > GENERATED",
        "text": "GENERATED\n\nGENERATED"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource.STRAIN_MAP",
        "title": "Analysis Types > Constants > STRAIN_MAP",
        "section": "Constants > STRAIN_MAP",
        "text": "STRAIN_MAP\n\nSTRAIN_MAP"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType",
        "title": "Analysis Types > Constants > RunAnalysisRequestAnalysisType",
        "section": "Constants > RunAnalysisRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType\n\nConstants for type of analysis in the Run Analysis request.\n\n\n\nCOMPONENT_FAILURE_MODE\n\nCOMPONENT_FAILURE_MODE\n\n\n\nDFMEA\n\nDFMEA\n\n\n\nHARMONIC_VIBE\n\nHARMONIC_VIBE\n\n\n\nICT\n\nICT\n\n\n\nMECHANICAL_SHOCK\n\nMECHANICAL_SHOCK\n\n\n\nNATURAL_FREQ\n\nNATURAL_FREQ\n\n\n\nPART_VALIDATION\n\nPART_VALIDATION\n\n\n\nPTH_FATIQUE\n\nPTH_FATIQUE\n\n\n\nRANDOM_VIBE\n\nRANDOM_VIBE\n\n\n\nSEMICINDUCTOR_WEAROUT\n\nSEMICINDUCTOR_WEAROUT\n\n\n\nSOLDER_JOINT_FATIGUE\n\nSOLDER_JOINT_FATIGUE\n\n\n\nTHERMAL_DERATING\n\nTHERMAL_DERATING\n\n\n\nTHERMAL_MECH\n\nTHERMAL_MECH"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.COMPONENT_FAILURE_MODE",
        "title": "Analysis Types > Constants > COMPONENT_FAILURE_MODE",
        "section": "Constants > COMPONENT_FAILURE_MODE",
        "text": "COMPONENT_FAILURE_MODE\n\nCOMPONENT_FAILURE_MODE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.DFMEA",
        "title": "Analysis Types > Constants > DFMEA",
        "section": "Constants > DFMEA",
        "text": "DFMEA\n\nDFMEA"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE\n\nHARMONIC_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.ICT",
        "title": "Analysis Types > Constants > ICT",
        "section": "Constants > ICT",
        "text": "ICT\n\nICT"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK\n\nMECHANICAL_SHOCK"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.NATURAL_FREQ",
        "title": "Analysis Types > Constants > NATURAL_FREQ",
        "section": "Constants > NATURAL_FREQ",
        "text": "NATURAL_FREQ\n\nNATURAL_FREQ"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.PART_VALIDATION",
        "title": "Analysis Types > Constants > PART_VALIDATION",
        "section": "Constants > PART_VALIDATION",
        "text": "PART_VALIDATION\n\nPART_VALIDATION"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.PTH_FATIQUE",
        "title": "Analysis Types > Constants > PTH_FATIQUE",
        "section": "Constants > PTH_FATIQUE",
        "text": "PTH_FATIQUE\n\nPTH_FATIQUE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE\n\nRANDOM_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.SEMICINDUCTOR_WEAROUT",
        "title": "Analysis Types > Constants > SEMICINDUCTOR_WEAROUT",
        "section": "Constants > SEMICINDUCTOR_WEAROUT",
        "text": "SEMICINDUCTOR_WEAROUT\n\nSEMICINDUCTOR_WEAROUT"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.SOLDER_JOINT_FATIGUE",
        "title": "Analysis Types > Constants > SOLDER_JOINT_FATIGUE",
        "section": "Constants > SOLDER_JOINT_FATIGUE",
        "text": "SOLDER_JOINT_FATIGUE\n\nSOLDER_JOINT_FATIGUE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.THERMAL_DERATING",
        "title": "Analysis Types > Constants > THERMAL_DERATING",
        "section": "Constants > THERMAL_DERATING",
        "text": "THERMAL_DERATING\n\nTHERMAL_DERATING"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.THERMAL_MECH",
        "title": "Analysis Types > Constants > THERMAL_MECH",
        "section": "Constants > THERMAL_MECH",
        "text": "THERMAL_MECH\n\nTHERMAL_MECH"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType",
        "title": "Analysis Types > Constants > RunStrainMapAnalysisRequestAnalysisType",
        "section": "Constants > RunStrainMapAnalysisRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType\n\nConstants for type of analysis in the Run Strain Map Analysis request.\n\n\n\nHARMONIC_VIBE\n\nHARMONIC_VIBE\n\n\n\nMECHANICAL_SHOCK\n\nMECHANICAL_SHOCK\n\n\n\nRANDOM_VIBE\n\nRANDOM_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE\n\nHARMONIC_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK\n\nMECHANICAL_SHOCK"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE\n\nRANDOM_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestAnalysisType",
        "section": "Constants > UpdatePcbModelingPropsRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType\n\nConstants for type of analysis in the Update PCB Modeling Properties Analysis request.\n\n\n\nHARMONIC_VIBE\n\nHARMONIC_VIBE\n\n\n\nICT\n\nICT\n\n\n\nMECHANICAL_SHOCK\n\nMECHANICAL_SHOCK\n\n\n\nNATURAL_FREQUENCY\n\nNATURAL_FREQUENCY\n\n\n\nRANDOM_VIBE\n\nRANDOM_VIBE\n\n\n\nTHERMAL_MECH\n\nTHERMAL_MECH"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE\n\nHARMONIC_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.ICT",
        "title": "Analysis Types > Constants > ICT",
        "section": "Constants > ICT",
        "text": "ICT\n\nICT"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK\n\nMECHANICAL_SHOCK"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.NATURAL_FREQUENCY",
        "title": "Analysis Types > Constants > NATURAL_FREQUENCY",
        "section": "Constants > NATURAL_FREQUENCY",
        "text": "NATURAL_FREQUENCY\n\nNATURAL_FREQUENCY"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE\n\nRANDOM_VIBE"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.THERMAL_MECH",
        "title": "Analysis Types > Constants > THERMAL_MECH",
        "section": "Constants > THERMAL_MECH",
        "text": "THERMAL_MECH\n\nTHERMAL_MECH"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestPcbMaterialModel",
        "section": "Constants > UpdatePcbModelingPropsRequestPcbMaterialModel",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel\n\nConstants for PCB Material Model in the Update PCB Modeling Properties Analysis request.\n\n\n\nLAYERED\n\nLAYERED\n\n\n\nLAYERED_ELEMENTS\n\nLAYERED_ELEMENTS\n\n\n\nUNIFORM\n\nUNIFORM\n\n\n\nUNIFORM_ELEMENTS\n\nUNIFORM_ELEMENTS"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.LAYERED",
        "title": "Analysis Types > Constants > LAYERED",
        "section": "Constants > LAYERED",
        "text": "LAYERED\n\nLAYERED"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.LAYERED_ELEMENTS",
        "title": "Analysis Types > Constants > LAYERED_ELEMENTS",
        "section": "Constants > LAYERED_ELEMENTS",
        "text": "LAYERED_ELEMENTS\n\nLAYERED_ELEMENTS"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM",
        "title": "Analysis Types > Constants > UNIFORM",
        "section": "Constants > UNIFORM",
        "text": "UNIFORM\n\nUNIFORM"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM_ELEMENTS",
        "title": "Analysis Types > Constants > UNIFORM_ELEMENTS",
        "section": "Constants > UNIFORM_ELEMENTS",
        "text": "UNIFORM_ELEMENTS\n\nUNIFORM_ELEMENTS"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestPcbModelType",
        "section": "Constants > UpdatePcbModelingPropsRequestPcbModelType",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType\n\nConstants for PCB Model Type in the Update PCB Modeling Properties Analysis request.\n\n\n\nBONDED\n\nBONDED"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType.BONDED",
        "title": "Analysis Types > Constants > BONDED",
        "section": "Constants > BONDED",
        "text": "BONDED\n\nBONDED"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegion.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionCopyData.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionUpdateData.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer.html#update_laminate_layer",
        "title": "update_laminate_layer",
        "section": "update_laminate_layer",
        "text": "Update a laminate layer with given properties.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nlayer (str) – Layer ID associated with the conductor layer.\nmanufacturer (str, optional) – Manufacturer of the material for the laminate layer.\nThe default is \"\". To update the material, the\nmanufacturer, grade, and material parameters\nmust be specified. When the manufacturer is specified,\nthere are checks to ensure that the corresponding parameters\nare provided.\ngrade (str, optional) – Material grade. The default is \"\".\nmaterial (str, optional) – Material name. The default is \"\".\nthickness (float, optional) – Laminate thickness. The default is 0.\nthickness_unit (str, optional) – Units for the laminate thickness. The default is \"\".\nconstruction_style (str, optional) – Construction style. The default is \"\".\nglass_construction (list[tuple[str, float, float, str]], optional) – List representing a glass construction. This list consists\n\nof objects with these properties:style\n\nstr\n\nStyle of the glass construction.\n\nresinPercentage\n\nfloat\n\nResin percentage.\n\nthickness: float\n\nThickness.\n\nthicknessUnit: str\n\nUnits for the thickness.\nof objects with these properties:\nStyle of the glass construction.\nResin percentage.\nThickness.\nUnits for the thickness.\nfiber_material (str, optional) – Fiber material. The default is \"\". This parameter is only\nupdated for a glass construction.\nconductor_material (str, optional) – Conductor material. The default is \"\".\nconductor_percent (str, optional) – Conductor percentage. The default is \"\".\nUsing the default value for a property causes no changes for that property.\nStatus code of the response. 0 for success.\nint\nupdate_laminate_layer\n\"\"\nmanufacturer\ngrade\nmaterial\nmanufacturer\n\"\"\n\"\"\n0\n\"\"\n\"\"\n\"\"\n\"\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer.html#ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "title": "update_laminate_layer > update_laminate_layer > update_laminate_layer",
        "section": "update_laminate_layer > update_laminate_layer",
        "text": "Stackup.update_laminate_layer(project, cca_name, layer, manufacturer: str = '', grade: str = '', material: str = '', thickness: float = 0, thickness_unit: str = '', construction_style: str = '', glass_construction: list[tuple[str, float, float, str]] | None = None, fiber_material: str = '', conductor_material: str = '', conductor_percent: str = '') -> int\n\nUpdate a laminate layer with given properties.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nlayer (str) – Layer ID associated with the conductor layer.\n\nmanufacturer (str, optional) – Manufacturer of the material for the laminate layer.\nThe default is \"\". To update the material, the\nmanufacturer, grade, and material parameters\nmust be specified. When the manufacturer is specified,\nthere are checks to ensure that the corresponding parameters\nare provided.\n\ngrade (str, optional) – Material grade. The default is \"\".\n\nmaterial (str, optional) – Material name. The default is \"\".\n\nthickness (float, optional) – Laminate thickness. The default is 0.\n\nthickness_unit (str, optional) – Units for the laminate thickness. The default is \"\".\n\nconstruction_style (str, optional) – Construction style. The default is \"\".\n\nglass_construction (list[tuple[str, float, float, str]], optional) – List representing a glass construction. This list consists\n\nof objects with these properties:style\n\nstr\n\nStyle of the glass construction.\n\nresinPercentage\n\nfloat\n\nResin percentage.\n\nthickness: float\n\nThickness.\n\nthicknessUnit: str\n\nUnits for the thickness.\n\nfiber_material (str, optional) – Fiber material. The default is \"\". This parameter is only\nupdated for a glass construction.\n\nconductor_material (str, optional) – Conductor material. The default is \"\".\n\nconductor_percent (str, optional) – Conductor percentage. The default is \"\".\n\nUsing the default value for a property causes no changes for that property.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.update_laminate_layer(\n    \"Test\",\n    \"Card\",\n    \"2\",\n    \"Generic\",\n    \"FR-4\",\n    \"Generic FR-4\",\n    0.015,\n    \"in\",\n    \"106\",\n    [\n        (\"106\", 68.0, 0.015, \"in\")\n    ],\n    \"E-GLASS\",\n    \"COPPER\",\n    \"0.0\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode.html#import_project_zip_archive_single_mode",
        "title": "import_project_zip_archive_single_mode",
        "section": "import_project_zip_archive_single_mode",
        "text": "Import a zipped project archive – single project mode.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project.\ncategory (str) – Sherlock project category.\narchive_file (str) – Full path to the .zip archive file containing the project data.\ndestination_file_directory (str) – Directory in which the Sherlock project folder will be created.\nStatus code of the response. 0 for success.\nint\nimport_project_zip_archive_single_mode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode.html#ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "title": "import_project_zip_archive_single_mode > import_project_zip_archive_single_mode > import_project_zip_archive_single_mode",
        "section": "import_project_zip_archive_single_mode > import_project_zip_archive_single_mode",
        "text": "Project.import_project_zip_archive_single_mode(project: str, category: str, archive_file: str, destination_file_directory: str)\n\nImport a zipped project archive – single project mode.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncategory (str) – Sherlock project category.\n\narchive_file (str) – Full path to the .zip archive file containing the project data.\n\ndestination_file_directory (str) – Directory in which the Sherlock project folder will be created.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive_single_mode(\"Tutorial Project\",\n\"Demos\",\n\"Tutorial Project.zip\",\n\"New Tutorial Project\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps.html#list_strain_maps",
        "title": "list_strain_maps",
        "section": "list_strain_maps",
        "text": "List the strain maps assigned to each CCA or given CCAs.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\ncca_names (list[str], optional) – CCA names to provide strain maps for. The default is None,\nin which case all CCAs in the project are returned.\nAll strain maps or strain maps for the specified CCAs.\nlist[SherlockProjectService_pb2.ListStrainMapsResponse.CcaStrainMap]\nlist_strain_maps\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps.html#ansys.sherlock.core.project.Project.list_strain_maps",
        "title": "list_strain_maps > list_strain_maps > list_strain_maps",
        "section": "list_strain_maps > list_strain_maps",
        "text": "Project.list_strain_maps(project: str, cca_names: list[str] | None = None) -> list[SherlockProjectService_pb2.ListStrainMapsResponse.CcaStrainMap]\n\nList the strain maps assigned to each CCA or given CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_names (list[str], optional) – CCA names to provide strain maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\nAll strain maps or strain maps for the specified CCAs.\n\nReturn type\n\nlist[SherlockProjectService_pb2.ListStrainMapsResponse.CcaStrainMap]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> strain_maps = sherlock.project.list_strain_maps(\n    \"AssemblyTutorial\",\n    [\"Main Board\",\"Power Module\"]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm.html#ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod RectangularShape.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y.html#ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "SlotShape.center_y: float\n\nfloat\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CopyPottingRegionRequest.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json.html#ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegion.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod RectangularShape.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegion.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionUpdateData.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod DeletePottingRegionRequest.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "X coordinate for the center of the new potting region.\ncenter_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "PottingRegionCopyData.center_x: float\n\nX coordinate for the center of the new potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod DeletePottingRegionRequest.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info.html#get_sherlock_info",
        "title": "get_sherlock_info",
        "section": "get_sherlock_info",
        "text": "Get server Sherlock version.\nSherlock information containing\nreleaseVersion, defaultProjectDir and isSingleProjectMode flag\nSherlockInfoResponse\nget_sherlock_info"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info.html#ansys.sherlock.core.common.Common.get_sherlock_info",
        "title": "get_sherlock_info > get_sherlock_info > get_sherlock_info",
        "section": "get_sherlock_info > get_sherlock_info",
        "text": "Common.get_sherlock_info() -> str\n\nGet server Sherlock version.\n\nReturns\n\nSherlock information containing\nreleaseVersion, defaultProjectDir and isSingleProjectMode flag\n\nReturn type\n\nSherlockInfoResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> release_version = sherlock.common.get_sherlock_info().releaseVersion\n>>> default_dir = sherlock.common.get_sherlock_info().defaultProjectDir\n>>> is_single_project = sherlock.common.get_sherlock_info().isSingleProjectMode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds.html#board_bounds",
        "title": "board_bounds",
        "section": "board_bounds",
        "text": "board_bounds\nBoardBounds\nboard_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "title": "board_bounds > board_bounds > board_bounds",
        "section": "board_bounds > board_bounds",
        "text": "ImageFile.board_bounds\n\nboard_bounds\n\nType\n\nBoardBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod UpdatePottingRegionRequest.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PolygonalShape.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct.html#ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod RectangularShape.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CircularShape.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "UpdatePottingRegionRequest.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PolygonalShape.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length.html#length",
        "title": "length",
        "section": "length",
        "text": "float\nlength\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length.html#ansys.sherlock.core.types.layer_types.SlotShape.length",
        "title": "length > length > length",
        "section": "length > length",
        "text": "SlotShape.length: float\n\nfloat\n\nType\n\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionDeleteData.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles.html#add_shock_profiles",
        "title": "add_shock_profiles",
        "section": "add_shock_profiles",
        "text": "Add shock profiles to a life cycle phase.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project\nshock_profiles (list) – Shock profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the shock profile to.\n\nevent_name: str\n\nName of the shock event.\n\nprofile_name: str\n\nName of the shock profile.\n\nduration: float\n\nPulse duration.\n\nduration_units: str\n\nPulse duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nsample_rate: float\n\nSample rate.\n\nsample_rate_units: str\n\nSample rate units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nload_units: str\n\nLoad units. Options are: \"G\", \"m/s2\", \"mm/s2\", \"in/s2\",\nand \"ft/s2\".\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nshock_profile_entries: list\n\nShock profile entries consisting of these properties:\n\nshape: str\n\nShape of the shock profile entry. Options are \"FullSine\",\n\"HalfSine\", \"Haversine\", \"Triangle\", \"Sawtooth\",\n\"FullSquare\", and \"HalfSquare\".\n\nload: float\n\nLoad of the profile entry expressed in load units.\n\nfreq: float\n\nFrequency of the profile entry expressed in frequency units.\n\ndecay: float\n\nDecay value of the profile entry.\nShock profiles consisting of these properties:\nName of the life cycle phase to add the shock profile to.\nName of the shock event.\nName of the shock profile.\nPulse duration.\nPulse duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nSample rate.\nSample rate units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nLoad units. Options are: \"G\", \"m/s2\", \"mm/s2\", \"in/s2\",\nand \"ft/s2\".\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nShock profile entries consisting of these properties:\nShape of the shock profile entry. Options are \"FullSine\",\n\"HalfSine\", \"Haversine\", \"Triangle\", \"Sawtooth\",\n\"FullSquare\", and \"HalfSquare\".\nLoad of the profile entry expressed in load units.\nFrequency of the profile entry expressed in frequency units.\nDecay value of the profile entry.\nStatus code of the response. 0 for success.\nint\nadd_shock_profiles\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"G\"\n\"m/s2\"\n\"mm/s2\"\n\"in/s2\"\n\"ft/s2\"\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"FullSine\"\n\"HalfSine\"\n\"Haversine\"\n\"Triangle\"\n\"Sawtooth\"\n\"FullSquare\"\n\"HalfSquare\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "title": "add_shock_profiles > add_shock_profiles > add_shock_profiles",
        "section": "add_shock_profiles > add_shock_profiles",
        "text": "Lifecycle.add_shock_profiles(project: str, shock_profiles: list[tuple[str, str, str, float, str, float, str, str, str, list[tuple[str, float, float, float]]]]) -> int\n\nAdd shock profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nshock_profiles (list) – Shock profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the shock profile to.\n\nevent_name: str\n\nName of the shock event.\n\nprofile_name: str\n\nName of the shock profile.\n\nduration: float\n\nPulse duration.\n\nduration_units: str\n\nPulse duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nsample_rate: float\n\nSample rate.\n\nsample_rate_units: str\n\nSample rate units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nload_units: str\n\nLoad units. Options are: \"G\", \"m/s2\", \"mm/s2\", \"in/s2\",\nand \"ft/s2\".\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nshock_profile_entries: list\n\nShock profile entries consisting of these properties:\n\nshape: str\n\nShape of the shock profile entry. Options are \"FullSine\",\n\"HalfSine\", \"Haversine\", \"Triangle\", \"Sawtooth\",\n\"FullSquare\", and \"HalfSquare\".\n\nload: float\n\nLoad of the profile entry expressed in load units.\n\nfreq: float\n\nFrequency of the profile entry expressed in frequency units.\n\ndecay: float\n\nDecay value of the profile entry.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_shock_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_shock_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        10.0, \"ms\",\n        0.1, \"ms\",\n        \"G\",\n        \"HZ\",\n        [(\"HalfSine\", 100.0, 100.0, 0)],\n    )]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy.html#ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CircularShape.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionDeleteData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegion.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props.html#get_stackup_props",
        "title": "get_stackup_props",
        "section": "get_stackup_props",
        "text": "Get the stackup properties from a CCA.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nObject containing the properties of the stackup.\nStackupProperties\nget_stackup_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props.html#ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "title": "get_stackup_props > get_stackup_props > get_stackup_props",
        "section": "get_stackup_props > get_stackup_props",
        "text": "Stackup.get_stackup_props(project: str, cca_name: str) -> StackupProperties\n\nGet the stackup properties from a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nObject containing the properties of the stackup.\n\nReturn type\n\nStackupProperties\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> stackup_props = sherlock.stackup.get_stackup_props(\n       project=\"Tutorial\",\n       cca_name=\"Main Board\"\n    )\n>>> print(f\"{stackup_props}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "UpdatePottingRegionRequest.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod UpdatePottingRegionRequest.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive.html#import_odb_archive",
        "title": "import_odb_archive",
        "section": "import_odb_archive",
        "text": "Import an ODB++ archive file.\nAvailable Since: 2021R1\narchive_file (str) – Full path to the ODB++ archive file.\nprocess_layer_thickness (bool) – Whether to assign stackup thickness.\ninclude_other_layers (bool) – Whether to include other layers.\nprocess_cutout_file (bool) – Whether to process cutouts.\nguess_part_properties (bool) – Whether to guess part properties.\nims_stackup (bool, optional) – Whether to generate an IMS stackup\nproject (str, optional) – Name of the Sherlock project. The default is None, in which\ncase the name of the ODB++ archive file is used for the project name.\ncca_name (str, optional) – Name of the CCA name. The default is None, in which case the\nname of the ODB++ archive file is used for the CCA name.\npolyline_simplification (bool, optional) – Whether to enable polyline simplification\npolyline_tolerance (float, optional) – Polyline simplification tolerance\npolyline_tolerance_units (str, optional) – Polyline simplification tolerance units\nStatus code of the response. 0 for success.\nint\nimport_odb_archive\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive.html#ansys.sherlock.core.project.Project.import_odb_archive",
        "title": "import_odb_archive > import_odb_archive > import_odb_archive",
        "section": "import_odb_archive > import_odb_archive",
        "text": "Project.import_odb_archive(archive_file: str, process_layer_thickness: bool, include_other_layers: bool, process_cutout_file: bool, guess_part_properties: bool, ims_stackup: bool = False, project: str | None = None, cca_name: str | None = None, polyline_simplification: bool = False, polyline_tolerance: float = 0.1, polyline_tolerance_units: str = 'mm') -> int\n\nImport an ODB++ archive file.\n\nAvailable Since: 2021R1\n\nParameters\n\narchive_file (str) – Full path to the ODB++ archive file.\n\nprocess_layer_thickness (bool) – Whether to assign stackup thickness.\n\ninclude_other_layers (bool) – Whether to include other layers.\n\nprocess_cutout_file (bool) – Whether to process cutouts.\n\nguess_part_properties (bool) – Whether to guess part properties.\n\nims_stackup (bool, optional) – Whether to generate an IMS stackup\n\nproject (str, optional) – Name of the Sherlock project. The default is None, in which\ncase the name of the ODB++ archive file is used for the project name.\n\ncca_name (str, optional) – Name of the CCA name. The default is None, in which case the\nname of the ODB++ archive file is used for the CCA name.\n\npolyline_simplification (bool, optional) – Whether to enable polyline simplification\n\npolyline_tolerance (float, optional) – Polyline simplification tolerance\n\npolyline_tolerance_units (str, optional) – Polyline simplification tolerance units\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\"ODB++ Tutorial.tgz\", True, True,\n                        True, True,\n                        ims_stackup=True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\",\n                        polyline_simplification=True,\n                        polyline_tolerance=0.1,\n                        polyline_tolerance_units=\"mm\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "RectangularShape.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x.html#ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "SlotShape.center_x: float\n\nfloat\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.html#ansyssherlockcorelayerlayer",
        "title": "ansys.sherlock.core.layer.Layer",
        "section": "ansys.sherlock.core.layer.Layer",
        "text": "Module containing all the layer management capabilities.\nLayer.add_modeling_region(project, ...)\nAdd one or more modeling regions to a specific project.\nLayer.add_potting_region(project, ...)\nAdd one or more potting regions to a given project.\nLayer.copy_modeling_region(project, copy_regions)\nCopy one or more modeling regions in a specific project.\nLayer.copy_potting_region(request)\nCopy one or more potting regions in a specific project.\nLayer.delete_all_ict_fixtures(project, cca_name)\nDelete all ICT fixtures for a CCA.\nLayer.delete_all_mount_points(project, cca_name)\nDelete all mount points for a CCA.\nLayer.delete_all_test_points(project, cca_name)\nDelete all test points for a CCA.\nLayer.delete_modeling_region(project, ...)\nDelete one or more modeling regions for a specific project.\nLayer.delete_potting_region(request)\nDelete on or more potting regions in a specific project.\nLayer.export_all_mount_points(project, ...)\nExport the mount point properties for a CCA.\nLayer.export_all_test_fixtures(project, ...)\nExport the test fixture properties for a CCA.\nLayer.export_all_test_points(project, ...[, ...])\nExport the test point properties for a CCA.\nLayer.update_modeling_region(project, ...)\nUpdate one or more modeling regions in a specific project.\nLayer.update_mount_points_by_file(project, ...)\nUpdate mount point properties of a CCA from a CSV file.\nLayer.update_potting_region(request)\nUpdate one or more potting regions in a specific project.\nLayer.update_test_fixtures_by_file(project, ...)\nUpdate test fixture properties of a CCA from a CSV file.\nLayer.update_test_points_by_file(project, ...)\nUpdate test point properties of a CCA from a CSV file.\nansys.sherlock.core.layer.Layer\nLayer.add_modeling_region\nLayer.add_potting_region\nLayer.copy_modeling_region\nLayer.copy_potting_region\nLayer.delete_all_ict_fixtures\nLayer.delete_all_mount_points\nLayer.delete_all_test_points\nLayer.delete_modeling_region\nLayer.delete_potting_region\nLayer.export_all_mount_points\nLayer.export_all_test_fixtures\nLayer.export_all_test_points\nLayer.update_modeling_region\nLayer.update_mount_points_by_file\nLayer.update_potting_region\nLayer.update_test_fixtures_by_file\nLayer.update_test_points_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.html#ansys.sherlock.core.layer.Layer",
        "title": "ansys.sherlock.core.layer.Layer > ansys.sherlock.core.layer.Layer > Layer",
        "section": "ansys.sherlock.core.layer.Layer > Layer",
        "text": "class ansys.sherlock.core.layer.Layer(channel: grpc.Channel, server_version: int)\n\nModule containing all the layer management capabilities.\n\nMethods\n\n\n\n\n\n\n\nLayer.add_modeling_region(project, ...)\n\nAdd one or more modeling regions to a specific project.\n\nLayer.add_potting_region(project, ...)\n\nAdd one or more potting regions to a given project.\n\nLayer.copy_modeling_region(project, copy_regions)\n\nCopy one or more modeling regions in a specific project.\n\nLayer.copy_potting_region(request)\n\nCopy one or more potting regions in a specific project.\n\nLayer.delete_all_ict_fixtures(project, cca_name)\n\nDelete all ICT fixtures for a CCA.\n\nLayer.delete_all_mount_points(project, cca_name)\n\nDelete all mount points for a CCA.\n\nLayer.delete_all_test_points(project, cca_name)\n\nDelete all test points for a CCA.\n\nLayer.delete_modeling_region(project, ...)\n\nDelete one or more modeling regions for a specific project.\n\nLayer.delete_potting_region(request)\n\nDelete on or more potting regions in a specific project.\n\nLayer.export_all_mount_points(project, ...)\n\nExport the mount point properties for a CCA.\n\nLayer.export_all_test_fixtures(project, ...)\n\nExport the test fixture properties for a CCA.\n\nLayer.export_all_test_points(project, ...[, ...])\n\nExport the test point properties for a CCA.\n\nLayer.update_modeling_region(project, ...)\n\nUpdate one or more modeling regions in a specific project.\n\nLayer.update_mount_points_by_file(project, ...)\n\nUpdate mount point properties of a CCA from a CSV file.\n\nLayer.update_potting_region(request)\n\nUpdate one or more potting regions in a specific project.\n\nLayer.update_test_fixtures_by_file(project, ...)\n\nUpdate test fixture properties of a CCA from a CSV file.\n\nLayer.update_test_points_by_file(project, ...)\n\nUpdate test point properties of a CCA from a CSV file.\n\n"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#user-guide",
        "title": "User guide",
        "section": "User guide",
        "text": "This section provides an overview of PySherlock and explains how to use it.\nUser guide"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#prerequisites",
        "title": "User guide > Prerequisites",
        "section": "Prerequisites",
        "text": "For installation instructions and information on launching Sherlock and the gRPC server,\nsee ref_getting_started. The Sherlock gRPC server must be running to use PySherlock.\nPrerequisites"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#pysherlock-services",
        "title": "User guide > PySherlock services",
        "section": "PySherlock services",
        "text": "PySherlock methods are divided into modules that correspond to major Sherlock functional areas.\nFor descriptions of each module’s classes, methods, and functions, see ref_api_ref.\nPySherlock services"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#using-pysherlock",
        "title": "User guide > Using PySherlock",
        "section": "Using PySherlock",
        "text": "After the Sherlock gRPC server is started, you can use PySherlock to perform Sherlock\nclient operations.\nSubsequent topics describe how to use PySherlock to automate the process depicted in this diagram:\nUsing PySherlock"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#launch-sherlock",
        "title": "User guide > Launch Sherlock",
        "section": "Launch Sherlock",
        "text": "Use the launch_sherlock()\nmethod to launch Sherlock and start the gRPC server on the default port:\nThis method returns the sherlock gRPC connection object, which is used to invoke\nthe APIs from their respective services.\nLaunch Sherlock\nlaunch_sherlock()\nsherlock"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#import-odb-archive-file",
        "title": "User guide > Import ODB++ archive file",
        "section": "Import ODB++ archive file",
        "text": "Use the import_odb_archive()\nmethod to import the ODB++ archive file (ODB++ Tutorial.tgz).\nThis code imports the archive file and creates a project named Tutorial with a CCA\nnamed Main Board:\nFor information on the project module and its methods, see ref_project_module.\nImport ODB++ archive file\nimport_odb_archive()\nODB++ Tutorial.tgz\nTutorial\nMain Board\nproject"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#update-parts-list",
        "title": "User guide > Update parts list",
        "section": "Update parts list",
        "text": "Use the update_parts_list() method\nto update the parts list for the previously created CCA Main Board.\nThis code uses the Sherlock Part Library to update the parts list:\nFor information on the parts module and its methods, see ref_parts_module.\nUpdate parts list\nupdate_parts_list()\nMain Board\nparts"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#add-random-vibe-event",
        "title": "User guide > Add random vibe event",
        "section": "Add random vibe event",
        "text": "Use the add_random_vibe_event()\nmethod to add a random vibe event:\nFor information on the lifecycle module and its methods, see ref_lifecycle_module.\nAdd random vibe event\nadd_random_vibe_event()\nlifecycle"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#add-random-vibe-profile",
        "title": "User guide > Add random vibe profile",
        "section": "Add random vibe profile",
        "text": "Use the add_random_vibe_profiles()\nmethod to add a random vibe profile:\nFor information on the lifecycle module and its methods, see ref_lifecycle_module.\nAdd random vibe profile\nadd_random_vibe_profiles()\nlifecycle"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#run-analysis",
        "title": "User guide > Run analysis",
        "section": "Run analysis",
        "text": "Use the run_analysis() method\nto run a random vibe analysis:\nFor information on the analysis module and its methods, see ref_analysis_module.\nRun analysis\nrun_analysis()\nanalysis"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#generate-sherlock-report",
        "title": "User guide > Generate Sherlock report",
        "section": "Generate Sherlock report",
        "text": "Use the generate_project_report()\nmethod to generate a Sherlock report for the project Tutorial and save it to a PDF file\nin C:\\Temp\\tutorial_project_report.pdf:\nFor information on the project module and its methods, see ref_project_module.\nGenerate Sherlock report\ngenerate_project_report()\nTutorial\nC:\\Temp\\tutorial_project_report.pdf\nproject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema.html#ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PolygonalShape.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y.html#ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "RectangularShape.center_y: float\n\nfloat\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionCopyData.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields.html#get_natural_frequency_input_fields",
        "title": "get_natural_frequency_input_fields",
        "section": "get_natural_frequency_input_fields",
        "text": "Get natural frequency property fields based on the user configuration.\nAvailable Since: 2023R2\nMatural frequency property fields based on the user configuration.\nlist[str]\nget_natural_frequency_input_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "title": "get_natural_frequency_input_fields > get_natural_frequency_input_fields > get_natural_frequency_input_fields",
        "section": "get_natural_frequency_input_fields > get_natural_frequency_input_fields",
        "text": "Analysis.get_natural_frequency_input_fields() -> list[str]\n\nGet natural frequency property fields based on the user configuration.\n\nAvailable Since: 2023R2\n\nReturns\n\nMatural frequency property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n        \"ODB++ Tutorial.tgz\",\n        True,\n        True,\n        True,\n        True,\n        project=\"Test\",\n        cca_name=\"Card\",\n    )\n    >>> sherlock.analysis.get_natural_frequency_input_fields()"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "DeletePottingRegionRequest.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps.html#update_thermal_maps",
        "title": "update_thermal_maps",
        "section": "update_thermal_maps",
        "text": "Update thermal map files to a Sherlock project.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project to update thermal maps to.\nthermal_map_files (list) – List of thermal map files consisting of these properties:file_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile|IcepakFile|ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nList of thermal map files consisting of these properties:\nName of the thermal file to update.\nThermal maps file type.\nComment to associate with the file.\nThermal board side.\nThe properties of the thermal map file to update.\nList of thermal profiles.\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nStatus code of the response. 0 for success.\nint\nupdate_thermal_maps\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps.html#ansys.sherlock.core.project.Project.update_thermal_maps",
        "title": "update_thermal_maps > update_thermal_maps > update_thermal_maps",
        "section": "update_thermal_maps > update_thermal_maps",
        "text": "Project.update_thermal_maps(project: str, thermal_map_files: list[dict[str, str | ThermalMapsFileType | ThermalBoardSide | CsvExcelFile | IcepakFile | ImageFile | list[str]]]) -> int\n\nUpdate thermal map files to a Sherlock project.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project to update thermal maps to.\n\nthermal_map_files (list) – List of thermal map files consisting of these properties:file_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile|IcepakFile|ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    ThermalBoardSide,\n    ThermalMapsFileType,\n)\n>>> sherlock = launch_sherlock()\n>>> thermal_map_properties = ImageFile(board_bounds=BoardBounds([\n    (1.0, 2.0),\n    (3.0, 4.0),\n    (1.0, 2.0),\n    (1.0, 2.0)]),\n    coordinate_units=\"in\",\n    image_bounds=ImageBounds(0.0, 0.0, 10.0, 8.0),\n    legend_bounds=LegendBounds(1.0, 2.0, 4.0, 2.0),\n    legend_orientation=LegendOrientation.VERTICAL,\n    max_temperature=50.0,\n    max_temperature_units=\"C\",\n    min_temperature=20.0,\n    min_temperature_units=\"C\"\n)\n>>> files = [\n    {\n        \"file_name\": \"thermal_map_file.jpg\",\n        \"file_type\": ThermalMapsFileType.IMAGE,\n        \"file_comment\": \"Update thermal map\",\n        \"thermal_board_side\": ThermalBoardSide.TOP,\n        \"file_data\": thermal_map_properties,\n        \"thermal_profiles\": [\"Environmental/1 - Temp Cycle - Min\"],\n        \"cca_names\": [\"CCA1\", \"CCA2\"]\n    },\n]\n>>> sherlock.project.update_thermal_maps(\"Tutorial Project\", files)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CopyPottingRegionRequest.model_fields: ClassVar[dict[str, FieldInfo]] = {'potting_region_copy_data': FieldInfo(annotation=list[PottingRegionCopyData], required=True), 'project': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod DeletePottingRegionRequest.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props.html#update_harmonic_vibe_props",
        "title": "update_harmonic_vibe_props",
        "section": "update_harmonic_vibe_props",
        "text": "Update properties for a harmonic vibe analysis.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\nharmonic_vibe_properties (list[dict[str, bool | int | float | str]]) – Harmonic vibe properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource\n\nModel source. The default is None.\n\nharmonic_vibe_count: int\n\nNumber of harmonic vibe result layers to generate. The default is None.\n\nharmonic_vibe_damping: str\n\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nfilter_by_event_frequency: bool\n\nIndicates if harmonic results outside analysis event range are included.\nThis parameter is not used for NX Nastran analysis.\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nreuse_modal_analysis: bool\n\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\n\nstrain_map_natural_freq: double\n\nNatural frequency for strain map analysis.\nHarmonic vibe properties for a CCA consisting of these properties:\nName of the CCA.\nModel source. The default is None.\nNumber of harmonic vibe result layers to generate. The default is None.\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nTemperature. The default is None.\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nIndicates if harmonic results outside analysis event range are included.\nThis parameter is not used for NX Nastran analysis.\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\nNatural frequency for strain map analysis.\nStatus code of the response. 0 for success.\nint\nupdate_harmonic_vibe_props\nNone\nNone\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props.html#ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "title": "update_harmonic_vibe_props > update_harmonic_vibe_props > update_harmonic_vibe_props",
        "section": "update_harmonic_vibe_props > update_harmonic_vibe_props",
        "text": "Analysis.update_harmonic_vibe_props(project: str, harmonic_vibe_properties: list[dict[str, bool | int | float | str]]) -> int\n\nUpdate properties for a harmonic vibe analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nharmonic_vibe_properties (list[dict[str, bool | int | float | str]]) – Harmonic vibe properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource\n\nModel source. The default is None.\n\nharmonic_vibe_count: int\n\nNumber of harmonic vibe result layers to generate. The default is None.\n\nharmonic_vibe_damping: str\n\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nfilter_by_event_frequency: bool\n\nIndicates if harmonic results outside analysis event range are included.\nThis parameter is not used for NX Nastran analysis.\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nreuse_modal_analysis: bool\n\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\n\nstrain_map_natural_freq: double\n\nNatural frequency for strain map analysis.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_harmonic_vibe_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"model_source\": ModelSource.GENERATED,\n        \"harmonic_vibe_count\": 2,\n        \"harmonic_vibe_damping\": \"0.01, 0.05\",\n        \"part_validation_enabled\": False,\n        \"require_material_assignment_enabled\": False,\n        \"analysis_temp\": 20,\n        \"analysis_temp_units\": \"C\",\n        \"force_model_rebuild\": \"AUTO\",\n        \"filter_by_event_frequency\": False,\n        \"natural_freq_min\": 10,\n        \"natural_freq_min_units\": \"Hz\",\n        \"natural_freq_max\": 1000,\n        \"natural_freq_max_units\": \"KHz\",\n        \"reuse_modal_analysis\": True,\n        \"strain_map_natural_freq\": 100.13,\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PCBShape.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading.html#is_sherlock_client_loading",
        "title": "is_sherlock_client_loading",
        "section": "is_sherlock_client_loading",
        "text": "Check if the Sherlock client is opened and done initializing.\nAvailable Since: 2023R2\nWhether the Sherlock client is opened and done initializing.\nbool\nis_sherlock_client_loading"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading.html#ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "title": "is_sherlock_client_loading > is_sherlock_client_loading > is_sherlock_client_loading",
        "section": "is_sherlock_client_loading > is_sherlock_client_loading",
        "text": "Common.is_sherlock_client_loading() -> bool\n\nCheck if the Sherlock client is opened and done initializing.\n\nAvailable Since: 2023R2\n\nReturns\n\nWhether the Sherlock client is opened and done initializing.\n\nReturn type\n\nbool"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionCopyData.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm.html#ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PolygonalShape.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy.html#ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PCBShape.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionCopyData.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionDeleteData.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod SlotShape.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PolygonalShape.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas.html#list_ccas",
        "title": "list_ccas",
        "section": "list_ccas",
        "text": "List CCAs and subassembly CCAs assigned to each CCA or given CCAs.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\ncca_names (list[str], optional) – CCA names. The default is None, in which case all CCAs\nin the project are returned.\nCCAs and subassembly CCAs.\nlist\nlist_ccas\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas.html#ansys.sherlock.core.project.Project.list_ccas",
        "title": "list_ccas > list_ccas > list_ccas",
        "section": "list_ccas > list_ccas",
        "text": "Project.list_ccas(project: str, cca_names: list[str] | None = None) -> dict[str, str | dict[str, str]]\n\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_names (list[str], optional) – CCA names. The default is None, in which case all CCAs\nin the project are returned.\n\nReturns\n\nCCAs and subassembly CCAs.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> ccas = sherlock.project.list_ccas(\"AssemblyTutorial\", [\"Main Board\"])"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionDeleteData.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PolygonalShape.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionDeleteData.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.html#ansyssherlockcoretypeslayer_typespolygonalshape",
        "title": "ansys.sherlock.core.types.layer_types.PolygonalShape",
        "section": "ansys.sherlock.core.types.layer_types.PolygonalShape",
        "text": "Contains the properties for a polygonal shape.\nPolygonalShape.construct([_fields_set])\n\nPolygonalShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nPolygonalShape.dict(*[, include, exclude, ...])\n\nPolygonalShape.from_orm(obj)\n\nPolygonalShape.json(*[, include, exclude, ...])\n\nPolygonalShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPolygonalShape.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPolygonalShape.model_dump(*[, mode, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPolygonalShape.model_dump_json(*[, indent, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPolygonalShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPolygonalShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPolygonalShape.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPolygonalShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPolygonalShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nPolygonalShape.model_validate_json(json_data, *)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPolygonalShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPolygonalShape.parse_file(path, *[, ...])\n\nPolygonalShape.parse_obj(obj)\n\nPolygonalShape.parse_raw(b, *[, ...])\n\nPolygonalShape.schema([by_alias, ref_template])\n\nPolygonalShape.schema_json(*[, by_alias, ...])\n\nPolygonalShape.update_forward_refs(**localns)\n\nPolygonalShape.validate(value)\n\nPolygonalShape.model_computed_fields\n\nPolygonalShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPolygonalShape.model_extra\nGet extra fields set during validation.\nPolygonalShape.model_fields\n\nPolygonalShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPolygonalShape.points\nlist[tuple[float, float]]\nPolygonalShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.PolygonalShape\nPolygonalShape.construct\nPolygonalShape.copy\nPolygonalShape.dict\nPolygonalShape.from_orm\nPolygonalShape.json\nPolygonalShape.model_construct\nPolygonalShape.model_copy\nPolygonalShape.model_dump\nPolygonalShape.model_dump_json\nPolygonalShape.model_json_schema\nPolygonalShape.model_parametrized_name\nPolygonalShape.model_post_init\nPolygonalShape.model_rebuild\nPolygonalShape.model_validate\nPolygonalShape.model_validate_json\nPolygonalShape.model_validate_strings\nPolygonalShape.parse_file\nPolygonalShape.parse_obj\nPolygonalShape.parse_raw\nPolygonalShape.schema\nPolygonalShape.schema_json\nPolygonalShape.update_forward_refs\nPolygonalShape.validate\nPolygonalShape.model_computed_fields\nPolygonalShape.model_config\nPolygonalShape.model_extra\nPolygonalShape.model_fields\nPolygonalShape.model_fields_set\nPolygonalShape.points\nPolygonalShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.html#ansys.sherlock.core.types.layer_types.PolygonalShape",
        "title": "ansys.sherlock.core.types.layer_types.PolygonalShape > ansys.sherlock.core.types.layer_types.PolygonalShape > PolygonalShape",
        "section": "ansys.sherlock.core.types.layer_types.PolygonalShape > PolygonalShape",
        "text": "class ansys.sherlock.core.types.layer_types.PolygonalShape(*, points: list[tuple[float, float]], rotation: float)\n\nContains the properties for a polygonal shape.\n\nMethods\n\n\n\n\n\n\n\nPolygonalShape.construct([_fields_set])\n\n\n\nPolygonalShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nPolygonalShape.dict(*[, include, exclude, ...])\n\n\n\nPolygonalShape.from_orm(obj)\n\n\n\nPolygonalShape.json(*[, include, exclude, ...])\n\n\n\nPolygonalShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPolygonalShape.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPolygonalShape.model_dump(*[, mode, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPolygonalShape.model_dump_json(*[, indent, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPolygonalShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPolygonalShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPolygonalShape.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPolygonalShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPolygonalShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nPolygonalShape.model_validate_json(json_data, *)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPolygonalShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPolygonalShape.parse_file(path, *[, ...])\n\n\n\nPolygonalShape.parse_obj(obj)\n\n\n\nPolygonalShape.parse_raw(b, *[, ...])\n\n\n\nPolygonalShape.schema([by_alias, ref_template])\n\n\n\nPolygonalShape.schema_json(*[, by_alias, ...])\n\n\n\nPolygonalShape.update_forward_refs(**localns)\n\n\n\nPolygonalShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPolygonalShape.model_computed_fields\n\n\n\nPolygonalShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPolygonalShape.model_extra\n\nGet extra fields set during validation.\n\nPolygonalShape.model_fields\n\n\n\nPolygonalShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPolygonalShape.points\n\nlist[tuple[float, float]]\n\nPolygonalShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property DeletePottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate.html#ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PCBShape.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/analysis",
        "href": "api/analysis.html#analysis",
        "title": "Analysis",
        "section": "Analysis",
        "text": "Module containing all analysis capabilities.\nAnalysis(channel, server_version)\nContains all analysis capabilities.\nAnalysis\nAnalysis"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionUpdateData.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod RectangularShape.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate.html#ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PolygonalShape.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema.html#ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PCBShape.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock.html#launch_sherlock",
        "title": "launch_sherlock",
        "section": "launch_sherlock",
        "text": "Launch Sherlock and start gRPC on a given host and port.\nhost (str, optional) – IP address to start gRPC on. The default is \"127.0.0.1\", which\nis the IP address for the local host.\nport (int, optional) – Port number for the connection.\nsingle_project_path (str, optional) – Path to the Sherlock project if invoking Sherlock in the single-project mode.\nsherlock_command_args (str, optional) – Additional command arguments for launching Sherlock.\nyear (int, optional) – 4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nrelease_number (int, optional) – Release number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nThe instance of sherlock.\nSherlock\nlaunch_sherlock\n\"127.0.0.1\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock.html#ansys.sherlock.core.launcher.launch_sherlock",
        "title": "launch_sherlock > launch_sherlock > launch_sherlock",
        "section": "launch_sherlock > launch_sherlock",
        "text": "ansys.sherlock.core.launcher.launch_sherlock(host: str = '127.0.0.1', port: int = 9090, single_project_path: str = '', sherlock_command_args: str = '', year: int | None = None, release_number: int | None = None) -> Sherlock\n\nLaunch Sherlock and start gRPC on a given host and port.\n\nParameters\n\nhost (str, optional) – IP address to start gRPC on. The default is \"127.0.0.1\", which\nis the IP address for the local host.\n\nport (int, optional) – Port number for the connection.\n\nsingle_project_path (str, optional) – Path to the Sherlock project if invoking Sherlock in the single-project mode.\n\nsherlock_command_args (str, optional) – Additional command arguments for launching Sherlock.\n\nyear (int, optional) – 4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nrelease_number (int, optional) – Release number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nReturns\n\nThe instance of sherlock.\n\nReturn type\n\nSherlock\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> launcher.launch_sherlock()\n\n>>> from ansys.sherlock.core import launcher\n>>> launcher.launch_sherlock(port=9092, year=2024, release_number=1)\n\n>>> from ansys.sherlock.core import launcher\n>>> project = \"C:\\\\Default Projects Directory\\\\ODB++ Tutorial\"\n>>> launcher.launch_sherlock(port=9092, single_project_path=project)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile.html#load_thermal_profile",
        "title": "load_thermal_profile",
        "section": "load_thermal_profile",
        "text": "Load a thermal profile from a .dat or .csv file.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project\nphase_name (str) – Name of the lifecycle phase to add this event to.\nevent_name (str) – Name of the random vibe event.\nfile_path (str) – File path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_thermal_profile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "title": "load_thermal_profile > load_thermal_profile > load_thermal_profile",
        "section": "load_thermal_profile > load_thermal_profile",
        "text": "Lifecycle.load_thermal_profile(project: str, phase_name: str, event_name: str, file_path: str) -> int\n\nLoad a thermal profile from a .dat or .csv file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nphase_name (str) – Name of the lifecycle phase to add this event to.\n\nevent_name (str) – Name of the random vibe event.\n\nfile_path (str) – File path for thermal profile .dat or .csv file\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n >>>loaded = sherlock.lifecycle.load_thermal_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Thermal Event\",\n        file_path=\"Tutorial_Profile.dat\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.html#ansyssherlockcoretypesproject_typescsvexcelfile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelFile",
        "text": "Contains the properties for a thermal map, CSV, or Excel file.\nCsvExcelFile.header_row_count\nheader_row_count\nCsvExcelFile.numeric_format\nnumeric_format\nCsvExcelFile.reference_id_column\nreference_id_column\nCsvExcelFile.temperature_column\ntemperature_column\nCsvExcelFile.temperature_units\ntemperature_units\nansys.sherlock.core.types.project_types.CsvExcelFile\nCsvExcelFile.header_row_count\nCsvExcelFile.numeric_format\nCsvExcelFile.reference_id_column\nCsvExcelFile.temperature_column\nCsvExcelFile.temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.html#ansys.sherlock.core.types.project_types.CsvExcelFile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelFile > ansys.sherlock.core.types.project_types.CsvExcelFile > CsvExcelFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelFile > CsvExcelFile",
        "text": "class ansys.sherlock.core.types.project_types.CsvExcelFile(header_row_count: int, numeric_format: str, reference_id_column: str, temperature_column: str, temperature_units: str)\n\nContains the properties for a thermal map, CSV, or Excel file.\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCsvExcelFile.header_row_count\n\nheader_row_count\n\nCsvExcelFile.numeric_format\n\nnumeric_format\n\nCsvExcelFile.reference_id_column\n\nreference_id_column\n\nCsvExcelFile.temperature_column\n\ntemperature_column\n\nCsvExcelFile.temperature_units\n\ntemperature_units\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionDeleteData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PCBShape.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod RectangularShape.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegion.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionUpdateData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct.html#ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegion.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionUpdateData.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props.html#update_natural_frequency_props",
        "title": "update_natural_frequency_props",
        "section": "update_natural_frequency_props",
        "text": "Update properties for a natural frequency analysis.\nAvailable Since:2023R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nnatural_freq_count (int) – Natural frequency result count.\nnatural_freq_min (int, optional) – Minimum frequency. This parameter is for NX Nastran analysis only.\nnatural_freq_min_units (str, optional) – Minimum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nnatural_freq_max (int, optional) – Maximum frequency. This parameter is for NX Nastran analysis only.\nnatural_freq_max_units (str, optional) – Maximum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\npart_validation_enabled (bool) – Whether part validation is enabled.\nrequire_material_assignment_enabled (bool) – Whether to require material assignment.\nanalysis_temp (float, optional) – Temperature.\nanalysis_temp_units (str, optional) – Temperature units. Options are \"C\", \"F\", and \"K\".\nStatus code of the response. 0 for success.\nint\nupdate_natural_frequency_props\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"C\"\n\"F\"\n\"K\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props.html#ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "title": "update_natural_frequency_props > update_natural_frequency_props > update_natural_frequency_props",
        "section": "update_natural_frequency_props > update_natural_frequency_props",
        "text": "Analysis.update_natural_frequency_props(project: str, cca_name: str, natural_freq_count: int, natural_freq_min: int, natural_freq_min_units: str, natural_freq_max: int, natural_freq_max_units: str, part_validation_enabled: bool, require_material_assignment_enabled: bool, analysis_temp: float | None = None, analysis_temp_units: str | None = None) -> int\n\nUpdate properties for a natural frequency analysis.\n\nAvailable Since:2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nnatural_freq_count (int) – Natural frequency result count.\n\nnatural_freq_min (int, optional) – Minimum frequency. This parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units (str, optional) – Minimum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max (int, optional) – Maximum frequency. This parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units (str, optional) – Maximum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\npart_validation_enabled (bool) – Whether part validation is enabled.\n\nrequire_material_assignment_enabled (bool) – Whether to require material assignment.\n\nanalysis_temp (float, optional) – Temperature.\n\nanalysis_temp_units (str, optional) – Temperature units. Options are \"C\", \"F\", and \"K\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n>>> sherlock.analysis.update_natural_frequency_props(\n    \"Test\",\n    \"Card\",\n    natural_freq_count=2,\n    natural_freq_min=10,\n    natural_freq_min_units=\"HZ\",\n    natural_freq_max=100,\n    natural_freq_max_units=\"HZ\",\n    part_validation_enabled=True,\n    require_material_assignment_enabled=False,\n    analysis_temp=25,\n    analysis_temp_units=\"C\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionCopyData.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionCopyData.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles.html#add_harmonic_vibe_profiles",
        "title": "add_harmonic_vibe_profiles",
        "section": "add_harmonic_vibe_profiles",
        "text": "Add harmonic vibe profiles to a life cycle phase.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\nharmonic_vibe_profiles (list) – Harmonic vibe profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add this harmonic vibe profile to.\n\nevent_name: str\n\nName of the event.\n\nprofile_name: str\n\nName of the harmonic vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\",\nand \"GHZ\".\n\nload_units: str\n\nLoad units. Options are \"G\", `\"m/s2\", \"mm/s2\",\n\"in/s2\", and \"ft/s2\".\n\nharmonic_profile_entries: list[tuple[float, float, str]]\n\nHarmonic profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the harmonic profile expressed in frequency units.\n\nload: float\n\nLoad of the harmonic profile expressed in load units.\n\ntriaxial_axis: str\n\nAxis that this profile should be assigned to if the harmonic\nprofile type is \"Triaxial\". Options are: \"x\", \"y\",\nand \"z\".\nHarmonic vibe profiles consisting of these properties:\nName of the life cycle phase to add this harmonic vibe profile to.\nName of the event.\nName of the harmonic vibe profile.\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\",\nand \"GHZ\".\nLoad units. Options are \"G\", `\"m/s2\", \"mm/s2\",\n\"in/s2\", and \"ft/s2\".\nHarmonic profile entries consisting of these properties:\nFrequency of the harmonic profile expressed in frequency units.\nLoad of the harmonic profile expressed in load units.\nAxis that this profile should be assigned to if the harmonic\nprofile type is \"Triaxial\". Options are: \"x\", \"y\",\nand \"z\".\nStatus code of the response. 0 for success.\nint\nadd_harmonic_vibe_profiles\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"G\"\n`\"m/s2\"\n\"mm/s2\"\n\"in/s2\"\n\"ft/s2\"\n\"Triaxial\"\n\"x\"\n\"y\"\n\"z\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "title": "add_harmonic_vibe_profiles > add_harmonic_vibe_profiles > add_harmonic_vibe_profiles",
        "section": "add_harmonic_vibe_profiles > add_harmonic_vibe_profiles",
        "text": "Lifecycle.add_harmonic_vibe_profiles(project: str, harmonic_vibe_profiles: list[tuple[str, str, str, str, str, list[tuple[float, float, str]]]]) -> int\n\nAdd harmonic vibe profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nharmonic_vibe_profiles (list) – Harmonic vibe profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add this harmonic vibe profile to.\n\nevent_name: str\n\nName of the event.\n\nprofile_name: str\n\nName of the harmonic vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\",\nand \"GHZ\".\n\nload_units: str\n\nLoad units. Options are \"G\", `\"m/s2\", \"mm/s2\",\n\"in/s2\", and \"ft/s2\".\n\nharmonic_profile_entries: list[tuple[float, float, str]]\n\nHarmonic profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the harmonic profile expressed in frequency units.\n\nload: float\n\nLoad of the harmonic profile expressed in load units.\n\ntriaxial_axis: str\n\nAxis that this profile should be assigned to if the harmonic\nprofile type is \"Triaxial\". Options are: \"x\", \"y\",\nand \"z\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_harmonic_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    5,\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_harmonic_vibe_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"HZ\",\n        \"G\",\n        [\n            (10, 1),\n            (1000, 1),\n        ],\n        \"\",\n    )]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CopyPottingRegionRequest.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps.html#add_thermal_maps",
        "title": "add_thermal_maps",
        "section": "add_thermal_maps",
        "text": "Add thermal map files to a Sherlock project.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project to add thermal maps to.\nadd_thermal_map_files (list[dict[str, list[dict[str, str | ThermalMapsFileType                | ThermalBoardSide | CsvExcelFile | IcepakFile | ImageFile | list[str]]] | str]]) – List of thermal map files consisting of these properties:thermal_map_file: str\n\nFull path to the thermal map file to add.\n\nthermal_map_file_properties: list\n\nList of thermal map properties consisting of these properties:\n\nfile_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile | IcepakFile | ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nList of thermal map files consisting of these properties:\nFull path to the thermal map file to add.\nList of thermal map properties consisting of these properties:\nName of the thermal file to update.\nThermal maps file type.\nComment to associate with the file.\nThermal board side.\nThe properties of the thermal map file to update.\nList of thermal profiles.\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nStatus code of the response. 0 for success.\nint\nadd_thermal_maps\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps.html#ansys.sherlock.core.project.Project.add_thermal_maps",
        "title": "add_thermal_maps > add_thermal_maps > add_thermal_maps",
        "section": "add_thermal_maps > add_thermal_maps",
        "text": "Project.add_thermal_maps(project: str, add_thermal_map_files: list[dict[str, list[dict[str, str | ThermalMapsFileType | ThermalBoardSide | CsvExcelFile | IcepakFile | ImageFile | list[str]]] | str]]) -> int\n\nAdd thermal map files to a Sherlock project.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project to add thermal maps to.\n\nadd_thermal_map_files (list[dict[str, list[dict[str, str | ThermalMapsFileType                | ThermalBoardSide | CsvExcelFile | IcepakFile | ImageFile | list[str]]] | str]]) – List of thermal map files consisting of these properties:thermal_map_file: str\n\nFull path to the thermal map file to add.\n\nthermal_map_file_properties: list\n\nList of thermal map properties consisting of these properties:\n\nfile_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile | IcepakFile | ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    ThermalBoardSide,\n    ThermalMapsFileType,\n)\n>>> sherlock = launch_sherlock()\n>>> thermal_map_properties = ImageFile(board_bounds=BoardBounds([\n    (1.0, 2.0),\n    (3.0, 4.0),\n    (1.0, 2.0),\n    (1.0, 2.0)]),\n    coordinate_units=\"in\",\n    image_bounds=ImageBounds(0.0, 0.0, 10.0, 8.0),\n    legend_bounds=LegendBounds(1.0, 2.0, 4.0, 2.0),\n    legend_orientation=LegendOrientation.VERTICAL,\n    min_temperature=20.0,\n    min_temperature_units=\"C\",\n    max_temperature=50.0,\n    max_temperature_units=\"C\"\n)\n>>> files = [\n    {\n        \"thermal_map_file\": \"Thermal Image.jpg\",\n        \"thermal_map_file_properties\": [\n            {\n                \"file_name\": \"Thermal Image.jpg\",\n                \"file_type\": ThermalMapsFileType.IMAGE,\n                \"file_comment\": \"Update thermal map\",\n                \"thermal_board_side\": ThermalBoardSide.TOP,\n                \"file_data\": thermal_map_properties,\n                \"thermal_profiles\": [\"Environmental/1 - Temp Cycle - Min\"],\n                \"cca_names\": [\"CCA1\", \"CCA2\"]\n            },\n        ]\n    }\n]\n>>> sherlock.project.add_thermal_maps(\"Tutorial Project\", files)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionCopyData.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump.html#ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "SlotShape.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegion.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionCopyData.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionCopyData.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PolygonalShape.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props.html#update_mechanical_shock_props",
        "title": "update_mechanical_shock_props",
        "section": "update_mechanical_shock_props",
        "text": "Update properties for a mechanical shock analysis.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\nmechanical_shock_properties (list[dict[str, bool | float | int | str]]) – Mechanical shock properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource, optional\n\nModel source. The default is None.\n\nshock_result_count\n\nint\n\nNumber of mechanical shock result layers to generate.\n\ncritical_shock_strain: float\n\nCritical shock strain. The default is None.\n\ncritical_shock_strain_units: str\n\nCritical shock strain units. The default is None.\nOptions are \"strain\", \"ε\", and \"µε\".\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nMechanical shock properties for a CCA consisting of these properties:\nName of the CCA.\nModel source. The default is None.\nNumber of mechanical shock result layers to generate.\nCritical shock strain. The default is None.\nCritical shock strain units. The default is None.\nOptions are \"strain\", \"ε\", and \"µε\".\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nMinimum frequency. The default is None.\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nMaximum frequency. The default is None.\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nTemperature. The default is None.\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nStatus code of the response. 0 for success.\nint\nupdate_mechanical_shock_props\nNone\nNone\nNone\n\"strain\"\n\"ε\"\n\"µε\"\nNone\nNone\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"C\"\n\"F\"\n\"K\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props.html#ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "title": "update_mechanical_shock_props > update_mechanical_shock_props > update_mechanical_shock_props",
        "section": "update_mechanical_shock_props > update_mechanical_shock_props",
        "text": "Analysis.update_mechanical_shock_props(project: str, mechanical_shock_properties: list[dict[str, bool | float | int | str]]) -> int\n\nUpdate properties for a mechanical shock analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nmechanical_shock_properties (list[dict[str, bool | float | int | str]]) – Mechanical shock properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource, optional\n\nModel source. The default is None.\n\nshock_result_count\n\nint\n\nNumber of mechanical shock result layers to generate.\n\ncritical_shock_strain: float\n\nCritical shock strain. The default is None.\n\ncritical_shock_strain_units: str\n\nCritical shock strain units. The default is None.\nOptions are \"strain\", \"ε\", and \"µε\".\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_mechanical_shock_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"model_source\": ModelSource.GENERATED,\n        \"shock_result_count\": 2,\n        \"critical_shock_strain\": 10,\n        \"critical_shock_strain_units\": \"strain\",\n        \"part_validation_enabled\": True,\n        \"require_material_assignment_enabled\": False,\n        \"force_model_rebuild\": \"AUTO\",\n        \"natural_freq_min\": 10,\n        \"natural_freq_min_units\": \"Hz\",\n        \"natural_freq_max\": 100,\n        \"natural_freq_max_units\": \"KHz\",\n        \"analysis_temp\": 20,\n        \"analysis_temp_units\": \"F\",\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionDeleteData.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod RectangularShape.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/index",
        "href": "api/index.html#api-reference",
        "title": "API reference",
        "section": "API reference",
        "text": "This section describes PySherlock modules and their classes, methods, and functions.\nUse the search feature or click links to view API documentation.\nansys.sherlock.core.analysis\nModule containing all analysis capabilities.\nansys.sherlock.core.types.analysis_types\nModule containing types for the Analysis Service.\nansys.sherlock.core.common\nModule for running the gRPC APIs in the Sherlock Common service.\nansys.sherlock.core.types.common_types\nModule containing types for the Common Service.\nansys.sherlock.core.launcher\nModule for launching Sherlock locally or connecting to a local instance with gRPC.\nansys.sherlock.core.layer\nModule containing all layer management capabilities.\nansys.sherlock.core.types.layer_types\nModule containing types for the Layer Service.\nansys.sherlock.core.lifecycle\nModule containing all life cycle management capabilities.\nansys.sherlock.core.model\nModule containing all model generation capabilities.\nansys.sherlock.core.parts\nModule containing all parts management capabilities.\nansys.sherlock.core.types.parts_types\nModule containing types for the Parts Service.\nansys.sherlock.core.project\nModule containing all project management capabilities.\nansys.sherlock.core.types.project_types\nModule containing types for the Project Service.\nansys.sherlock.core.stackup\nModule containing all stackup management capabilities.\nAPI reference\nansys.sherlock.core.analysis\nansys.sherlock.core.types.analysis_types\nansys.sherlock.core.common\nansys.sherlock.core.types.common_types\nansys.sherlock.core.launcher\nansys.sherlock.core.layer\nansys.sherlock.core.types.layer_types\nansys.sherlock.core.lifecycle\nansys.sherlock.core.model\nansys.sherlock.core.parts\nansys.sherlock.core.types.parts_types\nansys.sherlock.core.project\nansys.sherlock.core.types.project_types\nansys.sherlock.core.stackup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.html#ansyssherlockcoretypeslayer_typespottingregion",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegion",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegion",
        "text": "Contains the properties of a Potting Region add or update request.\nPottingRegion.construct([_fields_set])\n\nPottingRegion.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nPottingRegion.dict(*[, include, exclude, ...])\n\nPottingRegion.from_orm(obj)\n\nPottingRegion.json(*[, include, exclude, ...])\n\nPottingRegion.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPottingRegion.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPottingRegion.model_dump(*[, mode, include, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPottingRegion.model_dump_json(*[, indent, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPottingRegion.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPottingRegion.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegion.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegion.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegion.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nPottingRegion.model_validate_json(json_data, *)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPottingRegion.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegion.parse_file(path, *[, ...])\n\nPottingRegion.parse_obj(obj)\n\nPottingRegion.parse_raw(b, *[, ...])\n\nPottingRegion.schema([by_alias, ref_template])\n\nPottingRegion.schema_json(*[, by_alias, ...])\n\nPottingRegion.str_validation(value, info)\nValidate string fields listed.\nPottingRegion.update_forward_refs(**localns)\n\nPottingRegion.validate(value)\n\nPottingRegion.model_computed_fields\n\nPottingRegion.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegion.model_extra\nGet extra fields set during validation.\nPottingRegion.model_fields\n\nPottingRegion.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegion.cca_name\nThe name of the CCA.\nPottingRegion.potting_id\nThe potting ID.\nPottingRegion.potting_side\nThe potting side, options are \"TOP\", \"BOT\", or \"BOTTOM\".\nPottingRegion.potting_material\nThe potting material.\nPottingRegion.potting_units\nThe units to use for the potting region.\nPottingRegion.potting_thickness\nThe potting thickness.\nPottingRegion.potting_standoff\nThe potting standoff.\nPottingRegion.shape\nThe shape of the potting region.\nansys.sherlock.core.types.layer_types.PottingRegion\nPottingRegion.construct\nPottingRegion.copy\nPottingRegion.dict\nPottingRegion.from_orm\nPottingRegion.json\nPottingRegion.model_construct\nPottingRegion.model_copy\nPottingRegion.model_dump\nPottingRegion.model_dump_json\nPottingRegion.model_json_schema\nPottingRegion.model_parametrized_name\nPottingRegion.model_post_init\nPottingRegion.model_rebuild\nPottingRegion.model_validate\nPottingRegion.model_validate_json\nPottingRegion.model_validate_strings\nPottingRegion.parse_file\nPottingRegion.parse_obj\nPottingRegion.parse_raw\nPottingRegion.schema\nPottingRegion.schema_json\nPottingRegion.str_validation\nPottingRegion.update_forward_refs\nPottingRegion.validate\nPottingRegion.model_computed_fields\nPottingRegion.model_config\nPottingRegion.model_extra\nPottingRegion.model_fields\nPottingRegion.model_fields_set\nPottingRegion.cca_name\nPottingRegion.potting_id\nPottingRegion.potting_side\nPottingRegion.potting_material\nPottingRegion.potting_units\nPottingRegion.potting_thickness\nPottingRegion.potting_standoff\nPottingRegion.shape"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.html#ansys.sherlock.core.types.layer_types.PottingRegion",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegion > ansys.sherlock.core.types.layer_types.PottingRegion > PottingRegion",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegion > PottingRegion",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegion(*, cca_name: str, potting_id: str, potting_side: str, potting_material: str, potting_units: str, potting_thickness: float, potting_standoff: float, shape: CircularShape | PCBShape | PolygonalShape | RectangularShape | SlotShape)\n\nContains the properties of a Potting Region add or update request.\n\nMethods\n\n\n\n\n\n\n\nPottingRegion.construct([_fields_set])\n\n\n\nPottingRegion.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nPottingRegion.dict(*[, include, exclude, ...])\n\n\n\nPottingRegion.from_orm(obj)\n\n\n\nPottingRegion.json(*[, include, exclude, ...])\n\n\n\nPottingRegion.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegion.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPottingRegion.model_dump(*[, mode, include, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPottingRegion.model_dump_json(*[, indent, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPottingRegion.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegion.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegion.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegion.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegion.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nPottingRegion.model_validate_json(json_data, *)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPottingRegion.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegion.parse_file(path, *[, ...])\n\n\n\nPottingRegion.parse_obj(obj)\n\n\n\nPottingRegion.parse_raw(b, *[, ...])\n\n\n\nPottingRegion.schema([by_alias, ref_template])\n\n\n\nPottingRegion.schema_json(*[, by_alias, ...])\n\n\n\nPottingRegion.str_validation(value, info)\n\nValidate string fields listed.\n\nPottingRegion.update_forward_refs(**localns)\n\n\n\nPottingRegion.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegion.model_computed_fields\n\n\n\nPottingRegion.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegion.model_extra\n\nGet extra fields set during validation.\n\nPottingRegion.model_fields\n\n\n\nPottingRegion.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegion.cca_name\n\nThe name of the CCA.\n\nPottingRegion.potting_id\n\nThe potting ID.\n\nPottingRegion.potting_side\n\nThe potting side, options are \"TOP\", \"BOT\", or \"BOTTOM\".\n\nPottingRegion.potting_material\n\nThe potting material.\n\nPottingRegion.potting_units\n\nThe units to use for the potting region.\n\nPottingRegion.potting_thickness\n\nThe potting thickness.\n\nPottingRegion.potting_standoff\n\nThe potting standoff.\n\nPottingRegion.shape\n\nThe shape of the potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x.html#ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "RectangularShape.center_x: float\n\nfloat\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count.html#get_layer_count",
        "title": "get_layer_count",
        "section": "get_layer_count",
        "text": "Get the number of CCA layers in a stackup.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nThe number of layers of the CCA in the project.\nint\nget_layer_count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count.html#ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "title": "get_layer_count > get_layer_count > get_layer_count",
        "section": "get_layer_count > get_layer_count",
        "text": "Stackup.get_layer_count(project: str, cca_name: str) -> int\n\nGet the number of CCA layers in a stackup.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nThe number of layers of the CCA in the project.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> conductor_layer_count = sherlock.stackup.get_layer_count(\n>>>    project=\"Test\",\n>>>    cca_name=\"Card\")\n>>> print(f\"{conductor_layer_count}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CopyPottingRegionRequest.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod UpdatePottingRegionRequest.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#contribute",
        "title": "Contribute",
        "section": "Contribute",
        "text": "Overall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys Developer’s Guide. Ensure that you are thoroughly familiar with\nthis guide before attempting to contribute to PySherlock.\nThe following contribution information is specific to PySherlock.\nContribute"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#post-issues",
        "title": "Contribute > Post issues",
        "section": "Post issues",
        "text": "Use the PySherlock Issues\npage to submit questions, report bugs, and request new features. When possible, you\nshould use these issue templates:\nBug report template\nFeature request template\nIf your issue does not fit into these categories, create your own issue.\nTo reach the PyAnsys team, email pyansys.core@ansys.com.\nPost issues"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#view-documentation",
        "title": "Contribute > View documentation",
        "section": "View documentation",
        "text": "Documentation for the latest stable release of PySherlock is hosted at\nPySherlock Documentation.\nIn the upper right corner of the documentation’s title bar, there is an option\nfor switching from viewing the documentation for the latest stable release to\nviewing the documentation for the development version or previously released versions.\nView documentation"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#code-style",
        "title": "Contribute > Code style",
        "section": "Code style",
        "text": "PySherlock follows the PEP8 standard as outlined in the PyAnsys Development Guide and implements style checking using\npre-commit.\nTo ensure your code meets minimum code styling standards, run:\nYou can also install this as a pre-commit hook by running:\nThis way, it’s not possible for you to push code that fails the style checks. For example:\nCode style"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-the-package",
        "title": "Contribute > Install the package",
        "section": "Install the package",
        "text": "PySherlock has three installation modes: user, developer, and offline.\nInstall the package"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-user-mode",
        "title": "Contribute > Install in user mode",
        "section": "Install in user mode",
        "text": "Before installing PySherlock in user mode, use this command to make sure that\nyou have the latest version of pip:\nThen, use this command to install PySherlock:\nInstall in user mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-developer-mode",
        "title": "Contribute > Install in developer mode",
        "section": "Install in developer mode",
        "text": "To install PySherlock in developer mode, run these commands:\nThen run this command:\nDetails\nInstalling PySherlock in developer mode allows you to modify the source\nand enhance it.\nBefore contributing to the project, see the PyAnsys Developer’s\nguide. You must follow these steps:\nStart by cloning this repository:\nCreate a fresh-clean Python environment and activate it:\nIf you require additional information on virtual environments, see the\nofficial Python venv topic.\nTo make sure you have the latest version of pip,\nrun this command:\nInstall the project in editable mode by running the following commands:\nInstall in developer mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-offline-mode",
        "title": "Contribute > Install in offline mode",
        "section": "Install in offline mode",
        "text": "If you lack an internet connection on your installation machine (or you do not have access to the\nprivate Ansys PyPI packages repository), you should install PySherlock by downloading the wheelhouse\narchive from the Releases Page for your\ncorresponding machine architecture.\nEach wheelhouse archive contains all the Python wheels necessary to install PySherlock from scratch on Windows,\nLinux, and MacOS from Python 3.10 to 3.12. You can install this on an isolated system with a fresh Python\ninstallation or on a virtual environment.\nFor example, on Linux with Python 3.10, unzip the wheelhouse archive and install it with:\nIf you’re on Windows with Python 3.10, unzip to a wheelhouse directory and install using the preceding command.\nConsider installing using a virtual environment.\nInstall in offline mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#testing",
        "title": "Contribute > Testing",
        "section": "Testing",
        "text": "This project takes advantage of tox. This tool automates common\ndevelopment tasks (similar to Makefile), but it is oriented towards Python\ndevelopment.\nTesting"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#using-tox",
        "title": "Contribute > Using tox",
        "section": "Using tox",
        "text": "While Makefile has rules, tox has environments. In fact, tox creates its\nown virtual environment so that anything being tested is isolated from the project\nto guarantee the project’s integrity.\nThe following environments commands are provided:\ntox -e style: Checks for coding style quality.\ntox -e py: Checks for unit tests.\ntox -e py-coverage: Checks for unit testing and code coverage.\ntox -e doc: Checks for successfully building the documentation.\nUsing tox\ntox\ntox"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#raw-testing",
        "title": "Contribute > Raw testing",
        "section": "Raw testing",
        "text": "PySherlock also makes use of PyTest,\nwhich can be easily run by using this command to install the tests target:\nOnce the dependencies are installed in your project, you can simply execute the\nfollowing command to run the PySherlock tests:\nRaw testing\ntests"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#documentation",
        "title": "Contribute > Documentation",
        "section": "Documentation",
        "text": "For building documentation, you can run the usual rules provided in the\nSphinx Makefile, such as:\nHowever, the recommended way of checking documentation integrity is to use\ntox:\nDocumentation\ntox"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#distributing",
        "title": "Contribute > Distributing",
        "section": "Distributing",
        "text": "If you would like to create either source or wheel files, start by installing\nthe building requirements and then executing the build module with these commands:\nDistributing"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionUpdateData.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/stackup",
        "href": "api/stackup.html#stackup",
        "title": "Stackup",
        "section": "Stackup",
        "text": "Module containing all stackup management capabilities.\nStackup(channel, server_version)\nContains all stackup management capabilities.\nStackup\nStackup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod DeletePottingRegionRequest.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.html#ansyssherlockcorecommoncommon",
        "title": "ansys.sherlock.core.common.Common",
        "section": "ansys.sherlock.core.common.Common",
        "text": "Contains methods from the Sherlock Common service.\nCommon.check()\nPerform a health check on the gRPC connection.\nCommon.exit([close_sherlock_client])\nClose the gRPC connection.\nCommon.get_sherlock_info()\nGet server Sherlock version.\nCommon.is_sherlock_client_loading()\nCheck if the Sherlock client is opened and done initializing.\nCommon.list_solder_materials()\nList valid solders.\nCommon.list_units(unit_type)\nList units for a unit type.\nansys.sherlock.core.common.Common\nCommon.check\nCommon.exit\nCommon.get_sherlock_info\nCommon.is_sherlock_client_loading\nCommon.list_solder_materials\nCommon.list_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.html#ansys.sherlock.core.common.Common",
        "title": "ansys.sherlock.core.common.Common > ansys.sherlock.core.common.Common > Common",
        "section": "ansys.sherlock.core.common.Common > Common",
        "text": "class ansys.sherlock.core.common.Common(channel: grpc.Channel, server_version: int)\n\nContains methods from the Sherlock Common service.\n\nMethods\n\n\n\n\n\n\n\nCommon.check()\n\nPerform a health check on the gRPC connection.\n\nCommon.exit([close_sherlock_client])\n\nClose the gRPC connection.\n\nCommon.get_sherlock_info()\n\nGet server Sherlock version.\n\nCommon.is_sherlock_client_loading()\n\nCheck if the Sherlock client is opened and done initializing.\n\nCommon.list_solder_materials()\n\nList valid solders.\n\nCommon.list_units(unit_type)\n\nList units for a unit type.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init.html#ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "SlotShape.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy.html#ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegion.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct.html#ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PolygonalShape.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PolygonalShape.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct.html#ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CircularShape.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PolygonalShape.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y.html#image_y",
        "title": "image_y",
        "section": "image_y",
        "text": "y coordinate of the upper left corner\nfloat\nimage_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y.html#ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "title": "image_y > image_y > image_y",
        "section": "image_y > image_y",
        "text": "ImageBounds.image_y\n\ny coordinate of the upper left corner\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PCBShape.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod UpdatePottingRegionRequest.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegion.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionCopyData.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod DeletePottingRegionRequest.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PolygonalShape.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionUpdateData.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles.html#add_thermal_profiles",
        "title": "add_thermal_profiles",
        "section": "add_thermal_profiles",
        "text": "Add thermal profiles to a life cycle phase.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\nthermal_profiles (list[tuple[str, str, str, str, str, list[tuple[str, str, float, float]]]]) – Thermal profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the thermal profile to.\n\nevent_name: str\n\nName of the thermal event.\n\nprofile_name: str\n\nName of the thermal profile.\n\ntime_units: str\n\nTime units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\ntemp_units: str\n\nTemperature units. Options are \"C\", \"F\", and \"K\".\n\nthermal_profile_entries: list[tuple[str, str, float, float]]\n\nThermal profile entries consisting of these properties:\n\nstep: str\n\nName of the thermal step.\n\ntype: str\n\nType of the thermal step. Options are \"HOLD\" and \"RAMP\".\n\ntime: float\n\nDuration of the thermal step expressed in time units.\n\ntemperature: float\n\nTemperature of the step expressed in temperature units.\nThermal profiles consisting of these properties:\nName of the life cycle phase to add the thermal profile to.\nName of the thermal event.\nName of the thermal profile.\nTime units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nTemperature units. Options are \"C\", \"F\", and \"K\".\nThermal profile entries consisting of these properties:\nName of the thermal step.\nType of the thermal step. Options are \"HOLD\" and \"RAMP\".\nDuration of the thermal step expressed in time units.\nTemperature of the step expressed in temperature units.\nStatus code of the response. 0 for success.\nint\nadd_thermal_profiles\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"C\"\n\"F\"\n\"K\"\n\"HOLD\"\n\"RAMP\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "title": "add_thermal_profiles > add_thermal_profiles > add_thermal_profiles",
        "section": "add_thermal_profiles > add_thermal_profiles",
        "text": "Lifecycle.add_thermal_profiles(project: str, thermal_profiles: list[tuple[str, str, str, str, str, list[tuple[str, str, float, float]]]]) -> int\n\nAdd thermal profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nthermal_profiles (list[tuple[str, str, str, str, str, list[tuple[str, str, float, float]]]]) – Thermal profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the thermal profile to.\n\nevent_name: str\n\nName of the thermal event.\n\nprofile_name: str\n\nName of the thermal profile.\n\ntime_units: str\n\nTime units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\ntemp_units: str\n\nTemperature units. Options are \"C\", \"F\", and \"K\".\n\nthermal_profile_entries: list[tuple[str, str, float, float]]\n\nThermal profile entries consisting of these properties:\n\nstep: str\n\nName of the thermal step.\n\ntype: str\n\nType of the thermal step. Options are \"HOLD\" and \"RAMP\".\n\ntime: float\n\nDuration of the thermal step expressed in time units.\n\ntemperature: float\n\nTemperature of the step expressed in temperature units.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_thermal_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    4.0,\n    \"PER YEAR\",\n    \"STORAGE\",\n)\n>>> sherlock.lifecycle.add_thermal_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"sec\",\n        \"F\",\n        [\n            (\"Steady1\", \"HOLD\", 40, 40),\n            (\"Steady\", \"HOLD\", 20, 20),\n            (\"Back\", \"RAMP\", 20, 40),\n        ],\n    )]\n)"
    },
    {
        "objectID": "api/lifecycle",
        "href": "api/lifecycle.html#lifecycle",
        "title": "Lifecycle",
        "section": "Lifecycle",
        "text": "Module containing all life cycle management capabilities.\nLifecycle(channel, server_version)\nContains all life cycle management capabilities.\nLifecycle\nLifecycle"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PolygonalShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#parts-types",
        "title": "Parts Types",
        "section": "Parts Types",
        "text": "Module containing types for the Parts Service.\nParts Types"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#constants",
        "title": "Parts Types > Constants",
        "section": "Constants",
        "text": "Constants for AVLDescription in the Update Parts List from AVL request.\nAssignApprovedDescription\nDoNotChangeDescription\nConstants for AVLPartNum in the Update Parts List from AVL request.\nAssignInternalPartNum\nAssignVendorAndPartNum\nDoNotChangeVendorOrPartNum\nConstants for Duplication Mode in Update Parts List and Update Parts from AVL request.\nError\nFirst\nIgnore\nDEPRECATED. Constants for Matching Mode in Update Parts List & Update Parts from AVL.\nBoth\nPart\nConstants"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription",
        "title": "Parts Types > Constants > AVLDescription",
        "section": "Constants > AVLDescription",
        "text": "class ansys.sherlock.core.types.parts_types.AVLDescription\n\nConstants for AVLDescription in the Update Parts List from AVL request.\n\n\n\nASSIGN_APPROVED_DESCRIPTION\n\nAssignApprovedDescription\n\n\n\nDO_NOT_CHANGE_DESCRIPTION\n\nDoNotChangeDescription"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription.ASSIGN_APPROVED_DESCRIPTION",
        "title": "Parts Types > Constants > ASSIGN_APPROVED_DESCRIPTION",
        "section": "Constants > ASSIGN_APPROVED_DESCRIPTION",
        "text": "ASSIGN_APPROVED_DESCRIPTION\n\nAssignApprovedDescription"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription.DO_NOT_CHANGE_DESCRIPTION",
        "title": "Parts Types > Constants > DO_NOT_CHANGE_DESCRIPTION",
        "section": "Constants > DO_NOT_CHANGE_DESCRIPTION",
        "text": "DO_NOT_CHANGE_DESCRIPTION\n\nDoNotChangeDescription"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum",
        "title": "Parts Types > Constants > AVLPartNum",
        "section": "Constants > AVLPartNum",
        "text": "class ansys.sherlock.core.types.parts_types.AVLPartNum\n\nConstants for AVLPartNum in the Update Parts List from AVL request.\n\n\n\nASSIGN_INTERNAL_PART_NUM\n\nAssignInternalPartNum\n\n\n\nASSIGN_VENDOR_AND_PART_NUM\n\nAssignVendorAndPartNum\n\n\n\nDO_NOT_CHANGE_VENDOR_OR_PART_NUM\n\nDoNotChangeVendorOrPartNum"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.ASSIGN_INTERNAL_PART_NUM",
        "title": "Parts Types > Constants > ASSIGN_INTERNAL_PART_NUM",
        "section": "Constants > ASSIGN_INTERNAL_PART_NUM",
        "text": "ASSIGN_INTERNAL_PART_NUM\n\nAssignInternalPartNum"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.ASSIGN_VENDOR_AND_PART_NUM",
        "title": "Parts Types > Constants > ASSIGN_VENDOR_AND_PART_NUM",
        "section": "Constants > ASSIGN_VENDOR_AND_PART_NUM",
        "text": "ASSIGN_VENDOR_AND_PART_NUM\n\nAssignVendorAndPartNum"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "title": "Parts Types > Constants > DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "section": "Constants > DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "text": "DO_NOT_CHANGE_VENDOR_OR_PART_NUM\n\nDoNotChangeVendorOrPartNum"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode",
        "title": "Parts Types > Constants > PartsListSearchDuplicationMode",
        "section": "Constants > PartsListSearchDuplicationMode",
        "text": "class ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode\n\nConstants for Duplication Mode in Update Parts List and Update Parts from AVL request.\n\n\n\nERROR\n\nError\n\n\n\nFIRST\n\nFirst\n\n\n\nIGNORE\n\nIgnore"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.ERROR",
        "title": "Parts Types > Constants > ERROR",
        "section": "Constants > ERROR",
        "text": "ERROR\n\nError"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.FIRST",
        "title": "Parts Types > Constants > FIRST",
        "section": "Constants > FIRST",
        "text": "FIRST\n\nFirst"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.IGNORE",
        "title": "Parts Types > Constants > IGNORE",
        "section": "Constants > IGNORE",
        "text": "IGNORE\n\nIgnore"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode",
        "title": "Parts Types > Constants > PartsListSearchMatchingMode",
        "section": "Constants > PartsListSearchMatchingMode",
        "text": "class ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode\n\nDEPRECATED. Constants for Matching Mode in Update Parts List & Update Parts from AVL.\n\n\n\nBOTH\n\nBoth\n\n\n\nPART\n\nPart"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode.BOTH",
        "title": "Parts Types > Constants > BOTH",
        "section": "Constants > BOTH",
        "text": "BOTH\n\nBoth"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode.PART",
        "title": "Parts Types > Constants > PART",
        "section": "Constants > PART",
        "text": "PART\n\nPart"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#classes",
        "title": "Parts Types > Classes",
        "section": "Classes",
        "text": "Part Location property values.\nboard side - \"TOP\" or \"BOTTOM\"\nunits for location coordinates\nmirrored - True or False\nreference designator\nrotation (in degrees)\nx coordinate\ny coordinate\nClasses\n\"TOP\"\n\"BOTTOM\"\nTrue\nFalse"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation",
        "title": "Parts Types > Classes > PartLocation",
        "section": "Classes > PartLocation",
        "text": "class ansys.sherlock.core.types.parts_types.PartLocation(location)\n\nPart Location property values.\n\n\n\nboard_side\n\nboard side - \"TOP\" or \"BOTTOM\"\n\n\n\nlocation_units\n\nunits for location coordinates\n\n\n\nmirrored\n\nmirrored - True or False\n\n\n\nref_des\n\nreference designator\n\n\n\nrotation(in degrees)\n\nrotation (in degrees)\n\n\n\nx\n\nx coordinate\n\n\n\ny\n\ny coordinate"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.board_side",
        "title": "Parts Types > Classes > board_side",
        "section": "Classes > board_side",
        "text": "board_side\n\nboard side - \"TOP\" or \"BOTTOM\""
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.location_units",
        "title": "Parts Types > Classes > location_units",
        "section": "Classes > location_units",
        "text": "location_units\n\nunits for location coordinates"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.mirrored",
        "title": "Parts Types > Classes > mirrored",
        "section": "Classes > mirrored",
        "text": "mirrored\n\nmirrored - True or False"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.ref_des",
        "title": "Parts Types > Classes > ref_des",
        "section": "Classes > ref_des",
        "text": "ref_des\n\nreference designator"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.rotation",
        "title": "Parts Types > Classes > rotation",
        "section": "Classes > rotation",
        "text": "rotation(in degrees)\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.x",
        "title": "Parts Types > Classes > x",
        "section": "Classes > x",
        "text": "x\n\nx coordinate"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.y",
        "title": "Parts Types > Classes > y",
        "section": "Classes > y",
        "text": "y\n\ny coordinate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "DeletePottingRegionRequest.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CircularShape.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegion.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct.html#ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PCBShape.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CopyPottingRegionRequest.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase.html#create_life_phase",
        "title": "create_life_phase",
        "section": "create_life_phase",
        "text": "Create a life phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nphase_name (str) – Name of the life phase.\nduration (float) – Event duration length.\nduration_units (str) – Units for the event duration length. Options are \"ms\",\n\"sec\", and \"min\".\nnum_of_cycles (float) – Number of cycles for the life phase.\ncycle_type (str) – Cycle type. Options include \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\ndescription (str, optional) – Description of the life phase. The default is \"\".\nStatus code of the response. 0 for success.\nint\ncreate_life_phase\n\"ms\"\n\"sec\"\n\"min\"\n\"COUNT\"\n\"DUTY CYCLE\"\n\"PER YEAR\"\n\"PER HOUR\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase.html#ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "title": "create_life_phase > create_life_phase > create_life_phase",
        "section": "create_life_phase > create_life_phase",
        "text": "Lifecycle.create_life_phase(project: str, phase_name: str, duration: float, duration_units: str, num_of_cycles: float, cycle_type: str, description: str = '')\n\nCreate a life phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nphase_name (str) – Name of the life phase.\n\nduration (float) – Event duration length.\n\nduration_units (str) – Units for the event duration length. Options are \"ms\",\n\"sec\", and \"min\".\n\nnum_of_cycles (float) – Number of cycles for the life phase.\n\ncycle_type (str) – Cycle type. Options include \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\n\ndescription (str, optional) – Description of the life phase. The default is \"\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.html#ansyssherlockcoreanalysisanalysis",
        "title": "ansys.sherlock.core.analysis.Analysis",
        "section": "ansys.sherlock.core.analysis.Analysis",
        "text": "Contains all analysis capabilities.\nAnalysis.get_harmonic_vibe_input_fields([...])\nGet harmonic vibe property fields based on the user configuration.\nAnalysis.get_ict_analysis_input_fields()\nGet ICT analysis property fields based on the user configuration.\nAnalysis.get_mechanical_shock_input_fields([...])\nGet mechanical shock property fields based on the user configuration.\nAnalysis.get_natural_frequency_input_fields()\nGet natural frequency property fields based on the user configuration.\nAnalysis.get_parts_list_validation_analysis_props(...)\nGet properties for a Part List Validation analysis.\nAnalysis.get_random_vibe_input_fields([...])\nGet random vibe property fields based on the user configuration.\nAnalysis.get_solder_fatigue_input_fields()\nGet solder fatigue property fields based on the user configuration.\nAnalysis.run_analysis(project, cca_name, ...)\nRun one or more Sherlock analyses.\nAnalysis.run_strain_map_analysis(project, ...)\nRun one or more strain map analyses.\nAnalysis.update_harmonic_vibe_props(project, ...)\nUpdate properties for a harmonic vibe analysis.\nAnalysis.update_ict_analysis_props(project, ...)\nUpdate properties for an ICT analysis.\nAnalysis.update_mechanical_shock_props(...)\nUpdate properties for a mechanical shock analysis.\nAnalysis.update_natural_frequency_props(...)\nUpdate properties for a natural frequency analysis.\nAnalysis.update_part_list_validation_analysis_props(...)\nUpdate properties for a Part List Validation analysis.\nAnalysis.update_part_modeling_props(project, ...)\nUpdate part modeling properties for a given project's CCA.\nAnalysis.update_pcb_modeling_props(project, ...)\nUpdate FEA PCB Modeling properties for one or more CCAs.\nAnalysis.update_random_vibe_props(project, ...)\nUpdate properties for a random vibe analysis.\nAnalysis.update_solder_fatigue_props(...)\nUpdate properties for a solder fatigue analysis.\nansys.sherlock.core.analysis.Analysis\nAnalysis.get_harmonic_vibe_input_fields\nAnalysis.get_ict_analysis_input_fields\nAnalysis.get_mechanical_shock_input_fields\nAnalysis.get_natural_frequency_input_fields\nAnalysis.get_parts_list_validation_analysis_props\nAnalysis.get_random_vibe_input_fields\nAnalysis.get_solder_fatigue_input_fields\nAnalysis.run_analysis\nAnalysis.run_strain_map_analysis\nAnalysis.update_harmonic_vibe_props\nAnalysis.update_ict_analysis_props\nAnalysis.update_mechanical_shock_props\nAnalysis.update_natural_frequency_props\nAnalysis.update_part_list_validation_analysis_props\nAnalysis.update_part_modeling_props\nAnalysis.update_pcb_modeling_props\nAnalysis.update_random_vibe_props\nAnalysis.update_solder_fatigue_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.html#ansys.sherlock.core.analysis.Analysis",
        "title": "ansys.sherlock.core.analysis.Analysis > ansys.sherlock.core.analysis.Analysis > Analysis",
        "section": "ansys.sherlock.core.analysis.Analysis > Analysis",
        "text": "class ansys.sherlock.core.analysis.Analysis(channel: grpc.Channel, server_version: int)\n\nContains all analysis capabilities.\n\nMethods\n\n\n\n\n\n\n\nAnalysis.get_harmonic_vibe_input_fields([...])\n\nGet harmonic vibe property fields based on the user configuration.\n\nAnalysis.get_ict_analysis_input_fields()\n\nGet ICT analysis property fields based on the user configuration.\n\nAnalysis.get_mechanical_shock_input_fields([...])\n\nGet mechanical shock property fields based on the user configuration.\n\nAnalysis.get_natural_frequency_input_fields()\n\nGet natural frequency property fields based on the user configuration.\n\nAnalysis.get_parts_list_validation_analysis_props(...)\n\nGet properties for a Part List Validation analysis.\n\nAnalysis.get_random_vibe_input_fields([...])\n\nGet random vibe property fields based on the user configuration.\n\nAnalysis.get_solder_fatigue_input_fields()\n\nGet solder fatigue property fields based on the user configuration.\n\nAnalysis.run_analysis(project, cca_name, ...)\n\nRun one or more Sherlock analyses.\n\nAnalysis.run_strain_map_analysis(project, ...)\n\nRun one or more strain map analyses.\n\nAnalysis.update_harmonic_vibe_props(project, ...)\n\nUpdate properties for a harmonic vibe analysis.\n\nAnalysis.update_ict_analysis_props(project, ...)\n\nUpdate properties for an ICT analysis.\n\nAnalysis.update_mechanical_shock_props(...)\n\nUpdate properties for a mechanical shock analysis.\n\nAnalysis.update_natural_frequency_props(...)\n\nUpdate properties for a natural frequency analysis.\n\nAnalysis.update_part_list_validation_analysis_props(...)\n\nUpdate properties for a Part List Validation analysis.\n\nAnalysis.update_part_modeling_props(project, ...)\n\nUpdate part modeling properties for a given project's CCA.\n\nAnalysis.update_pcb_modeling_props(project, ...)\n\nUpdate FEA PCB Modeling properties for one or more CCAs.\n\nAnalysis.update_random_vibe_props(project, ...)\n\nUpdate properties for a random vibe analysis.\n\nAnalysis.update_solder_fatigue_props(...)\n\nUpdate properties for a solder fatigue analysis.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props.html#update_pcb_modeling_props",
        "title": "update_pcb_modeling_props",
        "section": "update_pcb_modeling_props",
        "text": "Update FEA PCB Modeling properties for one or more CCAs.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\ncca_names (list) – Names of the CCAs to be used for the analysis.\nanalyses (list[tuple[bool | float | str | UpdatePcbModelingPropsRequestAnalysisType                | UpdatePcbModelingPropsRequestPcbModelType                | UpdatePcbModelingPropsRequestPcbMaterialModel                | ElementOrder, ...]]) – Elements consisting of the following properties:analysis_type: UpdatePcbModelingPropsRequestAnalysisType\n\nType of analysis applied.\n\npcb_model_type: UpdatePcbModelingPropsRequestPcbModelType\n\nThe PCB modeling mesh type.\n\nmodeling_region_enabled: bool\n\nIndicates if modeling regions are enabled.\n\npcb_material_model: UpdatePcbModelingPropsRequestPcbMaterialModel\n\nThe PCB modeling PCB model type.\n\npcb_max_materials: Optional[int]\n\nThe number of PCB materials for Uniform Elements and Layered Elements PCB model\ntypes. Not applicable if PCB model is Uniform or Layered.\n\npcb_elem_order: ElementOrder\n\nThe element order for PCB elements.\n\npcb_max_edge_length: float\n\nThe maximum mesh size for PCB elements.\n\npcb_max_edge_length_units: str\n\nThe length units for the maximum mesh size.\n\npcb_max_vertical: float\n\nThe maximum vertical mesh size for PCB elements.\n\npcb_max_vertical_units: str\n\nThe length units for the maximum vertical mesh size.\n\nquads_preferred: bool\n\nIndicates that the meshing engine should attempt to generate quad-shaped elements\nwhen creating the mesh.\nElements consisting of the following properties:\nType of analysis applied.\nThe PCB modeling mesh type.\nIndicates if modeling regions are enabled.\nThe PCB modeling PCB model type.\nThe number of PCB materials for Uniform Elements and Layered Elements PCB model\ntypes. Not applicable if PCB model is Uniform or Layered.\nThe element order for PCB elements.\nThe maximum mesh size for PCB elements.\nThe length units for the maximum mesh size.\nThe maximum vertical mesh size for PCB elements.\nThe length units for the maximum vertical mesh size.\nIndicates that the meshing engine should attempt to generate quad-shaped elements\nwhen creating the mesh.\nStatus code of the response. 0 for success.\nint\nupdate_pcb_modeling_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props.html#ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "title": "update_pcb_modeling_props > update_pcb_modeling_props > update_pcb_modeling_props",
        "section": "update_pcb_modeling_props > update_pcb_modeling_props",
        "text": "Analysis.update_pcb_modeling_props(project: str, cca_names: list[str], analyses: list[tuple[bool | float | str | UpdatePcbModelingPropsRequestAnalysisType | UpdatePcbModelingPropsRequestPcbModelType | UpdatePcbModelingPropsRequestPcbMaterialModel | ElementOrder, ...]]) -> int\n\nUpdate FEA PCB Modeling properties for one or more CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_names (list) – Names of the CCAs to be used for the analysis.\n\nanalyses (list[tuple[bool | float | str | UpdatePcbModelingPropsRequestAnalysisType                | UpdatePcbModelingPropsRequestPcbModelType                | UpdatePcbModelingPropsRequestPcbMaterialModel                | ElementOrder, ...]]) – Elements consisting of the following properties:analysis_type: UpdatePcbModelingPropsRequestAnalysisType\n\nType of analysis applied.\n\npcb_model_type: UpdatePcbModelingPropsRequestPcbModelType\n\nThe PCB modeling mesh type.\n\nmodeling_region_enabled: bool\n\nIndicates if modeling regions are enabled.\n\npcb_material_model: UpdatePcbModelingPropsRequestPcbMaterialModel\n\nThe PCB modeling PCB model type.\n\npcb_max_materials: Optional[int]\n\nThe number of PCB materials for Uniform Elements and Layered Elements PCB model\ntypes. Not applicable if PCB model is Uniform or Layered.\n\npcb_elem_order: ElementOrder\n\nThe element order for PCB elements.\n\npcb_max_edge_length: float\n\nThe maximum mesh size for PCB elements.\n\npcb_max_edge_length_units: str\n\nThe length units for the maximum mesh size.\n\npcb_max_vertical: float\n\nThe maximum vertical mesh size for PCB elements.\n\npcb_max_vertical_units: str\n\nThe length units for the maximum vertical mesh size.\n\nquads_preferred: bool\n\nIndicates that the meshing engine should attempt to generate quad-shaped elements\nwhen creating the mesh.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> update_request = SherlockAnalysisService_pb2.UpdatePcbModelingPropsRequest\n>>> sherlock.analysis.update_pcb_modeling_props(\n    \"Tutorial Project\",\n    [\"Main Board\"],\n    [\n        (\n            UpdatePcbModelingPropsRequestAnalysisType.HARMONIC_VIBE,\n            UpdatePcbModelingPropsRequestPcbModelType.BONDED,\n            True,\n            UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM,\n            ElementOrder.SOLID_SHELL,\n            6,\n            \"mm\",\n            3,\n            \"mm\",\n            True,\n        )\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config.html#ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PCBShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionUpdateData.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod SlotShape.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod DeletePottingRegionRequest.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra.html#ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PCBShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event.html#add_shock_event",
        "title": "add_shock_event",
        "section": "add_shock_event",
        "text": "Add a shock event to a life cycle phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nphase_name (str) – Name of the life cycle phase to add this shock event to.\nevent_name (str) – Name of the shock event.\nduration (float) – Event duration length.\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nnum_of_cycles (float) – Number of cycles for the shock event.\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\ndescription (str, optional) – Description of the shock event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_shock_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY CYCLE\"\n\"PER YEAR\"\n\"PER HOUR\"\n\"azimuth, elevation\"\n\"30,15\"\n\"x,y,z\"\n\"0,0,1\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "title": "add_shock_event > add_shock_event > add_shock_event",
        "section": "add_shock_event > add_shock_event",
        "text": "Lifecycle.add_shock_event(project: str, phase_name: str, event_name: str, duration: float, duration_units: str, num_of_cycles: float, cycle_type: str, orientation: str, load_direction: str, description: str = '') -> int\n\nAdd a shock event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nphase_name (str) – Name of the life cycle phase to add this shock event to.\n\nevent_name (str) – Name of the shock event.\n\nduration (float) – Event duration length.\n\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nnum_of_cycles (float) – Number of cycles for the shock event.\n\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\n\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription (str, optional) – Description of the shock event. The default is \"\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_shock_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"2,4,5\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate.html#ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CircularShape.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegion.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id.html#copy_potting_id",
        "title": "copy_potting_id",
        "section": "copy_potting_id",
        "text": "Id of the potting region to copy.\ncopy_potting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "title": "copy_potting_id > copy_potting_id > copy_potting_id",
        "section": "copy_potting_id > copy_potting_id",
        "text": "PottingRegionCopyData.copy_potting_id: str\n\nId of the potting region to copy."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region.html#update_potting_region",
        "title": "update_potting_region",
        "section": "update_potting_region",
        "text": "Update one or more potting regions in a specific project.\nAvailable Since: 2025R1\nrequest (UpdatePottingRegionRequest) – Contains all the information needed to update one or more potting regions per project.\nReturn codes for each request.\nlist[SherlockCommonService_pb2.ReturnCode]\nupdate_potting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region.html#ansys.sherlock.core.layer.Layer.update_potting_region",
        "title": "update_potting_region > update_potting_region > update_potting_region",
        "section": "update_potting_region > update_potting_region",
        "text": "Layer.update_potting_region(request: UpdatePottingRegionRequest) -> list[SherlockCommonService_pb2.ReturnCode]\n\nUpdate one or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest (UpdatePottingRegionRequest) – Contains all the information needed to update one or more potting regions per project.\n\nReturns\n\nReturn codes for each request.\n\nReturn type\n\nlist[SherlockCommonService_pb2.ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import PolygonalShape\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionUpdateData\n>>> from ansys.sherlock.core.types.layer_types import PottingRegion\n>>> sherlock = launch_sherlock()\n>>>\n>>> update_request1 = PottingRegionUpdateData(\n    potting_region_id_to_update=potting_id,\n    potting_region=PottingRegionData(\n        cca_name=cca_name,\n        potting_id=potting_id,\n        potting_side=potting_side,\n        potting_material=potting_material,\n        potting_units=potting_units,\n        potting_thickness=potting_thickness,\n        potting_standoff=potting_standoff,\n        shape=PolygonalShape(\n            points=[(0, 1), (5, 1), (5, 5), (1, 5)],\n            rotation=45.0\n        )\n    )\n)\n>>> update_request2 = PottingRegionUpdateData(\n    potting_region_id_to_update=potting_id,\n    potting_region=PottingRegionData(\n        cca_name=cca_name,\n        potting_id=potting_id,\n        potting_side=potting_side,\n        potting_material=potting_material,\n        potting_units=potting_units,\n        potting_thickness=potting_thickness,\n        potting_standoff=potting_standoff,\n        shape=PolygonalShape(\n            points=[(0, 1), (5, 1), (5, 5), (1, 5)],\n            rotation=0.0\n        )\n    )\n)\n>>> potting_region_requests = [\n    update_request1,\n    update_request2\n]\n>>> return_codes = sherlock.layer.update_potting_region(request)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod DeletePottingRegionRequest.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionUpdateData.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod DeletePottingRegionRequest.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/model",
        "href": "api/model.html#model",
        "title": "Model",
        "section": "Model",
        "text": "Module containing all model generation capabilities.\nModel(channel, server_version)\nContains all model generation capabilities.\nModel\nModel"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region.html#copy_potting_region",
        "title": "copy_potting_region",
        "section": "copy_potting_region",
        "text": "Copy one or more potting regions in a specific project.\nAvailable Since: 2025R1\nrequest (CopyPottingRegionRequest) – Contains all the information needed to copy one or more potting regions per project.\nReturn codes for each request.\nlist[SherlockCommonService_pb2.ReturnCode]\ncopy_potting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region.html#ansys.sherlock.core.layer.Layer.copy_potting_region",
        "title": "copy_potting_region > copy_potting_region > copy_potting_region",
        "section": "copy_potting_region > copy_potting_region",
        "text": "Layer.copy_potting_region(request: CopyPottingRegionRequest) -> list[SherlockCommonService_pb2.ReturnCode]\n\nCopy one or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest (CopyPottingRegionRequest) – Contains all the information needed to copy one or more potting regions per project.\n\nReturns\n\nReturn codes for each request.\n\nReturn type\n\nlist[SherlockCommonService_pb2.ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import CopyPottingRegionRequest\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionCopyData\n>>> sherlock = launch_sherlock()\n>>>\n>>> copy_request_example = CopyPottingRegionRequest(\n    project=project,\n    potting_region_copy_data=[\n        PottingRegionCopyData(\n            cca_name=cca_name,\n            potting_id=potting_id,\n            copy_potting_id=new_id,\n            center_x=center_x,\n            center_y=center_y\n        ),\n        PottingRegionCopyData(\n            cca_name=cca_name,\n            potting_id=new_id,\n            copy_potting_id=new_id+\"1\",\n            center_x=center_x,\n            center_y=center_y\n        )\n    ]\n)\n>>> responses_example = sherlock.layer.copy_potting_region(copy_request_example)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionDeleteData.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionDeleteData.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegion.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers.html#list_conductor_layers",
        "title": "list_conductor_layers",
        "section": "list_conductor_layers",
        "text": "List CCA conductor layers.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\nThe conductor layers of all CCAs in the project.\nlist[SherlockStackupService_pb2.ListConductorLayersResponse.CCAConductorLayerProp]\nlist_conductor_layers"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers.html#ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "title": "list_conductor_layers > list_conductor_layers > list_conductor_layers",
        "section": "list_conductor_layers > list_conductor_layers",
        "text": "Stackup.list_conductor_layers(project: str) -> list[SherlockStackupService_pb2.ListConductorLayersResponse.CCAConductorLayerProp]\n\nList CCA conductor layers.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nReturns\n\nThe conductor layers of all CCAs in the project.\n\nReturn type\n\nlist[SherlockStackupService_pb2.ListConductorLayersResponse.CCAConductorLayerProp]\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> conductorLayers = sherlock.stackup.list_conductor_layers(project=\"Tutorial\")\n>>> for layer in conductorLayers:\n>>>     properties = layer.conductorLayerProps\n>>>     for prop in properties:\n>>>     print(f\"{prop}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionDeleteData.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionCopyData.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod UpdatePottingRegionRequest.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "UpdatePottingRegionRequest.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column.html#reference_id_column",
        "title": "reference_id_column",
        "section": "reference_id_column",
        "text": "reference_id_column\nstr\nreference_id_column"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column.html#ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "title": "reference_id_column > reference_id_column > reference_id_column",
        "section": "reference_id_column > reference_id_column",
        "text": "CsvExcelFile.reference_id_column\n\nreference_id_column\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PolygonalShape.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PCBShape.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod UpdatePottingRegionRequest.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers.html#list_laminate_layers",
        "title": "list_laminate_layers",
        "section": "list_laminate_layers",
        "text": "List all laminate layers and their properties.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nThe laminate layers of all CCAs in the project.\nlist[SherlockStackupService_pb2.ListLaminatesResponse.CCALaminateProp]\nlist_laminate_layers"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers.html#ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "title": "list_laminate_layers > list_laminate_layers > list_laminate_layers",
        "section": "list_laminate_layers > list_laminate_layers",
        "text": "Stackup.list_laminate_layers(project: str) -> list[SherlockStackupService_pb2.ListLaminatesResponse.CCALaminateProp]\n\nList all laminate layers and their properties.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nReturns\n\nThe laminate layers of all CCAs in the project.\n\nReturn type\n\nlist[SherlockStackupService_pb2.ListLaminatesResponse.CCALaminateProp]\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> laminateLayers = sherlock.stackup.list_laminate_layers(project=\"Tutorial\")\n>>> for layer in laminateLayers:\n>>>     properties = layer.laminateProps\n>>>     for prop in properties:\n>>>     print(f\"{prop}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps.html#add_strain_maps",
        "title": "add_strain_maps",
        "section": "add_strain_maps",
        "text": "Add strain map files to CCAs in a Sherlock project.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project to add strain maps to.\nstrain_maps (list) – Strain maps consisting of these properties:strain_map_file: str\n\nFull path to the CSV file with the strain maps.\n\nfile_comment: str\n\nComment to associate with the file.\n\nfile_type: StrainMapsFileType\n\nStrain maps file type. Options are CSV, Excel, and Image.\n\nheader_row_count: int\n\nNumber of rows before the file’s column header.\n\nreference_id_column: str\n\nName of the column in the file with reference IDs.\n\nstrain_column: str\n\nName of the column in the file with strain values.\n\nstrain_units: str\n\nStrain units. Options are µε and ε.\n\nimage_file: StrainMapImageFile, optional\n\nThe properties of the strain map file to add.\n\nccas: list, optional\n\nList of CCA names to assign the file to. When no list is\nspecified, the file is assigned to all CCAs in the project.\nStrain maps consisting of these properties:\nFull path to the CSV file with the strain maps.\nComment to associate with the file.\nStrain maps file type. Options are CSV, Excel, and Image.\nNumber of rows before the file’s column header.\nName of the column in the file with reference IDs.\nName of the column in the file with strain values.\nStrain units. Options are µε and ε.\nThe properties of the strain map file to add.\nList of CCA names to assign the file to. When no list is\nspecified, the file is assigned to all CCAs in the project.\nStatus code of the response. 0 for success.\nint\nadd_strain_maps\nµε\nε"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps.html#ansys.sherlock.core.project.Project.add_strain_maps",
        "title": "add_strain_maps > add_strain_maps > add_strain_maps",
        "section": "add_strain_maps > add_strain_maps",
        "text": "Project.add_strain_maps(project: str, strain_maps: list) -> int\n\nAdd strain map files to CCAs in a Sherlock project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project to add strain maps to.\n\nstrain_maps (list) – Strain maps consisting of these properties:strain_map_file: str\n\nFull path to the CSV file with the strain maps.\n\nfile_comment: str\n\nComment to associate with the file.\n\nfile_type: StrainMapsFileType\n\nStrain maps file type. Options are CSV, Excel, and Image.\n\nheader_row_count: int\n\nNumber of rows before the file’s column header.\n\nreference_id_column: str\n\nName of the column in the file with reference IDs.\n\nstrain_column: str\n\nName of the column in the file with strain values.\n\nstrain_units: str\n\nStrain units. Options are µε and ε.\n\nimage_file: StrainMapImageFile, optional\n\nThe properties of the strain map file to add.\n\nccas: list, optional\n\nList of CCA names to assign the file to. When no list is\nspecified, the file is assigned to all CCAs in the project.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    StrainMapsFileType,\n    StrainMapLegendOrientation,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.add_strain_maps(\n    \"Tutorial Project\",\n        [\n            (\n                \"StrainMap.csv\",\n                \"This is the strain map file for the project\",\n                StrainMapsFileType.CSV,\n                0,\n                \"refDes\",\n                \"strain\",\n                \"µε\",\n                [\"Main Board\"]\n            )\n        ]\n    )\n>>> properties = (\n        BoardBounds([\n            (1.0, 2.0),\n            (3.0, 4.0),\n            (1.0, 2.0),\n            (1.0, 2.0)\n        ]),\n        \"in\",\n        ImageBounds(0.0, 0.0, 10.0, 8.0),\n        LegendBounds(1.0, 2.0, 4.0, 2.0),\n        StrainMapLegendOrientation.VERTICAL,\n        20.0,\n        50.0,\n        \"µε\"\n    )\n>>> sherlock.project.add_strain_maps(\n    \"Tutorial Project\",\n        [\n            (\n                \"StrainMap.jpg\",\n                \"This is the strain map image for the project\",\n                StrainMapsFileType.IMAGE,\n                properties,\n                [\"Main Board\"]\n            )\n        ]\n    )"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "Y coordinate for the center of the new potting region.\ncenter_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "PottingRegionCopyData.center_y: float\n\nY coordinate for the center of the new potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CopyPottingRegionRequest.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location.html#get_part_location",
        "title": "get_part_location",
        "section": "get_part_location",
        "text": "Return the location properties for one or more part.\nAvailable Since: 2022R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nref_des (str) – Comma separated list of reference designators of parts to retrieve locations for.\nlocation_units (str) – Valid units for a part’s location.\nPartLocation for each part that corresponds to the reference designators.\nlist[PartLocation]\nget_part_location"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location.html#ansys.sherlock.core.parts.Parts.get_part_location",
        "title": "get_part_location > get_part_location > get_part_location",
        "section": "get_part_location > get_part_location",
        "text": "Parts.get_part_location(project: str, cca_name: str, ref_des: str, location_units: str) -> list[PartLocation]\n\nReturn the location properties for one or more part.\n\nAvailable Since: 2022R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nref_des (str) – Comma separated list of reference designators of parts to retrieve locations for.\n\nlocation_units (str) – Valid units for a part’s location.\n\nReturns\n\nPartLocation for each part that corresponds to the reference designators.\n\nReturn type\n\nlist[PartLocation]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> part_locations = sherlock.parts.get_part_location(\n    project=\"Tutorial\",\n    cca_name=\"Main Board\",\n    ref_des=\"C1,C2\",\n    location_units=\"in\",\n)\n>>> print(f\"{part_locations}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields.html#ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CircularShape.model_fields: ClassVar[dict[str, FieldInfo]] = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'diameter': FieldInfo(annotation=float, required=True), 'node_count': FieldInfo(annotation=int, required=True), 'rotation': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region.html#delete_modeling_region",
        "title": "delete_modeling_region",
        "section": "delete_modeling_region",
        "text": "Delete one or more modeling regions for a specific project.\nproject (str) – Name of the Sherlock project.\ndelete_regions (list[dict[str, str]]) – Modeling regions to delete. Each dictionary should contain:\n- “cca_name”: str, Name of the CCA.\n- “region_id”: str, Unique region ID of the modeling region to delete.\nStatus code of the response. 0 for success.\nint\ndelete_modeling_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region.html#ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "title": "delete_modeling_region > delete_modeling_region > delete_modeling_region",
        "section": "delete_modeling_region > delete_modeling_region",
        "text": "Layer.delete_modeling_region(project: str, delete_regions: list[dict[str, str]]) -> int\n\nDelete one or more modeling regions for a specific project.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ndelete_regions (list[dict[str, str]]) – Modeling regions to delete. Each dictionary should contain:\n- “cca_name”: str, Name of the CCA.\n- “region_id”: str, Unique region ID of the modeling region to delete.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n        \"ODB++ Tutorial.tgz\",\n        True,\n        True,\n        True,\n        True,\n        project=\"Test\",\n        cca_name=\"Card\",\n    )\n>>> modeling_regions = [{\"cca_name\": \"Card\", \"region_id\": \"12345\"}]\n>>> sherlock.layer.delete_modeling_region(\"Test\", modeling_regions)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.html#ansyssherlockcorelifecyclelifecycle",
        "title": "ansys.sherlock.core.lifecycle.Lifecycle",
        "section": "ansys.sherlock.core.lifecycle.Lifecycle",
        "text": "Contains all life cycle management capabilities.\nLifecycle.add_harmonic_event(project, ...[, ...])\nAdd a harmonic event to a life cycle phase.\nLifecycle.add_harmonic_vibe_profiles(...)\nAdd harmonic vibe profiles to a life cycle phase.\nLifecycle.add_random_vibe_event(project, ...)\nAdd a random vibe event to a life cycle phase.\nLifecycle.add_random_vibe_profiles(project, ...)\nAdd random vibe profiles to a life cycle phase.\nLifecycle.add_shock_event(project, ...[, ...])\nAdd a shock event to a life cycle phase.\nLifecycle.add_shock_profiles(project, ...)\nAdd shock profiles to a life cycle phase.\nLifecycle.add_thermal_event(project, ...[, ...])\nAdd a thermal event to a life cycle phase.\nLifecycle.add_thermal_profiles(project, ...)\nAdd thermal profiles to a life cycle phase.\nLifecycle.create_life_phase(project, ...[, ...])\nCreate a life phase.\nLifecycle.load_harmonic_profile(project, ...)\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\nLifecycle.load_random_vibe_profile(project, ...)\nLoad random vibe profile from .csv or .dat file.\nLifecycle.load_shock_profile_dataset(...)\nLoad shock profile dataset from a .csv or .dat file.\nLifecycle.load_shock_profile_pulses(project, ...)\nLoad shock profile pulses from a .csv .dat file.\nLifecycle.load_thermal_profile(project, ...)\nLoad a thermal profile from a .dat or .csv file.\nansys.sherlock.core.lifecycle.Lifecycle\nLifecycle.add_harmonic_event\nLifecycle.add_harmonic_vibe_profiles\nLifecycle.add_random_vibe_event\nLifecycle.add_random_vibe_profiles\nLifecycle.add_shock_event\nLifecycle.add_shock_profiles\nLifecycle.add_thermal_event\nLifecycle.add_thermal_profiles\nLifecycle.create_life_phase\nLifecycle.load_harmonic_profile\nLifecycle.load_random_vibe_profile\nLifecycle.load_shock_profile_dataset\nLifecycle.load_shock_profile_pulses\nLifecycle.load_thermal_profile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.html#ansys.sherlock.core.lifecycle.Lifecycle",
        "title": "ansys.sherlock.core.lifecycle.Lifecycle > ansys.sherlock.core.lifecycle.Lifecycle > Lifecycle",
        "section": "ansys.sherlock.core.lifecycle.Lifecycle > Lifecycle",
        "text": "class ansys.sherlock.core.lifecycle.Lifecycle(channel: grpc.Channel, server_version: int)\n\nContains all life cycle management capabilities.\n\nMethods\n\n\n\n\n\n\n\nLifecycle.add_harmonic_event(project, ...[, ...])\n\nAdd a harmonic event to a life cycle phase.\n\nLifecycle.add_harmonic_vibe_profiles(...)\n\nAdd harmonic vibe profiles to a life cycle phase.\n\nLifecycle.add_random_vibe_event(project, ...)\n\nAdd a random vibe event to a life cycle phase.\n\nLifecycle.add_random_vibe_profiles(project, ...)\n\nAdd random vibe profiles to a life cycle phase.\n\nLifecycle.add_shock_event(project, ...[, ...])\n\nAdd a shock event to a life cycle phase.\n\nLifecycle.add_shock_profiles(project, ...)\n\nAdd shock profiles to a life cycle phase.\n\nLifecycle.add_thermal_event(project, ...[, ...])\n\nAdd a thermal event to a life cycle phase.\n\nLifecycle.add_thermal_profiles(project, ...)\n\nAdd thermal profiles to a life cycle phase.\n\nLifecycle.create_life_phase(project, ...[, ...])\n\nCreate a life phase.\n\nLifecycle.load_harmonic_profile(project, ...)\n\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\n\nLifecycle.load_random_vibe_profile(project, ...)\n\nLoad random vibe profile from .csv or .dat file.\n\nLifecycle.load_shock_profile_dataset(...)\n\nLoad shock profile dataset from a .csv or .dat file.\n\nLifecycle.load_shock_profile_pulses(project, ...)\n\nLoad shock profile pulses from a .csv .dat file.\n\nLifecycle.load_thermal_profile(project, ...)\n\nLoad a thermal profile from a .dat or .csv file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "RectangularShape.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units.html#temperature_units",
        "title": "temperature_units",
        "section": "temperature_units",
        "text": "temperature_units\nstr\ntemperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units.html#ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "title": "temperature_units > temperature_units > temperature_units",
        "section": "temperature_units > temperature_units",
        "text": "CsvExcelFile.temperature_units\n\ntemperature_units\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations.html#update_parts_locations",
        "title": "update_parts_locations",
        "section": "update_parts_locations",
        "text": "Update one or more part locations.\nAvailable Since: 2022R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\npart_loc (list[tuple[str, str, str, str, str, str, str]]) – List defining the part locations. The list consists\nof these properties:refDes: str\n\nReference designator of the part.\n\nx: str\n\nValue for the x coordinate.\n\ny: str\n\nValue for the y coordinate.\n\nrotation: str\n\nRotation.\n\nlocation_units: str\n\nLocations units.\n\nboard_side: str\n\nBoard side.\n\nmirrored: str\n\nMirrored.\nList defining the part locations. The list consists\nof these properties:\nReference designator of the part.\nValue for the x coordinate.\nValue for the y coordinate.\nRotation.\nLocations units.\nBoard side.\nMirrored.\nStatus code of the response. 0 for success.\nint\nupdate_parts_locations"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations.html#ansys.sherlock.core.parts.Parts.update_parts_locations",
        "title": "update_parts_locations > update_parts_locations > update_parts_locations",
        "section": "update_parts_locations > update_parts_locations",
        "text": "Parts.update_parts_locations(project: str, cca_name: str, part_loc: list[tuple[str, str, str, str, str, str, str]]) -> int\n\nUpdate one or more part locations.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\npart_loc (list[tuple[str, str, str, str, str, str, str]]) – List defining the part locations. The list consists\nof these properties:refDes: str\n\nReference designator of the part.\n\nx: str\n\nValue for the x coordinate.\n\ny: str\n\nValue for the y coordinate.\n\nrotation: str\n\nRotation.\n\nlocation_units: str\n\nLocations units.\n\nboard_side: str\n\nBoard side.\n\nmirrored: str\n\nMirrored.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_locations(\n    \"Test\",\n    \"Card\",\n    [\n        (\"C1\", \"-2.7\", \"-1.65\", \"0\", \"in\", \"TOP\", \"False\"),\n        (\"J1\", \"-3.55\", \"-2.220446049250313E-16\", \"90\", \"in\", \"TOP\", \"False\"),\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "SlotShape.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema.html#ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod SlotShape.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.html#ansyssherlockcoretypeslayer_typesupdatepottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "text": "Contains the properties of a potting region update per project.\nUpdatePottingRegionRequest.construct([...])\n\nUpdatePottingRegionRequest.copy(*[, ...])\nReturns a copy of the model.\nUpdatePottingRegionRequest.dict(*[, ...])\n\nUpdatePottingRegionRequest.from_orm(obj)\n\nUpdatePottingRegionRequest.json(*[, ...])\n\nUpdatePottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nUpdatePottingRegionRequest.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nUpdatePottingRegionRequest.model_dump(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nUpdatePottingRegionRequest.model_dump_json(*)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nUpdatePottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nUpdatePottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nUpdatePottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nUpdatePottingRegionRequest.model_rebuild(*)\nTry to rebuild the pydantic-core schema for the model.\nUpdatePottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nUpdatePottingRegionRequest.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nUpdatePottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nUpdatePottingRegionRequest.parse_file(path, *)\n\nUpdatePottingRegionRequest.parse_obj(obj)\n\nUpdatePottingRegionRequest.parse_raw(b, *[, ...])\n\nUpdatePottingRegionRequest.schema([...])\n\nUpdatePottingRegionRequest.schema_json(*[, ...])\n\nUpdatePottingRegionRequest.str_validation(...)\nValidate string fields listed.\nUpdatePottingRegionRequest.update_forward_refs(...)\n\nUpdatePottingRegionRequest.validate(value)\n\nUpdatePottingRegionRequest.model_computed_fields\n\nUpdatePottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nUpdatePottingRegionRequest.model_extra\nGet extra fields set during validation.\nUpdatePottingRegionRequest.model_fields\n\nUpdatePottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nUpdatePottingRegionRequest.project\nName of the Sherlock project.\nUpdatePottingRegionRequest.update_potting_regions\nList of potting region data to update.\nansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest\nUpdatePottingRegionRequest.construct\nUpdatePottingRegionRequest.copy\nUpdatePottingRegionRequest.dict\nUpdatePottingRegionRequest.from_orm\nUpdatePottingRegionRequest.json\nUpdatePottingRegionRequest.model_construct\nUpdatePottingRegionRequest.model_copy\nUpdatePottingRegionRequest.model_dump\nUpdatePottingRegionRequest.model_dump_json\nUpdatePottingRegionRequest.model_json_schema\nUpdatePottingRegionRequest.model_parametrized_name\nUpdatePottingRegionRequest.model_post_init\nUpdatePottingRegionRequest.model_rebuild\nUpdatePottingRegionRequest.model_validate\nUpdatePottingRegionRequest.model_validate_json\nUpdatePottingRegionRequest.model_validate_strings\nUpdatePottingRegionRequest.parse_file\nUpdatePottingRegionRequest.parse_obj\nUpdatePottingRegionRequest.parse_raw\nUpdatePottingRegionRequest.schema\nUpdatePottingRegionRequest.schema_json\nUpdatePottingRegionRequest.str_validation\nUpdatePottingRegionRequest.update_forward_refs\nUpdatePottingRegionRequest.validate\nUpdatePottingRegionRequest.model_computed_fields\nUpdatePottingRegionRequest.model_config\nUpdatePottingRegionRequest.model_extra\nUpdatePottingRegionRequest.model_fields\nUpdatePottingRegionRequest.model_fields_set\nUpdatePottingRegionRequest.project\nUpdatePottingRegionRequest.update_potting_regions"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > UpdatePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > UpdatePottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest(*, project: str, update_potting_regions: list[PottingRegionUpdateData])\n\nContains the properties of a potting region update per project.\n\nMethods\n\n\n\n\n\n\n\nUpdatePottingRegionRequest.construct([...])\n\n\n\nUpdatePottingRegionRequest.copy(*[, ...])\n\nReturns a copy of the model.\n\nUpdatePottingRegionRequest.dict(*[, ...])\n\n\n\nUpdatePottingRegionRequest.from_orm(obj)\n\n\n\nUpdatePottingRegionRequest.json(*[, ...])\n\n\n\nUpdatePottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nUpdatePottingRegionRequest.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nUpdatePottingRegionRequest.model_dump(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nUpdatePottingRegionRequest.model_dump_json(*)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nUpdatePottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nUpdatePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nUpdatePottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nUpdatePottingRegionRequest.model_rebuild(*)\n\nTry to rebuild the pydantic-core schema for the model.\n\nUpdatePottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nUpdatePottingRegionRequest.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nUpdatePottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nUpdatePottingRegionRequest.parse_file(path, *)\n\n\n\nUpdatePottingRegionRequest.parse_obj(obj)\n\n\n\nUpdatePottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nUpdatePottingRegionRequest.schema([...])\n\n\n\nUpdatePottingRegionRequest.schema_json(*[, ...])\n\n\n\nUpdatePottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nUpdatePottingRegionRequest.update_forward_refs(...)\n\n\n\nUpdatePottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nUpdatePottingRegionRequest.model_computed_fields\n\n\n\nUpdatePottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nUpdatePottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nUpdatePottingRegionRequest.model_fields\n\n\n\nUpdatePottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nUpdatePottingRegionRequest.project\n\nName of the Sherlock project.\n\nUpdatePottingRegionRequest.update_potting_regions\n\nList of potting region data to update.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json.html#ansys.sherlock.core.types.layer_types.CircularShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CircularShape.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionUpdateData.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PolygonalShape.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionUpdateData.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm.html#ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CircularShape.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column.html#temperature_column",
        "title": "temperature_column",
        "section": "temperature_column",
        "text": "temperature_column\nstr\ntemperature_column"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column.html#ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "title": "temperature_column > temperature_column > temperature_column",
        "section": "temperature_column > temperature_column",
        "text": "CsvExcelFile.temperature_column\n\ntemperature_column\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "RectangularShape.model_fields: ClassVar[dict[str, FieldInfo]] = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'length': FieldInfo(annotation=float, required=True), 'rotation': FieldInfo(annotation=float, required=True), 'width': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod CopyPottingRegionRequest.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side.html#potting_side",
        "title": "potting_side",
        "section": "potting_side",
        "text": "The potting side, options are “TOP”, “BOT”, or “BOTTOM”.\npotting_side"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "title": "potting_side > potting_side > potting_side",
        "section": "potting_side > potting_side",
        "text": "PottingRegion.potting_side: str\n\nThe potting side, options are “TOP”, “BOT”, or “BOTTOM”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod UpdatePottingRegionRequest.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x.html#ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "CircularShape.center_x: float\n\nfloat\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "Id to assign to the new potting region.\npotting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegionCopyData.potting_id: str\n\nId to assign to the new potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props.html#update_ict_analysis_props",
        "title": "update_ict_analysis_props",
        "section": "update_ict_analysis_props",
        "text": "Update properties for an ICT analysis.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\nict_analysis_properties (list[dict[str, bool | float | int | str]]) – ICT analysis properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nict_application_time: float\n\nSpecifies the amount of time to complete one ICT event.\n\nict_application_time_units: str\n\nApplication time units.\nOptions are \"ms\", \"sec\", \"min\", \"hr\", \"day\", \"year\".\n\nict_number_of_events: int\n\nSpecifies the number of events to apply to the application time when computing\nthe time to failure for a component.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nict_result_count: int\n\nThe number of ICT result layers to generate. This parameter is for use with\nthermal analysis.\nICT analysis properties for a CCA consisting of these properties:\nName of the CCA.\nSpecifies the amount of time to complete one ICT event.\nApplication time units.\nOptions are \"ms\", \"sec\", \"min\", \"hr\", \"day\", \"year\".\nSpecifies the number of events to apply to the application time when computing\nthe time to failure for a component.\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nThe number of ICT result layers to generate. This parameter is for use with\nthermal analysis.\nStatus code of the response. 0 for success.\nint\nupdate_ict_analysis_props\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props.html#ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "title": "update_ict_analysis_props > update_ict_analysis_props > update_ict_analysis_props",
        "section": "update_ict_analysis_props > update_ict_analysis_props",
        "text": "Analysis.update_ict_analysis_props(project: str, ict_analysis_properties: list[dict[str, bool | float | int | str]]) -> int\n\nUpdate properties for an ICT analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nict_analysis_properties (list[dict[str, bool | float | int | str]]) – ICT analysis properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nict_application_time: float\n\nSpecifies the amount of time to complete one ICT event.\n\nict_application_time_units: str\n\nApplication time units.\nOptions are \"ms\", \"sec\", \"min\", \"hr\", \"day\", \"year\".\n\nict_number_of_events: int\n\nSpecifies the number of events to apply to the application time when computing\nthe time to failure for a component.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nict_result_count: int\n\nThe number of ICT result layers to generate. This parameter is for use with\nthermal analysis.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_ict_analysis_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"ict_application_time\": 2,\n        \"ict_application_time_units\": \"sec\",\n        \"ict_number_of_events\": 10,\n        \"part_validation_enabled\": False,\n        \"require_material_assignment_enabled\": False,\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PCBShape.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionCopyData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod DeletePottingRegionRequest.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionCopyData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionDeleteData.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "RectangularShape.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles.html#add_random_vibe_profiles",
        "title": "add_random_vibe_profiles",
        "section": "add_random_vibe_profiles",
        "text": "Add random vibe profiles to a life cycle phase.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\nrandom_vibe_profiles (list[tuple[str, str, str, str, str, list[tuple[float, float]]]]) – Random vibe profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the random vibe profile to.\n\nevent_name: str\n\nName of the random vibe event.\n\nprofile_name: str\n\nName of the random vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nampl_units: str\n\nAmplitude units. Options are \"G2/Hz\", \"m2/s4/Hz\", \"mm2/s4/Hz\",                 \"in2/s4/Hz\", and \"ft2/s4/Hz\".\n\nrandom_vibe_profile_entries: list[tuple[float, float]]\n\nRandom vibe profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the profile entry expressed in frequency units.\n\namplitude: float\n\nAmplitude of the profile entry expressed in amplitude units.\nRandom vibe profiles consisting of these properties:\nName of the life cycle phase to add the random vibe profile to.\nName of the random vibe event.\nName of the random vibe profile.\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nAmplitude units. Options are \"G2/Hz\", \"m2/s4/Hz\", \"mm2/s4/Hz\",                 \"in2/s4/Hz\", and \"ft2/s4/Hz\".\nRandom vibe profile entries consisting of these properties:\nFrequency of the profile entry expressed in frequency units.\nAmplitude of the profile entry expressed in amplitude units.\nStatus code of the response. 0 for success.\nint\nadd_random_vibe_profiles\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"G2/Hz\"\n\"m2/s4/Hz\"\n\"mm2/s4/Hz\"\n\"in2/s4/Hz\"\n\"ft2/s4/Hz\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "title": "add_random_vibe_profiles > add_random_vibe_profiles > add_random_vibe_profiles",
        "section": "add_random_vibe_profiles > add_random_vibe_profiles",
        "text": "Lifecycle.add_random_vibe_profiles(project: str, random_vibe_profiles: list[tuple[str, str, str, str, str, list[tuple[float, float]]]])\n\nAdd random vibe profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nrandom_vibe_profiles (list[tuple[str, str, str, str, str, list[tuple[float, float]]]]) – Random vibe profiles consisting of these properties:phase_name: str\n\nName of the life cycle phase to add the random vibe profile to.\n\nevent_name: str\n\nName of the random vibe event.\n\nprofile_name: str\n\nName of the random vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nampl_units: str\n\nAmplitude units. Options are \"G2/Hz\", \"m2/s4/Hz\", \"mm2/s4/Hz\",                 \"in2/s4/Hz\", and \"ft2/s4/Hz\".\n\nrandom_vibe_profile_entries: list[tuple[float, float]]\n\nRandom vibe profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the profile entry expressed in frequency units.\n\namplitude: float\n\nAmplitude of the profile entry expressed in amplitude units.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_random_vibe_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_random_vibe_profiles(\n    \"Test\",\n     [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"HZ\",\n        \"G2/Hz\",\n        [(4,8), (5, 50)],\n    )]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CopyPottingRegionRequest.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate.html#ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod SlotShape.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "UpdatePottingRegionRequest.model_fields: ClassVar[dict[str, FieldInfo]] = {'project': FieldInfo(annotation=str, required=True), 'update_potting_regions': FieldInfo(annotation=list[PottingRegionUpdateData], required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegion.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x.html#image_x",
        "title": "image_x",
        "section": "image_x",
        "text": "x coordinate of the upper left corner\nfloat\nimage_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x.html#ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "title": "image_x > image_x > image_x",
        "section": "image_x > image_x",
        "text": "ImageBounds.image_x\n\nx coordinate of the upper left corner\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegion.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CopyPottingRegionRequest.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CopyPottingRegionRequest.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file.html#update_test_points_by_file",
        "title": "update_test_points_by_file",
        "section": "update_test_points_by_file",
        "text": "Update test point properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nfile_path (str) – Path for the CSV file with the test point properties.\nStatus code of the response. 0 for success.\nint\nupdate_test_points_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file.html#ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "title": "update_test_points_by_file > update_test_points_by_file > update_test_points_by_file",
        "section": "update_test_points_by_file > update_test_points_by_file",
        "text": "Layer.update_test_points_by_file(project: str, cca_name: str, file_path: str) -> int\n\nUpdate test point properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nfile_path (str) – Path for the CSV file with the test point properties.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_test_points_by_file(\n    \"Test\",\n    \"Card\",\n    \"TestPointsImport.csv\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel.html#exporttracemodel",
        "title": "exportTraceModel",
        "section": "exportTraceModel",
        "text": "Export a trace model to a specified output file.\nAvailable Since: 2024R2\nlayer_params (list[bool | int | float | str]) – list of parameters for export a trace model of a single copper layer.\nStatus code of the response. 0 for success.\nint\nexportTraceModel"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel.html#ansys.sherlock.core.model.Model.exportTraceModel",
        "title": "exportTraceModel > exportTraceModel > exportTraceModel",
        "section": "exportTraceModel > exportTraceModel",
        "text": "Model.exportTraceModel(layer_params: list[bool | int | float | str]) -> int\n\nExport a trace model to a specified output file.\n\nAvailable Since: 2024R2\n\nParameters\n\nlayer_params (list[bool | int | float | str]) – list of parameters for export a trace model of a single copper layer.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.types.analysis_types import ElementOrder\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.api.sherlock.v0 import SherlockModelService_pb2\n>>> sherlock = launcher.launch_sherlock()\n>>> list_of_params_for_layers = []\n>>> list_of_params_for_layers.append(\n        sherlock.model.createExportTraceCopperLayerParams(\n            \"Tutorial Project\",\n            \"Main Board\",\n            \".\\\\outputfile_path.stp\",\n            \"copper-01.odb\",\n            False,\n            False,\n            False,\n            False,\n            \"mm\",\n            SherlockModelService_pb2.MeshType.NONE,\n            False,\n            SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n            ElementOrder.LINEAR,\n            1.0,\n            \"mm\".\n            1,\n            False,\n            1.0,\n            \"mm\",\n            1.0\n        )\n    )\n>>> sherlock.model.exportTraceModel(list_of_params_for_layers)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "RectangularShape.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.html#ansyssherlockcoretypeslayer_typescopypottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "text": "Request to delete 1 or more potting regions.\nCopyPottingRegionRequest.construct([_fields_set])\n\nCopyPottingRegionRequest.copy(*[, include, ...])\nReturns a copy of the model.\nCopyPottingRegionRequest.dict(*[, include, ...])\n\nCopyPottingRegionRequest.from_orm(obj)\n\nCopyPottingRegionRequest.json(*[, include, ...])\n\nCopyPottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nCopyPottingRegionRequest.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nCopyPottingRegionRequest.model_dump(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nCopyPottingRegionRequest.model_dump_json(*)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nCopyPottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nCopyPottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCopyPottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCopyPottingRegionRequest.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nCopyPottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nCopyPottingRegionRequest.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nCopyPottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCopyPottingRegionRequest.parse_file(path, *)\n\nCopyPottingRegionRequest.parse_obj(obj)\n\nCopyPottingRegionRequest.parse_raw(b, *[, ...])\n\nCopyPottingRegionRequest.schema([by_alias, ...])\n\nCopyPottingRegionRequest.schema_json(*[, ...])\n\nCopyPottingRegionRequest.str_validation(...)\nValidate string fields listed.\nCopyPottingRegionRequest.update_forward_refs(...)\n\nCopyPottingRegionRequest.validate(value)\n\nCopyPottingRegionRequest.model_computed_fields\n\nCopyPottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCopyPottingRegionRequest.model_extra\nGet extra fields set during validation.\nCopyPottingRegionRequest.model_fields\n\nCopyPottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nCopyPottingRegionRequest.project\nName of the project containing the potting region(s) to be copied.\nCopyPottingRegionRequest.potting_region_copy_data\nData identifying which potting regions to copy and what potting regions to copy from.\nansys.sherlock.core.types.layer_types.CopyPottingRegionRequest\nCopyPottingRegionRequest.construct\nCopyPottingRegionRequest.copy\nCopyPottingRegionRequest.dict\nCopyPottingRegionRequest.from_orm\nCopyPottingRegionRequest.json\nCopyPottingRegionRequest.model_construct\nCopyPottingRegionRequest.model_copy\nCopyPottingRegionRequest.model_dump\nCopyPottingRegionRequest.model_dump_json\nCopyPottingRegionRequest.model_json_schema\nCopyPottingRegionRequest.model_parametrized_name\nCopyPottingRegionRequest.model_post_init\nCopyPottingRegionRequest.model_rebuild\nCopyPottingRegionRequest.model_validate\nCopyPottingRegionRequest.model_validate_json\nCopyPottingRegionRequest.model_validate_strings\nCopyPottingRegionRequest.parse_file\nCopyPottingRegionRequest.parse_obj\nCopyPottingRegionRequest.parse_raw\nCopyPottingRegionRequest.schema\nCopyPottingRegionRequest.schema_json\nCopyPottingRegionRequest.str_validation\nCopyPottingRegionRequest.update_forward_refs\nCopyPottingRegionRequest.validate\nCopyPottingRegionRequest.model_computed_fields\nCopyPottingRegionRequest.model_config\nCopyPottingRegionRequest.model_extra\nCopyPottingRegionRequest.model_fields\nCopyPottingRegionRequest.model_fields_set\nCopyPottingRegionRequest.project\nCopyPottingRegionRequest.potting_region_copy_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > CopyPottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > CopyPottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest(*, project: str, potting_region_copy_data: list[PottingRegionCopyData])\n\nRequest to delete 1 or more potting regions.\n\nMethods\n\n\n\n\n\n\n\nCopyPottingRegionRequest.construct([_fields_set])\n\n\n\nCopyPottingRegionRequest.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nCopyPottingRegionRequest.dict(*[, include, ...])\n\n\n\nCopyPottingRegionRequest.from_orm(obj)\n\n\n\nCopyPottingRegionRequest.json(*[, include, ...])\n\n\n\nCopyPottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nCopyPottingRegionRequest.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nCopyPottingRegionRequest.model_dump(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nCopyPottingRegionRequest.model_dump_json(*)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nCopyPottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nCopyPottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCopyPottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCopyPottingRegionRequest.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCopyPottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nCopyPottingRegionRequest.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nCopyPottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCopyPottingRegionRequest.parse_file(path, *)\n\n\n\nCopyPottingRegionRequest.parse_obj(obj)\n\n\n\nCopyPottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nCopyPottingRegionRequest.schema([by_alias, ...])\n\n\n\nCopyPottingRegionRequest.schema_json(*[, ...])\n\n\n\nCopyPottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nCopyPottingRegionRequest.update_forward_refs(...)\n\n\n\nCopyPottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCopyPottingRegionRequest.model_computed_fields\n\n\n\nCopyPottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCopyPottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nCopyPottingRegionRequest.model_fields\n\n\n\nCopyPottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nCopyPottingRegionRequest.project\n\nName of the project containing the potting region(s) to be copied.\n\nCopyPottingRegionRequest.potting_region_copy_data\n\nData identifying which potting regions to copy and what potting regions to copy from.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod UpdatePottingRegionRequest.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#release-notes",
        "title": "Release notes",
        "section": "Release notes",
        "text": "This document contains the release notes for the project.\nRelease notes"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#081---2024-12-10",
        "title": "Release notes > 0.8.1 - 2024-12-10",
        "section": "0.8.1 - 2024-12-10",
        "text": "0.8.1 - 2024-12-10"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: conf.py issue #467\nfix: import statements #470\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#documentation",
        "title": "Release notes > Documentation",
        "section": "Documentation",
        "text": "MAINT: Bump pytest from 8.3.3 to 8.3.4 #459\nMAINT: Bump ansys-sphinx-theme from 1.2.1 to 1.2.3 #463\nDocumentation"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#080---2024-12-10",
        "title": "Release notes > 0.8.0 - 2024-12-10",
        "section": "0.8.0 - 2024-12-10",
        "text": "0.8.0 - 2024-12-10"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: conf.py issue #467\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#080---2024-12-09",
        "title": "Release notes > 0.8.0 - 2024-12-09",
        "section": "0.8.0 - 2024-12-09",
        "text": "0.8.0 - 2024-12-09"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#added",
        "title": "Release notes > Added",
        "section": "Added",
        "text": "feat: launching a specific version of Sherlock #431\nAdded"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: proper AUTHORS file #438\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#documentation",
        "title": "Release notes > Documentation",
        "section": "Documentation",
        "text": "MAINT: add action changelog and changelog.rst for release notes #426\nUpdate unit test for HV strain map analysis. #428\nMAINT: Bump ansys-sphinx-theme from 1.1.6 to 1.1.7 #429\nMAINT: Bump grpcio from 1.67.0 to 1.67.1 #433\nMAINT: Bump pytest-cov from 5.0.0 to 6.0.0 #434\nMAINT: Bump ansys-sphinx-theme from 1.1.7 to 1.2.0 #436\nfeat: Adding version check to all API methods #440\nfeat: Keith/potting region update #441\nfix: Analysis.update_harmonic_vibe_props(): add support for setting model source and strain map natural frequency #442\ndocs: update the pull request template #446\nfeat:Keith/copy delete potting region #448\nMAINT: Bump ansys-sphinx-theme from 1.2.0 to 1.2.1 #449\ndoc: project logo #450\nMAINT: Bump codecov/codecov-action from 4 to 5 #451\nfeat: add type hints #454\nfeat: increment version of ansys-api-sherlock to 0.1.35 #461\nDocumentation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegion.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegion.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.html#ansyssherlockcoretypesproject_typeslegendbounds",
        "title": "ansys.sherlock.core.types.project_types.LegendBounds",
        "section": "ansys.sherlock.core.types.project_types.LegendBounds",
        "text": "Contains the properties of the legend bounds.\nLegendBounds.legend_x\nx coordinate of the upper left corner\nLegendBounds.legend_y\ny coordinate of the upper left corner\nLegendBounds.height\nheight of the legend\nLegendBounds.width\nwidth of the legend\nansys.sherlock.core.types.project_types.LegendBounds\nLegendBounds.legend_x\nLegendBounds.legend_y\nLegendBounds.height\nLegendBounds.width"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.html#ansys.sherlock.core.types.project_types.LegendBounds",
        "title": "ansys.sherlock.core.types.project_types.LegendBounds > ansys.sherlock.core.types.project_types.LegendBounds > LegendBounds",
        "section": "ansys.sherlock.core.types.project_types.LegendBounds > LegendBounds",
        "text": "class ansys.sherlock.core.types.project_types.LegendBounds(legend_x: float, legend_y: float, height: float, width: float)\n\nContains the properties of the legend bounds.\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nLegendBounds.legend_x\n\nx coordinate of the upper left corner\n\nLegendBounds.legend_y\n\ny coordinate of the upper left corner\n\nLegendBounds.height\n\nheight of the legend\n\nLegendBounds.width\n\nwidth of the legend\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PCBShape.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod UpdatePottingRegionRequest.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region.html#copy_modeling_region",
        "title": "copy_modeling_region",
        "section": "copy_modeling_region",
        "text": "Copy one or more modeling regions in a specific project.\nproject (str) – Name of the Sherlock project.\ncopy_regions (list[dict[str, float | str]]) – Modeling regions to copy along with their corresponding “copy to” parameters.\nEach dictionary should contain:cca_name\n\nstr\n\nName of the CCA.\n\nregion_id\n\nstr\n\nRegion ID of the existing modeling region to copy.\n\nregion_id_copy\n\nstr\n\nRegion ID of the modeling region copy. Must be unique.\n\ncenter_x\n\nfloat\n\nThe center x coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\n\ncenter_y\n\nfloat\n\nThe center y coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\nModeling regions to copy along with their corresponding “copy to” parameters.\nEach dictionary should contain:\nName of the CCA.\nRegion ID of the existing modeling region to copy.\nRegion ID of the modeling region copy. Must be unique.\nThe center x coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\nThe center y coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\nStatus code of the response. 0 for success.\nint\ncopy_modeling_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region.html#ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "title": "copy_modeling_region > copy_modeling_region > copy_modeling_region",
        "section": "copy_modeling_region > copy_modeling_region",
        "text": "Layer.copy_modeling_region(project: str, copy_regions: list[dict[str, float | str]]) -> int\n\nCopy one or more modeling regions in a specific project.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncopy_regions (list[dict[str, float | str]]) – Modeling regions to copy along with their corresponding “copy to” parameters.\nEach dictionary should contain:cca_name\n\nstr\n\nName of the CCA.\n\nregion_id\n\nstr\n\nRegion ID of the existing modeling region to copy.\n\nregion_id_copy\n\nstr\n\nRegion ID of the modeling region copy. Must be unique.\n\ncenter_x\n\nfloat\n\nThe center x coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\n\ncenter_y\n\nfloat\n\nThe center y coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Tutorial Project\",\n    cca_name=\"Card\",\n)\n>>> modeling_regions = [\n>>>     {\n>>>         \"cca_name\": \"Card\",\n>>>         \"region_id\": \"Region001\",\n>>>         \"region_id_copy\": \"RegionCopy001\",\n>>>         \"center_x\": 10.0,\n>>>         \"center_y\": 20.0,\n>>>     }\n>>> ]\n>>> result = sherlock.layer.copy_modeling_region(\"Tutorial Project\", modeling_regions)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.html#ansyssherlockcorestackupstackup",
        "title": "ansys.sherlock.core.stackup.Stackup",
        "section": "ansys.sherlock.core.stackup.Stackup",
        "text": "Contains all stackup management capabilities.\nStackup.gen_stackup(project, cca_name, ...)\nGenerate a new stackup from given properties.\nStackup.get_layer_count(project, cca_name)\nGet the number of CCA layers in a stackup.\nStackup.get_stackup_props(project, cca_name)\nGet the stackup properties from a CCA.\nStackup.get_total_conductor_thickness(...)\nReturn the total conductor thickness.\nStackup.list_conductor_layers(project)\nList CCA conductor layers.\nStackup.list_laminate_layers(project)\nList all laminate layers and their properties.\nStackup.update_conductor_layer(project, ...)\nUpdate a conductor layer with given properties.\nStackup.update_laminate_layer(project, ...)\nUpdate a laminate layer with given properties.\nansys.sherlock.core.stackup.Stackup\nStackup.gen_stackup\nStackup.get_layer_count\nStackup.get_stackup_props\nStackup.get_total_conductor_thickness\nStackup.list_conductor_layers\nStackup.list_laminate_layers\nStackup.update_conductor_layer\nStackup.update_laminate_layer"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.html#ansys.sherlock.core.stackup.Stackup",
        "title": "ansys.sherlock.core.stackup.Stackup > ansys.sherlock.core.stackup.Stackup > Stackup",
        "section": "ansys.sherlock.core.stackup.Stackup > Stackup",
        "text": "class ansys.sherlock.core.stackup.Stackup(channel: grpc.Channel, server_version: int)\n\nContains all stackup management capabilities.\n\nMethods\n\n\n\n\n\n\n\nStackup.gen_stackup(project, cca_name, ...)\n\nGenerate a new stackup from given properties.\n\nStackup.get_layer_count(project, cca_name)\n\nGet the number of CCA layers in a stackup.\n\nStackup.get_stackup_props(project, cca_name)\n\nGet the stackup properties from a CCA.\n\nStackup.get_total_conductor_thickness(...)\n\nReturn the total conductor thickness.\n\nStackup.list_conductor_layers(project)\n\nList CCA conductor layers.\n\nStackup.list_laminate_layers(project)\n\nList all laminate layers and their properties.\n\nStackup.update_conductor_layer(project, ...)\n\nUpdate a conductor layer with given properties.\n\nStackup.update_laminate_layer(project, ...)\n\nUpdate a laminate layer with given properties.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.check",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.check.html#check",
        "title": "check",
        "section": "check",
        "text": "Perform a health check on the gRPC connection.\nWhether the Sherlock client is connected via gRPC.\nbool\ncheck"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.check",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.check.html#ansys.sherlock.core.common.Common.check",
        "title": "check > check > check",
        "section": "check > check",
        "text": "Common.check() -> bool\n\nPerform a health check on the gRPC connection.\n\nReturns\n\nWhether the Sherlock client is connected via gRPC.\n\nReturn type\n\nbool"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod UpdatePottingRegionRequest.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CircularShape.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod RectangularShape.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props.html#update_solder_fatigue_props",
        "title": "update_solder_fatigue_props",
        "section": "update_solder_fatigue_props",
        "text": "Update properties for a solder fatigue analysis.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\nsolder_fatigue_properties (list[dict[str, bool | float | str]]) – Mechanical shock properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nsolder_material: str\n\nSolder material. The default is None.\n\npart_temp: float\n\nPart temperature. The default is None.\n\npart_temp_units: str\n\nPart temperature units. The default is None.\n\nuse_part_temp_rise_min: bool\n\nwhether to apply min temp rise. The default is None.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\nMechanical shock properties for a CCA consisting of these properties:\nName of the CCA.\nSolder material. The default is None.\nPart temperature. The default is None.\nPart temperature units. The default is None.\nwhether to apply min temp rise. The default is None.\nWhether to enable part validation. The default is None.\nStatus code of the response. 0 for success.\nint\nupdate_solder_fatigue_props\nNone\nNone\nNone\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props.html#ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "title": "update_solder_fatigue_props > update_solder_fatigue_props > update_solder_fatigue_props",
        "section": "update_solder_fatigue_props > update_solder_fatigue_props",
        "text": "Analysis.update_solder_fatigue_props(project: str, solder_fatigue_properties: list[dict[str, bool | float | str]]) -> int\n\nUpdate properties for a solder fatigue analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nsolder_fatigue_properties (list[dict[str, bool | float | str]]) – Mechanical shock properties for a CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nsolder_material: str\n\nSolder material. The default is None.\n\npart_temp: float\n\nPart temperature. The default is None.\n\npart_temp_units: str\n\nPart temperature units. The default is None.\n\nuse_part_temp_rise_min: bool\n\nwhether to apply min temp rise. The default is None.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_solder_fatigue_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"solder_material\": \"TIN-LEAD (63SN37PB)\",\n        \"part_temp\": 70,\n        \"part_temp_units\": \"F\",\n        \"use_part_temp_rise_min\": True,\n        \"part_validation_enabled\": True\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod SlotShape.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "UpdatePottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling.html#enable_lead_modeling",
        "title": "enable_lead_modeling",
        "section": "enable_lead_modeling",
        "text": "Enable lead modeling for leaded parts.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nStatus code of the response. 0 for success.\nint\nenable_lead_modeling"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling.html#ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "title": "enable_lead_modeling > enable_lead_modeling > enable_lead_modeling",
        "section": "enable_lead_modeling > enable_lead_modeling",
        "text": "Parts.enable_lead_modeling(project: str, cca_name: str)\n\nEnable lead modeling for leaded parts.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.enable_lead_modeling(\n    \"Test\",\n    \"Card\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy.html#ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "SlotShape.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionUpdateData.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod SlotShape.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionDeleteData.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y.html#ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "CircularShape.center_y: float\n\nfloat\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionDeleteData.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "The potting ID.\npotting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegion.potting_id: str\n\nThe potting ID."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count.html#header_row_count",
        "title": "header_row_count",
        "section": "header_row_count",
        "text": "header_row_count\nint\nheader_row_count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count.html#ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "title": "header_row_count > header_row_count > header_row_count",
        "section": "header_row_count > header_row_count",
        "text": "CsvExcelFile.header_row_count\n\nheader_row_count\n\nType\n\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegion.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PolygonalShape.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegion.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegion.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy.html#ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "SlotShape.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units.html#min_temperature_units",
        "title": "min_temperature_units",
        "section": "min_temperature_units",
        "text": "min_temperature_units\nstr\nmin_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units.html#ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "title": "min_temperature_units > min_temperature_units > min_temperature_units",
        "section": "min_temperature_units > min_temperature_units",
        "text": "ImageFile.min_temperature_units\n\nmin_temperature_units\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.connect_grpc_channel",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.connect_grpc_channel.html#connect_grpc_channel",
        "title": "connect_grpc_channel",
        "section": "connect_grpc_channel",
        "text": "Create a gRPC connection to a specified port and return the Sherlock connection object.\nThe Sherlock connection object is used to invoke the APIs from their respective services.\nThis can be used to connect to the Sherlock instance that is already running with the specified\nport.\nport (int, optional) – Port number for the connection. Default is SHERLOCK_DEFAULT_PORT.\nserver_version (int, optional) – Version of Sherlock. Default is the newest version that is installed.\nThe instance of sherlock.\nSherlock\nconnect_grpc_channel\nSherlock\nSherlock\nSHERLOCK_DEFAULT_PORT"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.connect_grpc_channel",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.connect_grpc_channel.html#ansys.sherlock.core.launcher.connect_grpc_channel",
        "title": "connect_grpc_channel > connect_grpc_channel > connect_grpc_channel",
        "section": "connect_grpc_channel > connect_grpc_channel",
        "text": "ansys.sherlock.core.launcher.connect_grpc_channel(port: int = 9090, server_version: int | None = None)\n\nCreate a gRPC connection to a specified port and return the Sherlock connection object.\n\nThe Sherlock connection object is used to invoke the APIs from their respective services.\nThis can be used to connect to the Sherlock instance that is already running with the specified\nport.\n\nParameters\n\nport (int, optional) – Port number for the connection. Default is SHERLOCK_DEFAULT_PORT.\n\nserver_version (int, optional) – Version of Sherlock. Default is the newest version that is installed.\n\nReturns\n\nThe instance of sherlock.\n\nReturn type\n\nSherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CopyPottingRegionRequest.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count.html#node_count",
        "title": "node_count",
        "section": "node_count",
        "text": "int\nnode count\nnode_count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count.html#ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "title": "node_count > node_count > node_count",
        "section": "node_count > node_count",
        "text": "CircularShape.node_count: int\n\nint\n\nType\n\nnode count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file.html#update_parts_locations_by_file",
        "title": "update_parts_locations_by_file",
        "section": "update_parts_locations_by_file",
        "text": "Update one or more part locations using a CSV file.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nfile_path (str) – Full path to the file with the components and location properties.\nnumeric_format (str, optional) – Numeric format for the file, which indicates whether commas or points\nare used as decimal markers. The default is \"\", in which case\n\"English (United States)\" is the numeric format. This\nindicates that points are used as decimal markers.\nStatus code of the response. 0 for success.\nint\nupdate_parts_locations_by_file\n\"\"\n\"English (United States)\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file.html#ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "title": "update_parts_locations_by_file > update_parts_locations_by_file > update_parts_locations_by_file",
        "section": "update_parts_locations_by_file > update_parts_locations_by_file",
        "text": "Parts.update_parts_locations_by_file(project: str, cca_name: str, file_path: str, numeric_format: str = '') -> int\n\nUpdate one or more part locations using a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nfile_path (str) – Full path to the file with the components and location properties.\n\nnumeric_format (str, optional) – Numeric format for the file, which indicates whether commas or points\nare used as decimal markers. The default is \"\", in which case\n\"English (United States)\" is the numeric format. This\nindicates that points are used as decimal markers.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_locations_by_file(\n    \"Test\",\n    \"Card\",\n    \"Parts Locations.csv\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property CopyPottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props.html#update_random_vibe_props",
        "title": "update_random_vibe_props",
        "section": "update_random_vibe_props",
        "text": "Update properties for a random vibe analysis.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nrandom_vibe_damping (str, optional) – One or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\nnatural_freq_min (float, optional) – Minimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nnatural_freq_min_units (str, optional) – Minimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nnatural_freq_max (float, optional) – Maximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nnatural_freq_max_units (str, optional) – Maximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nanalysis_temp (float, optional) – Temperature. The default is None.\nanalysis_temp_units (str, optional) – Temperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\npart_validation_enabled (bool, optional) – Whether to enable part validation. The default is None.\nforce_model_rebuild (str, optional) – How to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nreuse_modal_analysis (bool, optional) – Whether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\nperform_nf_freq_range_check (bool, optional) – Whether to perform a frequency range check. The default is None.\nThis parameter is for NX Nastran analysis only.\nrequire_material_assignment_enabled (bool, optional) – Whether to require material assignment. The default is None.\nmodel_source (ModelSource, optional) – Model source. The default is None.\nThis parameter is required for strain map analysis.\nstrain_map_natural_freqs (str, optional) – Comma-separated list of natural frequencies. The default is None.\nThis parameter is required for strain map analysis.\nStatus code of the response. 0 for success.\nint\nupdate_random_vibe_props\nNone\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\nNone\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props.html#ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "title": "update_random_vibe_props > update_random_vibe_props > update_random_vibe_props",
        "section": "update_random_vibe_props > update_random_vibe_props",
        "text": "Analysis.update_random_vibe_props(project: str, cca_name: str, random_vibe_damping: str | None = None, natural_freq_min: float | None = None, natural_freq_min_units: str | None = None, natural_freq_max: float | None = None, natural_freq_max_units: str | None = None, analysis_temp: float | None = None, analysis_temp_units: str | None = None, part_validation_enabled: bool | None = None, force_model_rebuild: str | None = None, reuse_modal_analysis: bool | None = None, perform_nf_freq_range_check: bool | None = None, require_material_assignment_enabled: bool | None = None, model_source: ModelSource | None = None, strain_map_natural_freqs: str | None = None) -> int\n\nUpdate properties for a random vibe analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nrandom_vibe_damping (str, optional) – One or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\n\nnatural_freq_min (float, optional) – Minimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units (str, optional) – Minimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max (float, optional) – Maximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units (str, optional) – Maximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nanalysis_temp (float, optional) – Temperature. The default is None.\n\nanalysis_temp_units (str, optional) – Temperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\npart_validation_enabled (bool, optional) – Whether to enable part validation. The default is None.\n\nforce_model_rebuild (str, optional) – How to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nreuse_modal_analysis (bool, optional) – Whether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\n\nperform_nf_freq_range_check (bool, optional) – Whether to perform a frequency range check. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nrequire_material_assignment_enabled (bool, optional) – Whether to require material assignment. The default is None.\n\nmodel_source (ModelSource, optional) – Model source. The default is None.\nThis parameter is required for strain map analysis.\n\nstrain_map_natural_freqs (str, optional) – Comma-separated list of natural frequencies. The default is None.\nThis parameter is required for strain map analysis.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_random_vibe_props(\n    \"Test\",\n    \"Card\",\n    random_vibe_damping=\"0.01, 0.05\",\n    analysis_temp=20,\n    analysis_temp_units=\"C\",\n    model_source=ModelSource.STRAIN_MAP\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_project.html#add_project",
        "title": "add_project",
        "section": "add_project",
        "text": "Add a sherlock project to sherlock.\nAvailable Since: 2024R1\nproject_name (str) – Name of the Sherlock project.\nproject_category (str) – Category of the Sherlock project\nproject_description (str) – Description of the Sherlock project\n0 for success otherwise error\nint\nadd_project"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_project.html#ansys.sherlock.core.project.Project.add_project",
        "title": "add_project > add_project > add_project",
        "section": "add_project > add_project",
        "text": "Project.add_project(project_name: str, project_category: str, project_description: str) -> int\n\nAdd a sherlock project to sherlock.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject_name (str) – Name of the Sherlock project.\n\nproject_category (str) – Category of the Sherlock project\n\nproject_description (str) – Description of the Sherlock project\n\nReturns\n\n0 for success otherwise error\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> code = sherlock.project.add_project(\n    \"project name example\",\n    \"project category example\",\n    \"project description example\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionUpdateData.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length.html#length",
        "title": "length",
        "section": "length",
        "text": "float\nlength\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length.html#ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "title": "length > length > length",
        "section": "length > length",
        "text": "RectangularShape.length: float\n\nfloat\n\nType\n\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points.html#delete_all_test_points",
        "title": "delete_all_test_points",
        "section": "delete_all_test_points",
        "text": "Delete all test points for a CCA.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_test_points"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points.html#ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "title": "delete_all_test_points > delete_all_test_points > delete_all_test_points",
        "section": "delete_all_test_points > delete_all_test_points",
        "text": "Layer.delete_all_test_points(project: str, cca_name: str) -> int\n\nDelete all test points for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_test_points_by_file(\n    \"Test\",\n    \"Card\",\n    \"TestPointsImport.csv\",\n)\n>>> sherlock.layer.delete_all_test_points(\"Test\", \"Card\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data.html#potting_region_copy_data",
        "title": "potting_region_copy_data",
        "section": "potting_region_copy_data",
        "text": "Data identifying which potting regions to copy and what potting regions to copy from.\npotting_region_copy_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "title": "potting_region_copy_data > potting_region_copy_data > potting_region_copy_data",
        "section": "potting_region_copy_data > potting_region_copy_data",
        "text": "CopyPottingRegionRequest.potting_region_copy_data: list[PottingRegionCopyData]\n\nData identifying which potting regions to copy and what potting regions to copy from."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation.html#ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "RectangularShape.rotation: float\n\nfloat\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod SlotShape.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionDeleteData.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data.html#potting_region_delete_data",
        "title": "potting_region_delete_data",
        "section": "potting_region_delete_data",
        "text": "Data identifying which potting regions should be deleted.\npotting_region_delete_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "title": "potting_region_delete_data > potting_region_delete_data > potting_region_delete_data",
        "section": "potting_region_delete_data > potting_region_delete_data",
        "text": "DeletePottingRegionRequest.potting_region_delete_data: list[PottingRegionDeleteData]\n\nData identifying which potting regions should be deleted."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy.html#ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CircularShape.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event.html#add_random_vibe_event",
        "title": "add_random_vibe_event",
        "section": "add_random_vibe_event",
        "text": "Add a random vibe event to a life cycle phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nphase_name (str) – Name of the life cycle phase to add the random vibe event to.\nevent_name (str) – Name of the random vibe event.\nduration (float) – Event duration length.\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\nnum_of_cycles (float) – Number of cycles for the random vibe event.\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nprofile_type (str) – Random load profile type. The only option is \"Uniaxial\".\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\ndescription (str, optional) – Description of the random vibe event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_random_vibe_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY_CYCLE\"\n\"PER_YEAR\"\n\"PER_DAY\"\n\"PER_HOUR\"\n\"PER_MIN\"\n\"PER_SEC\"\n\"azimuth, elevation\"\n\"30,15\"\n\"Uniaxial\"\n\"x,y,z\"\n\"0,0,1\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "title": "add_random_vibe_event > add_random_vibe_event > add_random_vibe_event",
        "section": "add_random_vibe_event > add_random_vibe_event",
        "text": "Lifecycle.add_random_vibe_event(project: str, phase_name: str, event_name: str, duration: float, duration_units: str, num_of_cycles: float, cycle_type: str, orientation: str, profile_type: str, load_direction: str, description: str = '') -> int\n\nAdd a random vibe event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nphase_name (str) – Name of the life cycle phase to add the random vibe event to.\n\nevent_name (str) – Name of the random vibe event.\n\nduration (float) – Event duration length.\n\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\n\nnum_of_cycles (float) – Number of cycles for the random vibe event.\n\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\n\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nprofile_type (str) – Random load profile type. The only option is \"Uniaxial\".\n\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription (str, optional) – Description of the random vibe event. The default is \"\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_random_vibe_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CircularShape.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.html#ansyssherlockcoretypeslayer_typespottingregiondeletedata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "text": "Data specifying potting regions to delete.\nPottingRegionDeleteData.construct([_fields_set])\n\nPottingRegionDeleteData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionDeleteData.dict(*[, include, ...])\n\nPottingRegionDeleteData.from_orm(obj)\n\nPottingRegionDeleteData.json(*[, include, ...])\n\nPottingRegionDeleteData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionDeleteData.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPottingRegionDeleteData.model_dump(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPottingRegionDeleteData.model_dump_json(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPottingRegionDeleteData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionDeleteData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionDeleteData.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionDeleteData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionDeleteData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionDeleteData.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPottingRegionDeleteData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionDeleteData.parse_file(path, *)\n\nPottingRegionDeleteData.parse_obj(obj)\n\nPottingRegionDeleteData.parse_raw(b, *[, ...])\n\nPottingRegionDeleteData.schema([by_alias, ...])\n\nPottingRegionDeleteData.schema_json(*[, ...])\n\nPottingRegionDeleteData.str_validation(...)\nValidate string fields listed.\nPottingRegionDeleteData.update_forward_refs(...)\n\nPottingRegionDeleteData.validate(value)\n\nPottingRegionDeleteData.model_computed_fields\n\nPottingRegionDeleteData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionDeleteData.model_extra\nGet extra fields set during validation.\nPottingRegionDeleteData.model_fields\n\nPottingRegionDeleteData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionDeleteData.cca_name\nName of the CCA containing the potting region(s) to delete.\nPottingRegionDeleteData.potting_id\nId of the potting region(s) to delete.\nansys.sherlock.core.types.layer_types.PottingRegionDeleteData\nPottingRegionDeleteData.construct\nPottingRegionDeleteData.copy\nPottingRegionDeleteData.dict\nPottingRegionDeleteData.from_orm\nPottingRegionDeleteData.json\nPottingRegionDeleteData.model_construct\nPottingRegionDeleteData.model_copy\nPottingRegionDeleteData.model_dump\nPottingRegionDeleteData.model_dump_json\nPottingRegionDeleteData.model_json_schema\nPottingRegionDeleteData.model_parametrized_name\nPottingRegionDeleteData.model_post_init\nPottingRegionDeleteData.model_rebuild\nPottingRegionDeleteData.model_validate\nPottingRegionDeleteData.model_validate_json\nPottingRegionDeleteData.model_validate_strings\nPottingRegionDeleteData.parse_file\nPottingRegionDeleteData.parse_obj\nPottingRegionDeleteData.parse_raw\nPottingRegionDeleteData.schema\nPottingRegionDeleteData.schema_json\nPottingRegionDeleteData.str_validation\nPottingRegionDeleteData.update_forward_refs\nPottingRegionDeleteData.validate\nPottingRegionDeleteData.model_computed_fields\nPottingRegionDeleteData.model_config\nPottingRegionDeleteData.model_extra\nPottingRegionDeleteData.model_fields\nPottingRegionDeleteData.model_fields_set\nPottingRegionDeleteData.cca_name\nPottingRegionDeleteData.potting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > PottingRegionDeleteData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > PottingRegionDeleteData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionDeleteData(*, cca_name: str, potting_id: str)\n\nData specifying potting regions to delete.\n\nMethods\n\n\n\n\n\n\n\nPottingRegionDeleteData.construct([_fields_set])\n\n\n\nPottingRegionDeleteData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionDeleteData.dict(*[, include, ...])\n\n\n\nPottingRegionDeleteData.from_orm(obj)\n\n\n\nPottingRegionDeleteData.json(*[, include, ...])\n\n\n\nPottingRegionDeleteData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionDeleteData.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPottingRegionDeleteData.model_dump(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPottingRegionDeleteData.model_dump_json(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPottingRegionDeleteData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionDeleteData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionDeleteData.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionDeleteData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionDeleteData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionDeleteData.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPottingRegionDeleteData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionDeleteData.parse_file(path, *)\n\n\n\nPottingRegionDeleteData.parse_obj(obj)\n\n\n\nPottingRegionDeleteData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionDeleteData.schema([by_alias, ...])\n\n\n\nPottingRegionDeleteData.schema_json(*[, ...])\n\n\n\nPottingRegionDeleteData.str_validation(...)\n\nValidate string fields listed.\n\nPottingRegionDeleteData.update_forward_refs(...)\n\n\n\nPottingRegionDeleteData.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionDeleteData.model_computed_fields\n\n\n\nPottingRegionDeleteData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionDeleteData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionDeleteData.model_fields\n\n\n\nPottingRegionDeleteData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionDeleteData.cca_name\n\nName of the CCA containing the potting region(s) to delete.\n\nPottingRegionDeleteData.potting_id\n\nId of the potting region(s) to delete.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra.html#ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property CircularShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width.html#width",
        "title": "width",
        "section": "width",
        "text": "width of the legend\nfloat\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width.html#ansys.sherlock.core.types.project_types.LegendBounds.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "LegendBounds.width\n\nwidth of the legend\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate.html#ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod RectangularShape.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials.html#list_solder_materials",
        "title": "list_solder_materials",
        "section": "list_solder_materials",
        "text": "List valid solders.\nAvailable Since: 2024R1\nValid solder names.\nlist[str]\nlist_solder_materials"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials.html#ansys.sherlock.core.common.Common.list_solder_materials",
        "title": "list_solder_materials > list_solder_materials > list_solder_materials",
        "section": "list_solder_materials > list_solder_materials",
        "text": "Common.list_solder_materials() -> list[str]\n\nList valid solders.\n\nAvailable Since: 2024R1\n\nReturns\n\nValid solder names.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.common.list_solder_materials()"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures.html#delete_all_ict_fixtures",
        "title": "delete_all_ict_fixtures",
        "section": "delete_all_ict_fixtures",
        "text": "Delete all ICT fixtures for a CCA.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_ict_fixtures"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures.html#ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "title": "delete_all_ict_fixtures > delete_all_ict_fixtures > delete_all_ict_fixtures",
        "section": "delete_all_ict_fixtures > delete_all_ict_fixtures",
        "text": "Layer.delete_all_ict_fixtures(project: str, cca_name: str) -> int\n\nDelete all ICT fixtures for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_ict_fixtures_by_file(\n    \"Test\",\n    \"Card\",\n    \"ICTFixturesImport.csv\",\n)\n>>> sherlock.layer.delete_all_ict_fixtures(\"Test\", \"Card\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures.html#export_all_test_fixtures",
        "title": "export_all_test_fixtures",
        "section": "export_all_test_fixtures",
        "text": "Export the test fixture properties for a CCA.\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nexport_file (str) – Full path for the CSV file to export the text fixtures list to.\nunits (str, optional) – Units to use when exporting the test fixtures.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_test_fixtures\nDEFAULT"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures.html#ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "title": "export_all_test_fixtures > export_all_test_fixtures > export_all_test_fixtures",
        "section": "export_all_test_fixtures > export_all_test_fixtures",
        "text": "Layer.export_all_test_fixtures(project: str, cca_name: str, export_file: str, units: str = 'DEFAULT') -> int\n\nExport the test fixture properties for a CCA.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nexport_file (str) – Full path for the CSV file to export the text fixtures list to.\n\nunits (str, optional) – Units to use when exporting the test fixtures.\nThe default is DEFAULT.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Tutorial Project\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.export_all_test_fixtures(\n    \"Tutorial Project\",\n    \"Card\",\n    \"TestFixturesExport.csv\",\n    \"DEFAULT\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width.html#width",
        "title": "width",
        "section": "width",
        "text": "float\nwidth\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width.html#ansys.sherlock.core.types.layer_types.SlotShape.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "SlotShape.width: float\n\nfloat\n\nType\n\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionUpdateData.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "DeletePottingRegionRequest.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate.html#ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegion.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CopyPottingRegionRequest.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list.html#export_net_list",
        "title": "export_net_list",
        "section": "export_net_list",
        "text": "Export a net list to a delimited output file.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\noutput_file (str) – Full path for the output file where the net list will be written.\ncol_delimiter (TableDelimiter, optional) – The delimiter character to be used. Defaults to TableDelimiter.COMMA.\noverwrite_existing (bool, optional) – Flag to determine if existing .CSV files should be overwritten\nif they match the output_file. Defaults to False.\nutf8_enabled (bool, optional) – Flag that specifies if UTF-8 will be used for .CSV files. Defaults to False.\nStatus code of the response. 0 for success.\nint\nexport_net_list"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list.html#ansys.sherlock.core.parts.Parts.export_net_list",
        "title": "export_net_list > export_net_list > export_net_list",
        "section": "export_net_list > export_net_list",
        "text": "Parts.export_net_list(project: str, cca_name: str, output_file: str, col_delimiter: str = SherlockCommonService_pb2.TableDelimiter.COMMA, overwrite_existing: bool = False, utf8_enabled: bool = False) -> int\n\nExport a net list to a delimited output file.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\noutput_file (str) – Full path for the output file where the net list will be written.\n\ncol_delimiter (TableDelimiter, optional) – The delimiter character to be used. Defaults to TableDelimiter.COMMA.\n\noverwrite_existing (bool, optional) – Flag to determine if existing .CSV files should be overwritten\nif they match the output_file. Defaults to False.\n\nutf8_enabled (bool, optional) – Flag that specifies if UTF-8 will be used for .CSV files. Defaults to False.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.export_net_list(\n    \"Test\",\n    \"Card\",\n    \"Net List.csv\",\n    col_delimiter=TableDelimiter.TAB,\n    overwrite_existing=True,\n    utf8_enabled=True\n)"
    },
    {
        "objectID": "api/layer",
        "href": "api/layer.html#layer",
        "title": "Layer",
        "section": "Layer",
        "text": "Module containing all layer management capabilities.\nLayer(channel, server_version)\nModule containing all the layer management capabilities.\nLayer\nLayer"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CopyPottingRegionRequest.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionCopyData.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CircularShape.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive.html#import_project_zip_archive",
        "title": "import_project_zip_archive",
        "section": "import_project_zip_archive",
        "text": "Import a zipped project archive – multiple project mode.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project.\ncategory (str) – Sherlock project category.\narchive_file (str) – Full path to the .zip archive file containing the project data.\nStatus code of the response. 0 for success.\nint\nimport_project_zip_archive"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive.html#ansys.sherlock.core.project.Project.import_project_zip_archive",
        "title": "import_project_zip_archive > import_project_zip_archive > import_project_zip_archive",
        "section": "import_project_zip_archive > import_project_zip_archive",
        "text": "Project.import_project_zip_archive(project: str, category: str, archive_file: str) -> int\n\nImport a zipped project archive – multiple project mode.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncategory (str) – Sherlock project category.\n\narchive_file (str) – Full path to the .zip archive file containing the project data.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\"Tutorial Project\", \"Demos\",\n\"Tutorial Project.zip\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod DeletePottingRegionRequest.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CircularShape.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region.html#add_modeling_region",
        "title": "add_modeling_region",
        "section": "add_modeling_region",
        "text": "Add one or more modeling regions to a specific project.\nproject (str) – Name of the Sherlock project.\nmodeling_regions (list[dict[str, bool | float | str | dict[str, bool | float | str]                | dict[str, float | str]]]) – Modeling regions to add. Each dictionary should contain:cca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type\n\nstr\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size\n\nfloat, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\nModeling regions to add. Each dictionary should contain:\nName of the CCA.\nUnique region ID of the modeling region.\nUnits of the modeling region.\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\nThe shape of the modeling region.\nPCB model parameters consisting of these properties:\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum size of the mesh to be used in the region.\nUnits for the maximum mesh size.\nWhether to generate quad-shaped elements when creating the mesh if true.\nTrace model parameters consisting of these properties:\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\nUnits for the maximum mesh size when trace modeling is enabled.\nStatus code of the response. 0 for success.\nint\nadd_modeling_region\nEnabled\nDisabled\nExcluded\nDefault\nSherlock\nSweep\nNone\nFirst_Order\nSecond_Order\nSolid_Shell\nDefault\nEnabled\nDisabled\nFirst_Order\nSecond_Order\nSolid_Shell"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region.html#ansys.sherlock.core.layer.Layer.add_modeling_region",
        "title": "add_modeling_region > add_modeling_region > add_modeling_region",
        "section": "add_modeling_region > add_modeling_region",
        "text": "Layer.add_modeling_region(project: str, modeling_regions: list[dict[str, bool | float | str | dict[str, bool | float | str] | dict[str, float | str]]]) -> int\n\nAdd one or more modeling regions to a specific project.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nmodeling_regions (list[dict[str, bool | float | str | dict[str, bool | float | str]                | dict[str, float | str]]]) – Modeling regions to add. Each dictionary should contain:cca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type\n\nstr\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size\n\nfloat, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Tutorial Project\",\n    cca_name=\"Card\",\n)\n>>> modeling_regions = [\n    {\n        \"cca_name\": \"Card\",\n        \"region_id\": \"Region001\",\n        \"region_units\": \"mm\",\n        \"model_mode\": \"Enabled\",\n        \"shape\": PolygonalShape(points=[\n            (0, 0),\n            (0, 6.35),\n            (9.77, 0)\n        ], rotation=87.8),\n        \"pcb_model_props\": {\n            \"export_model_type\": \"Sherlock\",\n            \"elem_order\": \"First_Order\",\n            \"max_mesh_size\": 0.5,\n            \"max_mesh_size_units\": \"mm\",\n            \"quads_preferred\": True\n        },\n        \"trace_model_props\": {\n            \"trace_model_type\": \"Enabled\",\n            \"elem_order\": \"Second_Order\",\n            \"trace_mesh_size\": 0.3,\n            \"trace_mesh_size_units\": \"mm\"\n        }\n    }\n]\n>>> result = sherlock.layer.add_modeling_region(\"Tutorial Project\", modeling_regions)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionCopyData.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CircularShape.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionCopyData.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/project",
        "href": "api/project.html#project",
        "title": "Project",
        "section": "Project",
        "text": "Module containing all project management capabilities.\nProject(channel, server_version)\nContains all project management capabilities.\nProject\nProject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PCBShape.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#getting-started",
        "title": "Getting started",
        "section": "Getting started",
        "text": "PySherlock provides a Pythonic interface to Sherlock functionalities.\nTo use PySherlock, you must have a licensed copy of Sherlock 2022 R2 or later installed.\nFor more information on Sherlock, see the\nAnsys Sherlock\npage on the Ansys website.\nGetting started"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields.html#get_harmonic_vibe_input_fields",
        "title": "get_harmonic_vibe_input_fields",
        "section": "get_harmonic_vibe_input_fields",
        "text": "Get harmonic vibe property fields based on the user configuration.\nAvailable Since: 2024R1\nmodel_source (ModelSource, optional) – Model source to get the harmonic vibe property fields from.\nThe default is None.\nHarmonic vibe property fields based on the user configuration.\nlist[str]\nget_harmonic_vibe_input_fields\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "title": "get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields",
        "section": "get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields",
        "text": "Analysis.get_harmonic_vibe_input_fields(model_source: ModelSource | None = None) -> list[str]\n\nGet harmonic vibe property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nParameters\n\nmodel_source (ModelSource, optional) – Model source to get the harmonic vibe property fields from.\nThe default is None.\n\nReturns\n\nHarmonic vibe property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_harmonic_vibe_input_fields(ModelSource.GENERATED)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region.html#delete_potting_region",
        "title": "delete_potting_region",
        "section": "delete_potting_region",
        "text": "Delete on or more potting regions in a specific project.\nAvailable Since: 2025R1\nrequest (DeletePottingRegionRequest) – Contains all the information needed to delete one or more potting regions per project.\nReturn codes for each request.\nlist[SherlockCommonService_pb2.ReturnCode]\ndelete_potting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region.html#ansys.sherlock.core.layer.Layer.delete_potting_region",
        "title": "delete_potting_region > delete_potting_region > delete_potting_region",
        "section": "delete_potting_region > delete_potting_region",
        "text": "Layer.delete_potting_region(request: DeletePottingRegionRequest) -> list[SherlockCommonService_pb2.ReturnCode]\n\nDelete on or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest (DeletePottingRegionRequest) – Contains all the information needed to delete one or more potting regions per project.\n\nReturns\n\nReturn codes for each request.\n\nReturn type\n\nlist[SherlockCommonService_pb2.ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import DeletePottingRegionRequest\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionDeleteData\n>>> sherlock = launch_sherlock()\n>>>\n>>> delete_request_example = DeletePottingRegionRequest(\n    project=project,\n    potting_region_delete_data=[\n        PottingRegionDeleteData(\n            cca_name=cca_name,\n            potting_id=potting_id\n        )\n    ]\n)\n>>> responses_example = sherlock.layer.delete_potting_region(delete_request_example)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer.html#update_conductor_layer",
        "title": "update_conductor_layer",
        "section": "update_conductor_layer",
        "text": "Update a conductor layer with given properties.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nlayer (str) – Layer ID associated with the conductor layer.\nlayer_type (str, optional) – Layer type. The default is \"\". For example,\n\"SIGNAL\", \"POWER\", or \"SUBSTRATE\".\nmaterial (str, optional) – Conductor material. The default is \"\".\nthickness (float, optional) – Conductor layer thickness. The default is 0.\nthickness_unit (str, optional) – Units for the conductor layer thickness. The\ndefault is \"\".\nconductor_percent (str, optional) – Conductor percentage. The default is \"\".\nresin_material (str, optional) – Resin material. The default is \"\".\nUsing the default value for a property causes no changes for that property.\nStatus code of the response. 0 for success.\nint\nupdate_conductor_layer\n\"\"\n\"SIGNAL\"\n\"POWER\"\n\"SUBSTRATE\"\n\"\"\n0\n\"\"\n\"\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer.html#ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "title": "update_conductor_layer > update_conductor_layer > update_conductor_layer",
        "section": "update_conductor_layer > update_conductor_layer",
        "text": "Stackup.update_conductor_layer(project: str, cca_name: str, layer: str, layer_type: str = '', material: str = '', thickness: float = 0, thickness_unit: str = '', conductor_percent: str = '', resin_material: str = '') -> int\n\nUpdate a conductor layer with given properties.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nlayer (str) – Layer ID associated with the conductor layer.\n\nlayer_type (str, optional) – Layer type. The default is \"\". For example,\n\"SIGNAL\", \"POWER\", or \"SUBSTRATE\".\n\nmaterial (str, optional) – Conductor material. The default is \"\".\n\nthickness (float, optional) – Conductor layer thickness. The default is 0.\n\nthickness_unit (str, optional) – Units for the conductor layer thickness. The\ndefault is \"\".\n\nconductor_percent (str, optional) – Conductor percentage. The default is \"\".\n\nresin_material (str, optional) – Resin material. The default is \"\".\n\nUsing the default value for a property causes no changes for that property.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.update_conductor_layer(\n    \"Test\",\n    \"Card\",\n    \"3\",\n    \"POWER\",\n    \"COPPER\",\n    1.0,\n    \"oz\",\n    \"94.2\",\n    \"Generic FR-4 Generic FR-4\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json.html#ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod SlotShape.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.html#ansyssherlockcoretypeslayer_typespcbshape",
        "title": "ansys.sherlock.core.types.layer_types.PCBShape",
        "section": "ansys.sherlock.core.types.layer_types.PCBShape",
        "text": "Contains the properties for a PCB shape.\nPCBShape.construct([_fields_set])\n\nPCBShape.copy(*[, include, exclude, update, ...])\nReturns a copy of the model.\nPCBShape.dict(*[, include, exclude, ...])\n\nPCBShape.from_orm(obj)\n\nPCBShape.json(*[, include, exclude, ...])\n\nPCBShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPCBShape.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPCBShape.model_dump(*[, mode, include, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPCBShape.model_dump_json(*[, indent, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPCBShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPCBShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPCBShape.model_post_init(_BaseModel__context)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPCBShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPCBShape.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nPCBShape.model_validate_json(json_data, *[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPCBShape.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nPCBShape.parse_file(path, *[, content_type, ...])\n\nPCBShape.parse_obj(obj)\n\nPCBShape.parse_raw(b, *[, content_type, ...])\n\nPCBShape.schema([by_alias, ref_template])\n\nPCBShape.schema_json(*[, by_alias, ref_template])\n\nPCBShape.update_forward_refs(**localns)\n\nPCBShape.validate(value)\n\nPCBShape.model_computed_fields\n\nPCBShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPCBShape.model_extra\nGet extra fields set during validation.\nPCBShape.model_fields\n\nPCBShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nansys.sherlock.core.types.layer_types.PCBShape\nPCBShape.construct\nPCBShape.copy\nPCBShape.dict\nPCBShape.from_orm\nPCBShape.json\nPCBShape.model_construct\nPCBShape.model_copy\nPCBShape.model_dump\nPCBShape.model_dump_json\nPCBShape.model_json_schema\nPCBShape.model_parametrized_name\nPCBShape.model_post_init\nPCBShape.model_rebuild\nPCBShape.model_validate\nPCBShape.model_validate_json\nPCBShape.model_validate_strings\nPCBShape.parse_file\nPCBShape.parse_obj\nPCBShape.parse_raw\nPCBShape.schema\nPCBShape.schema_json\nPCBShape.update_forward_refs\nPCBShape.validate\nPCBShape.model_computed_fields\nPCBShape.model_config\nPCBShape.model_extra\nPCBShape.model_fields\nPCBShape.model_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.html#ansys.sherlock.core.types.layer_types.PCBShape",
        "title": "ansys.sherlock.core.types.layer_types.PCBShape > ansys.sherlock.core.types.layer_types.PCBShape > PCBShape",
        "section": "ansys.sherlock.core.types.layer_types.PCBShape > PCBShape",
        "text": "class ansys.sherlock.core.types.layer_types.PCBShape\n\nContains the properties for a PCB shape.\n\nMethods\n\n\n\n\n\n\n\nPCBShape.construct([_fields_set])\n\n\n\nPCBShape.copy(*[, include, exclude, update, ...])\n\nReturns a copy of the model.\n\nPCBShape.dict(*[, include, exclude, ...])\n\n\n\nPCBShape.from_orm(obj)\n\n\n\nPCBShape.json(*[, include, exclude, ...])\n\n\n\nPCBShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPCBShape.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPCBShape.model_dump(*[, mode, include, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPCBShape.model_dump_json(*[, indent, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPCBShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPCBShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPCBShape.model_post_init(_BaseModel__context)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPCBShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPCBShape.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nPCBShape.model_validate_json(json_data, *[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPCBShape.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nPCBShape.parse_file(path, *[, content_type, ...])\n\n\n\nPCBShape.parse_obj(obj)\n\n\n\nPCBShape.parse_raw(b, *[, content_type, ...])\n\n\n\nPCBShape.schema([by_alias, ref_template])\n\n\n\nPCBShape.schema_json(*[, by_alias, ref_template])\n\n\n\nPCBShape.update_forward_refs(**localns)\n\n\n\nPCBShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPCBShape.model_computed_fields\n\n\n\nPCBShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPCBShape.model_extra\n\nGet extra fields set during validation.\n\nPCBShape.model_fields\n\n\n\nPCBShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.html#ansyssherlockcoretypeslayer_typesrectangularshape",
        "title": "ansys.sherlock.core.types.layer_types.RectangularShape",
        "section": "ansys.sherlock.core.types.layer_types.RectangularShape",
        "text": "Contains the properties for a rectangular shape.\nRectangularShape.construct([_fields_set])\n\nRectangularShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nRectangularShape.dict(*[, include, exclude, ...])\n\nRectangularShape.from_orm(obj)\n\nRectangularShape.json(*[, include, exclude, ...])\n\nRectangularShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nRectangularShape.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nRectangularShape.model_dump(*[, mode, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nRectangularShape.model_dump_json(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nRectangularShape.model_json_schema([...])\nGenerates a JSON schema for a model class.\nRectangularShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nRectangularShape.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nRectangularShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nRectangularShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nRectangularShape.model_validate_json(...[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nRectangularShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nRectangularShape.parse_file(path, *[, ...])\n\nRectangularShape.parse_obj(obj)\n\nRectangularShape.parse_raw(b, *[, ...])\n\nRectangularShape.schema([by_alias, ref_template])\n\nRectangularShape.schema_json(*[, by_alias, ...])\n\nRectangularShape.update_forward_refs(**localns)\n\nRectangularShape.validate(value)\n\nRectangularShape.model_computed_fields\n\nRectangularShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nRectangularShape.model_extra\nGet extra fields set during validation.\nRectangularShape.model_fields\n\nRectangularShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nRectangularShape.length\nfloat\nRectangularShape.width\nfloat\nRectangularShape.center_x\nfloat\nRectangularShape.center_y\nfloat\nRectangularShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.RectangularShape\nRectangularShape.construct\nRectangularShape.copy\nRectangularShape.dict\nRectangularShape.from_orm\nRectangularShape.json\nRectangularShape.model_construct\nRectangularShape.model_copy\nRectangularShape.model_dump\nRectangularShape.model_dump_json\nRectangularShape.model_json_schema\nRectangularShape.model_parametrized_name\nRectangularShape.model_post_init\nRectangularShape.model_rebuild\nRectangularShape.model_validate\nRectangularShape.model_validate_json\nRectangularShape.model_validate_strings\nRectangularShape.parse_file\nRectangularShape.parse_obj\nRectangularShape.parse_raw\nRectangularShape.schema\nRectangularShape.schema_json\nRectangularShape.update_forward_refs\nRectangularShape.validate\nRectangularShape.model_computed_fields\nRectangularShape.model_config\nRectangularShape.model_extra\nRectangularShape.model_fields\nRectangularShape.model_fields_set\nRectangularShape.length\nRectangularShape.width\nRectangularShape.center_x\nRectangularShape.center_y\nRectangularShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.html#ansys.sherlock.core.types.layer_types.RectangularShape",
        "title": "ansys.sherlock.core.types.layer_types.RectangularShape > ansys.sherlock.core.types.layer_types.RectangularShape > RectangularShape",
        "section": "ansys.sherlock.core.types.layer_types.RectangularShape > RectangularShape",
        "text": "class ansys.sherlock.core.types.layer_types.RectangularShape(*, length: float, width: float, center_x: float, center_y: float, rotation: float)\n\nContains the properties for a rectangular shape.\n\nMethods\n\n\n\n\n\n\n\nRectangularShape.construct([_fields_set])\n\n\n\nRectangularShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nRectangularShape.dict(*[, include, exclude, ...])\n\n\n\nRectangularShape.from_orm(obj)\n\n\n\nRectangularShape.json(*[, include, exclude, ...])\n\n\n\nRectangularShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nRectangularShape.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nRectangularShape.model_dump(*[, mode, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nRectangularShape.model_dump_json(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nRectangularShape.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nRectangularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nRectangularShape.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nRectangularShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nRectangularShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nRectangularShape.model_validate_json(...[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nRectangularShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nRectangularShape.parse_file(path, *[, ...])\n\n\n\nRectangularShape.parse_obj(obj)\n\n\n\nRectangularShape.parse_raw(b, *[, ...])\n\n\n\nRectangularShape.schema([by_alias, ref_template])\n\n\n\nRectangularShape.schema_json(*[, by_alias, ...])\n\n\n\nRectangularShape.update_forward_refs(**localns)\n\n\n\nRectangularShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nRectangularShape.model_computed_fields\n\n\n\nRectangularShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nRectangularShape.model_extra\n\nGet extra fields set during validation.\n\nRectangularShape.model_fields\n\n\n\nRectangularShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nRectangularShape.length\n\nfloat\n\nRectangularShape.width\n\nfloat\n\nRectangularShape.center_x\n\nfloat\n\nRectangularShape.center_y\n\nfloat\n\nRectangularShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod SlotShape.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y.html#legend_y",
        "title": "legend_y",
        "section": "legend_y",
        "text": "y coordinate of the upper left corner\nfloat\nlegend_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y.html#ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "title": "legend_y > legend_y > legend_y",
        "section": "legend_y > legend_y",
        "text": "LegendBounds.legend_y\n\ny coordinate of the upper left corner\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict.html#ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegion.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionUpdateData.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation.html#ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "SlotShape.rotation: float\n\nfloat\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod SlotShape.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegion.model_fields: ClassVar[dict[str, FieldInfo]] = {'cca_name': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True), 'potting_material': FieldInfo(annotation=str, required=True), 'potting_side': FieldInfo(annotation=str, required=True), 'potting_standoff': FieldInfo(annotation=float, required=True), 'potting_thickness': FieldInfo(annotation=float, required=True), 'potting_units': FieldInfo(annotation=str, required=True), 'shape': FieldInfo(annotation=Union[CircularShape, PCBShape, PolygonalShape, RectangularShape, SlotShape], required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property CircularShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegion.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps.html#list_thermal_maps",
        "title": "list_thermal_maps",
        "section": "list_thermal_maps",
        "text": "List the thermal map files and their type assigned to each CCA of given CCAs.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project.\ncca_names (List of str, optional) – List of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nAll thermal map files or thermal map files and their type for the specified CCAs.\nlist\nlist_thermal_maps\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps.html#ansys.sherlock.core.project.Project.list_thermal_maps",
        "title": "list_thermal_maps > list_thermal_maps > list_thermal_maps",
        "section": "list_thermal_maps > list_thermal_maps",
        "text": "Project.list_thermal_maps(project: str, cca_names: list[str] | None = None) -> list\n\nList the thermal map files and their type assigned to each CCA of given CCAs.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_names (List of str, optional) – List of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\nAll thermal map files or thermal map files and their type for the specified CCAs.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> thermal_maps = sherlock.project.list_thermal_maps(\n    \"AssemblyTutorial\",\n    [\"Main Board\",\"Power Module\"]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionCopyData.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionDeleteData.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields.html#get_ict_analysis_input_fields",
        "title": "get_ict_analysis_input_fields",
        "section": "get_ict_analysis_input_fields",
        "text": "Get ICT analysis property fields based on the user configuration.\nAvailable Since: 2024R1\nICT analysis property fields based on the user configuration.\nNone if not connected to Sherlock.\nlist[str]\nget_ict_analysis_input_fields\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "title": "get_ict_analysis_input_fields > get_ict_analysis_input_fields > get_ict_analysis_input_fields",
        "section": "get_ict_analysis_input_fields > get_ict_analysis_input_fields",
        "text": "Analysis.get_ict_analysis_input_fields() -> list[str]\n\nGet ICT analysis property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nReturns\n\nICT analysis property fields based on the user configuration.\nNone if not connected to Sherlock.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.analysis.get_ict_analysis_input_fields()"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature.html#max_temperature",
        "title": "max_temperature",
        "section": "max_temperature",
        "text": "max_temperature\nfloat\nmax_temperature"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature.html#ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "title": "max_temperature > max_temperature > max_temperature",
        "section": "max_temperature > max_temperature",
        "text": "ImageFile.max_temperature\n\nmax_temperature\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionUpdateData.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property DeletePottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy.html#ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PCBShape.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod RectangularShape.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegion.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json.html#ansys.sherlock.core.types.layer_types.SlotShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "SlotShape.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod DeletePottingRegionRequest.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis.html#run_analysis",
        "title": "run_analysis",
        "section": "run_analysis",
        "text": "Run one or more Sherlock analyses.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nanalyses (list of elements) – elements: list[tuple[RunAnalysisRequestAnalysisType, tuple[str, str]]]\n\nTuples (type, event)\n\nanalysis_type: RunAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent: list[tuple[str, str]]\n\nTuples (phase_name, event_name)\n\nphase_name: str\n\nName of the life cycle phase.\n\nevent_name: str\n\nName of the life cycle event.\nTuples (type, event)\nType of analysis to run.\nTuples (phase_name, event_name)\nName of the life cycle phase.\nName of the life cycle event.\nStatus code of the response. 0 for success.\nint\nrun_analysis\nelements\ntype\nevent\nphase_name\nevent_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis.html#ansys.sherlock.core.analysis.Analysis.run_analysis",
        "title": "run_analysis > run_analysis > run_analysis",
        "section": "run_analysis > run_analysis",
        "text": "Analysis.run_analysis(project: str, cca_name: str, analyses: list[tuple[RunAnalysisRequestAnalysisType, tuple[str, str]]]) -> int\n\nRun one or more Sherlock analyses.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nanalyses (list of elements) – elements: list[tuple[RunAnalysisRequestAnalysisType, tuple[str, str]]]\n\nTuples (type, event)\n\nanalysis_type: RunAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent: list[tuple[str, str]]\n\nTuples (phase_name, event_name)\n\nphase_name: str\n\nName of the life cycle phase.\n\nevent_name: str\n\nName of the life cycle event.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.run_analysis(\n    \"Test\",\n    \"Card\",\n    [\n        (RunAnalysisRequestAnalysisType.NATURAL_FREQ,\n        [\n            (\"Phase 1\", [\"Harmonic Event\"])\n        ]\n        )\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter.html#diameter",
        "title": "diameter",
        "section": "diameter",
        "text": "float\ndiameter\ndiameter"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter.html#ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "title": "diameter > diameter > diameter",
        "section": "diameter > diameter",
        "text": "CircularShape.diameter: float\n\nfloat\n\nType\n\ndiameter"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict.html#ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "RectangularShape.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionCopyData.model_fields: ClassVar[dict[str, FieldInfo]] = {'cca_name': FieldInfo(annotation=str, required=True), 'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'copy_potting_id': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property RectangularShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CopyPottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the project containing the potting regions to delete.\nproject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "DeletePottingRegionRequest.project: str\n\nName of the project containing the potting regions to delete."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count.html#node_count",
        "title": "node_count",
        "section": "node_count",
        "text": "int\nnode count\nnode_count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count.html#ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "title": "node_count > node_count > node_count",
        "section": "node_count > node_count",
        "text": "SlotShape.node_count: int\n\nint\n\nType\n\nnode count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PolygonalShape.model_fields: ClassVar[dict[str, FieldInfo]] = {'points': FieldInfo(annotation=list[tuple[float, float]], required=True), 'rotation': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CopyPottingRegionRequest.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points.html#export_all_mount_points",
        "title": "export_all_mount_points",
        "section": "export_all_mount_points",
        "text": "Export the mount point properties for a CCA.\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nexport_file (str) – Full path for the CSV file to export the mount points list to.\nunits (str, optional) – Units to use when exporting the mount points.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_mount_points\nDEFAULT"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points.html#ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "title": "export_all_mount_points > export_all_mount_points > export_all_mount_points",
        "section": "export_all_mount_points > export_all_mount_points",
        "text": "Layer.export_all_mount_points(project: str, cca_name: str, export_file: str, units: str = 'DEFAULT') -> int\n\nExport the mount point properties for a CCA.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nexport_file (str) – Full path for the CSV file to export the mount points list to.\n\nunits (str, optional) – Units to use when exporting the mount points.\nThe default is DEFAULT.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Tutorial Project\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.export_all_mount_points(\n    \"Tutorial Project\",\n    \"Card\",\n    \"MountPointsExport.csv\",\n    \"DEFAULT\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CopyPottingRegionRequest.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids.html#validate_ids",
        "title": "validate_ids",
        "section": "validate_ids",
        "text": "Validate that the potting IDs are not the same between the original and copy.\nvalidate_ids"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "title": "validate_ids > validate_ids > validate_ids",
        "section": "validate_ids > validate_ids",
        "text": "PottingRegionCopyData.validate_ids() -> Self\n\nValidate that the potting IDs are not the same between the original and copy."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "UpdatePottingRegionRequest.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionUpdateData.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod UpdatePottingRegionRequest.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.export_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.export_project.html#export_project",
        "title": "export_project",
        "section": "export_project",
        "text": "Export a sherlock project.\nAvailable Since: 2025R1\nproject_name (str) – Name of the project being exported.\nexport_design_files (bool) – Determines if design files should be exported.\nexport_result_files (bool) – Determines if all analysis module result files should be exported.\nexport_archive_results (bool) – Determines if all archive result files should be exported.\nexport_user_files (bool) – Determines if user properties and custom data files should be exported.\nexport_log_files (bool) – Determines if Sherlock console and application log files should be exported.\nexport_system_data (bool) – Determines if system technical data should be exported.\nexport_file_dir (str) – Destination of export file.\nexport_file_name (str) – Name to be given to the exported file.\noverwrite_existing_file (bool) – Determines if exported file will overwrite a previously existing file.\nStatus code of the response. 0 for success.\nint\nexport_project"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.export_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.export_project.html#ansys.sherlock.core.project.Project.export_project",
        "title": "export_project > export_project > export_project",
        "section": "export_project > export_project",
        "text": "Project.export_project(project_name: str, export_design_files: bool, export_result_files: bool, export_archive_results: bool, export_user_files: bool, export_log_files: bool, export_system_data: bool, export_file_dir: str, export_file_name: str, overwrite_existing_file: bool) -> int\n\nExport a sherlock project.\n\nAvailable Since: 2025R1\n\nParameters\n\nproject_name (str) – Name of the project being exported.\n\nexport_design_files (bool) – Determines if design files should be exported.\n\nexport_result_files (bool) – Determines if all analysis module result files should be exported.\n\nexport_archive_results (bool) – Determines if all archive result files should be exported.\n\nexport_user_files (bool) – Determines if user properties and custom data files should be exported.\n\nexport_log_files (bool) – Determines if Sherlock console and application log files should be exported.\n\nexport_system_data (bool) – Determines if system technical data should be exported.\n\nexport_file_dir (str) – Destination of export file.\n\nexport_file_name (str) – Name to be given to the exported file.\n\noverwrite_existing_file (bool) – Determines if exported file will overwrite a previously existing file.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.export_project(\"Tutorial Project\",\nTrue,\nTrue,\nTrue,\nTrue,\nTrue,\nTrue,\n\"C:/Path/To/Exported/Project\",\n\"Exported_Project\",\nTrue)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property SlotShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm.html#ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PCBShape.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points.html#points",
        "title": "points",
        "section": "points",
        "text": "list[tuple[float, float]]\npoints (length two tuples of the form (x, y))\npoints"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points.html#ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "PolygonalShape.points: list[tuple[float, float]]\n\nlist[tuple[float, float]]\n\nType\n\npoints (length two tuples of the form (x, y))"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points.html#delete_all_mount_points",
        "title": "delete_all_mount_points",
        "section": "delete_all_mount_points",
        "text": "Delete all mount points for a CCA.\nAvailable Since: 2022R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_mount_points"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points.html#ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "title": "delete_all_mount_points > delete_all_mount_points > delete_all_mount_points",
        "section": "delete_all_mount_points > delete_all_mount_points",
        "text": "Layer.delete_all_mount_points(project: str, cca_name: str) -> int\n\nDelete all mount points for a CCA.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_mount_points_by_file(\n    \"Test\",\n    \"Card\",\n    \"MountPointImport.csv\",\n)\n>>> sherlock.layer.delete_all_mount_points(\"Test\", \"Card\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds.html#image_bounds",
        "title": "image_bounds",
        "section": "image_bounds",
        "text": "image_bounds\nImageBounds\nimage_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "title": "image_bounds > image_bounds > image_bounds",
        "section": "image_bounds > image_bounds",
        "text": "ImageFile.image_bounds\n\nimage_bounds\n\nType\n\nImageBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "UpdatePottingRegionRequest.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PCBShape.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "DeletePottingRegionRequest.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.html#ansyssherlockcoretypesproject_typesimagebounds",
        "title": "ansys.sherlock.core.types.project_types.ImageBounds",
        "section": "ansys.sherlock.core.types.project_types.ImageBounds",
        "text": "Contains the properties of the image bounds.\nImageBounds.image_x\nx coordinate of the upper left corner\nImageBounds.image_y\ny coordinate of the upper left corner\nImageBounds.height\nheight of the image\nImageBounds.width\nwidth of the image\nansys.sherlock.core.types.project_types.ImageBounds\nImageBounds.image_x\nImageBounds.image_y\nImageBounds.height\nImageBounds.width"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.html#ansys.sherlock.core.types.project_types.ImageBounds",
        "title": "ansys.sherlock.core.types.project_types.ImageBounds > ansys.sherlock.core.types.project_types.ImageBounds > ImageBounds",
        "section": "ansys.sherlock.core.types.project_types.ImageBounds > ImageBounds",
        "text": "class ansys.sherlock.core.types.project_types.ImageBounds(image_x: float, image_y: float, height: float, width: float)\n\nContains the properties of the image bounds.\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nImageBounds.image_x\n\nx coordinate of the upper left corner\n\nImageBounds.image_y\n\ny coordinate of the upper left corner\n\nImageBounds.height\n\nheight of the image\n\nImageBounds.width\n\nwidth of the image\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionDeleteData.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset.html#load_shock_profile_dataset",
        "title": "load_shock_profile_dataset",
        "section": "load_shock_profile_dataset",
        "text": "Load shock profile dataset from a .csv or .dat file.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project\nphase_name (str) – Name of the lifecycle phase to add this event to.\nevent_name (str) – Name of the random vibe event.\nfile_path (str) – File path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_shock_profile_dataset"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset.html#ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "title": "load_shock_profile_dataset > load_shock_profile_dataset > load_shock_profile_dataset",
        "section": "load_shock_profile_dataset > load_shock_profile_dataset",
        "text": "Lifecycle.load_shock_profile_dataset(project: str, phase_name: str, event_name: str, file_path: str) -> int\n\nLoad shock profile dataset from a .csv or .dat file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nphase_name (str) – Name of the lifecycle phase to add this event to.\n\nevent_name (str) – Name of the random vibe event.\n\nfile_path (str) – File path for thermal profile .dat or .csv file\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "DeletePottingRegionRequest.model_fields: ClassVar[dict[str, FieldInfo]] = {'potting_region_delete_data': FieldInfo(annotation=list[PottingRegionDeleteData], required=True), 'project': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses.html#load_shock_profile_pulses",
        "title": "load_shock_profile_pulses",
        "section": "load_shock_profile_pulses",
        "text": "Load shock profile pulses from a .csv .dat file.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project\nphase_name (str) – Name of the lifecycle phase to add this event to.\nevent_name (str) – Name of the random vibe event.\nfile_path (str) – Path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_shock_profile_pulses"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses.html#ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "title": "load_shock_profile_pulses > load_shock_profile_pulses > load_shock_profile_pulses",
        "section": "load_shock_profile_pulses > load_shock_profile_pulses",
        "text": "Lifecycle.load_shock_profile_pulses(project: str, phase_name: str, event_name: str, file_path: str) -> int\n\nLoad shock profile pulses from a .csv .dat file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nphase_name (str) – Name of the lifecycle phase to add this event to.\n\nevent_name (str) – Name of the random vibe event.\n\nfile_path (str) – Path for thermal profile .dat or .csv file\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.lifecycle.load_shock_profile_pulses(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Shock Event\",\n        file_path=\"Test_Profile.dat\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields.html#get_random_vibe_input_fields",
        "title": "get_random_vibe_input_fields",
        "section": "get_random_vibe_input_fields",
        "text": "Get random vibe property fields based on the user configuration.\nAvailable Since: 2023R2\nmodel_source (ModelSource, optional) – Model source to get the random vibe property fields from.\nThe default is None.\nRandom vibe input field property names based on the user configuration.\nlist[str]\nget_random_vibe_input_fields\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "title": "get_random_vibe_input_fields > get_random_vibe_input_fields > get_random_vibe_input_fields",
        "section": "get_random_vibe_input_fields > get_random_vibe_input_fields",
        "text": "Analysis.get_random_vibe_input_fields(model_source: ModelSource | None = None) -> list[str]\n\nGet random vibe property fields based on the user configuration.\n\nAvailable Since: 2023R2\n\nParameters\n\nmodel_source (ModelSource, optional) – Model source to get the random vibe property fields from.\nThe default is None.\n\nReturns\n\nRandom vibe input field property names based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_random_vibe_input_fields(ModelSource.STRAIN_MAP)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation.html#ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "PolygonalShape.rotation: float\n\nfloat\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json.html#ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CircularShape.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod DeletePottingRegionRequest.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PCBShape.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CircularShape.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod DeletePottingRegionRequest.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams.html#createexporttracecopperlayerparams",
        "title": "createExportTraceCopperLayerParams",
        "section": "createExportTraceCopperLayerParams",
        "text": "Create a set of parameters to be used to export a single copper layer.\nCreates TraceModelExportParams object that can be added to an export trace model request.\nShould be used in conjunction with exportTraceModel method to export multiple trace layers\nall at once. See example below.\nproject_name (str) – Name of the Sherlock project containing trace layer to export.\ncca_name (str) – Name of the CCA containing the trace layer to export.\noutput_file_path (str) – File path including the file name and extension where the trace layer will be exported.\nValid file extensions: .py, .bdf, .apdl, .cdb, .wbjn, .stp, .step, .tcl, .stl\nNote: relative paths will be relative to sherlock install directory,\nnot the python script.\ncopper_layer (str) – Name of the copper layer in the given CCA to export.\noverwrite (bool = False) – Determines if sherlock should overwrite the output file if it exists.\ndisplay_after (bool = False) – Determines if the output file should automatically display after export.\nclear_FEA_database (bool = False) – Determines if sherlock should clear the database after export.\nApplicable file extensions: .apdl, and .cdb.\nuse_FEA_model_ID (bool = False) – Determines if the FEA model id is used or not.\ncoord_units (str = \"mm\") – Units of the coordinate system. Applicable to .py .wbjn, .stp, .step.\nmesh_type (MeshType = MeshType.NONE) – Options of difference trace meshing strategies\nis_modeling_region_enabled (bool = False) – Determines if pre-defined modeling regions will be applied to the exported trace model.\ntrace_output_type (TraceOutputType = TraceOutputType.ALL_REGIONS) – Options to select which trace regions to include in the 3D model.\nelement_order (ElementOrder = ElementOrder.LINEAR) – Type of FEA element to be used when modeling each component.\nmax_mesh_size (float = 1.0) – Indicates the desired element sizes.\nmax_mesh_size_units (str = \"mm\") – Indicates the units to be used with max_mesh_size.\nmax_holes_per_trace (int = 2) – Maximum number of holes allowed in a trace before partitioning it into multiple traces.\nis_drill_hole_modeling_enabled (bool = False) – Determines if drill holes will be modeled or not.\ndrill_hole_min_diameter (float = 1.0) – All drill holes with a diameter < this value will not be modeled.\ndrill_hole_min_diameter_units (str = \"mm\") – Units associated with drill_hole_min_diameter.\ndrill_hole_max_edge_length (float = 1.0) – Specifies the length of the line segments used to represent round drill holes.\ndrill_hole_max_edge_length_units (str = \"mm\") – Units associated with drill_hole_max_edge_length.\nObject that holds the data for a single export trace request.\nTraceModelExportParams\ncreateExportTraceCopperLayerParams"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams.html#ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "title": "createExportTraceCopperLayerParams > createExportTraceCopperLayerParams > createExportTraceCopperLayerParams",
        "section": "createExportTraceCopperLayerParams > createExportTraceCopperLayerParams",
        "text": "Model.createExportTraceCopperLayerParams(project_name, cca_name, output_file_path, copper_layer, overwrite: bool = False, display_after: bool = False, clear_FEA_database: bool = False, use_FEA_model_ID: bool = False, coord_units: str = 'mm', mesh_type: int = SherlockModelService_pb2.MeshType.NONE, is_modeling_region_enabled: bool = False, trace_output_type: int = SherlockModelService_pb2.TraceOutputType.ALL_REGIONS, element_order: ElementOrder = SherlockAnalysisService_pb2.ElementOrder.Linear, max_mesh_size: float = 1.0, max_mesh_size_units: str = 'mm', max_holes_per_trace: int = 2, is_drill_hole_modeling_enabled: bool = False, drill_hole_min_diameter: float = 1.0, drill_hole_min_diameter_units: str = 'mm', drill_hole_max_edge_length: float = 1.0, drill_hole_max_edge_length_units: str = 'mm') -> SherlockModelService_pb2.TraceModelExportParams\n\nCreate a set of parameters to be used to export a single copper layer.\n\nCreates TraceModelExportParams object that can be added to an export trace model request.\nShould be used in conjunction with exportTraceModel method to export multiple trace layers\nall at once. See example below.\n\nParameters\n\nproject_name (str) – Name of the Sherlock project containing trace layer to export.\n\ncca_name (str) – Name of the CCA containing the trace layer to export.\n\noutput_file_path (str) – File path including the file name and extension where the trace layer will be exported.\nValid file extensions: .py, .bdf, .apdl, .cdb, .wbjn, .stp, .step, .tcl, .stl\nNote: relative paths will be relative to sherlock install directory,\nnot the python script.\n\ncopper_layer (str) – Name of the copper layer in the given CCA to export.\n\noverwrite (bool = False) – Determines if sherlock should overwrite the output file if it exists.\n\ndisplay_after (bool = False) – Determines if the output file should automatically display after export.\n\nclear_FEA_database (bool = False) – Determines if sherlock should clear the database after export.\nApplicable file extensions: .apdl, and .cdb.\n\nuse_FEA_model_ID (bool = False) – Determines if the FEA model id is used or not.\n\ncoord_units (str = \"mm\") – Units of the coordinate system. Applicable to .py .wbjn, .stp, .step.\n\nmesh_type (MeshType = MeshType.NONE) – Options of difference trace meshing strategies\n\nis_modeling_region_enabled (bool = False) – Determines if pre-defined modeling regions will be applied to the exported trace model.\n\ntrace_output_type (TraceOutputType = TraceOutputType.ALL_REGIONS) – Options to select which trace regions to include in the 3D model.\n\nelement_order (ElementOrder = ElementOrder.LINEAR) – Type of FEA element to be used when modeling each component.\n\nmax_mesh_size (float = 1.0) – Indicates the desired element sizes.\n\nmax_mesh_size_units (str = \"mm\") – Indicates the units to be used with max_mesh_size.\n\nmax_holes_per_trace (int = 2) – Maximum number of holes allowed in a trace before partitioning it into multiple traces.\n\nis_drill_hole_modeling_enabled (bool = False) – Determines if drill holes will be modeled or not.\n\ndrill_hole_min_diameter (float = 1.0) – All drill holes with a diameter < this value will not be modeled.\n\ndrill_hole_min_diameter_units (str = \"mm\") – Units associated with drill_hole_min_diameter.\n\ndrill_hole_max_edge_length (float = 1.0) – Specifies the length of the line segments used to represent round drill holes.\n\ndrill_hole_max_edge_length_units (str = \"mm\") – Units associated with drill_hole_max_edge_length.\n\nReturns\n\nObject that holds the data for a single export trace request.\n\nReturn type\n\nTraceModelExportParams\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core.types.analysis_types import ElementOrder\n>>> from ansys.api.sherlock.v0 import SherlockModelService_pb2\n>>> sherlock = launcher.launch_sherlock()\n>>> copper_1_layer = sherlock.model.createExportTraceCopperLayerParams(\n        \"Tutorial Project\",\n        \"Main Board\",\n        \".\\\\outputfile_path.stp\",\n        \"copper-01.odb\",\n        False,\n        False,\n        False,\n        False,\n        \"mm\",\n        SherlockModelService_pb2.MeshType.NONE,\n        False,\n        SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n        ElementOrder.LINEAR,\n        1.0,\n        \"mm\",\n        2,\n        False,\n        1.0,\n        \"mm\",\n        1.0\n    )\n>>> copper_2_layer = sherlock.model.createExportTraceCopperLayerParams(\n        \"Tutorial Project\",\n        \"Main Board\",\n        \".\\\\outputfile_path2.stp\",\n        \"copper-02.odb\",\n        False,\n        False,\n        False,\n        False,\n        \"mm\",\n        SherlockModelService_pb2.MeshType.NONE,\n        False,\n        SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n        ElementOrder.LINEAR,\n        1.0,\n        \"mm\",\n        2,\n        False,\n        1.0,\n        \"mm\",\n        1.0\n    )\n>>> sherlock.model.exportTraceModel([copper_1_layer, copper_2_layer])"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event.html#add_thermal_event",
        "title": "add_thermal_event",
        "section": "add_thermal_event",
        "text": "Add a thermal event to a life cycle phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nphase_name (str) – Name of the life cycle phase to add the thermal event to.\nevent_name (str) – Name of the thermal event.\nnum_of_cycles (float) – Number of cycles for the thermal event.\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\ncycle_state (str) – Life cycle state. Options are \"OPERATING\" and \"STORAGE\".\ndescription (str, optional) – Description of the thermal event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_thermal_event\n\"COUNT\"\n\"DUTY_CYCLE\"\n\"PER_YEAR\"\n\"PER_DAY\"\n\"PER_HOUR\"\n\"PER_MIN\"\n\"PER_SEC\"\n\"OPERATING\"\n\"STORAGE\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "title": "add_thermal_event > add_thermal_event > add_thermal_event",
        "section": "add_thermal_event > add_thermal_event",
        "text": "Lifecycle.add_thermal_event(project: str, phase_name: str, event_name: str, num_of_cycles: float, cycle_type: str, cycle_state: str, description: str = '') -> int\n\nAdd a thermal event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nphase_name (str) – Name of the life cycle phase to add the thermal event to.\n\nevent_name (str) – Name of the thermal event.\n\nnum_of_cycles (float) – Number of cycles for the thermal event.\n\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\n\ncycle_state (str) – Life cycle state. Options are \"OPERATING\" and \"STORAGE\".\n\ndescription (str, optional) – Description of the thermal event. The default is \"\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_thermal_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    4.0,\n    \"PER YEAR\",\n    \"STORAGE\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionUpdateData.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionCopyData.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump.html#ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PCBShape.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionCopyData.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CopyPottingRegionRequest.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionUpdateData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegion.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "DeletePottingRegionRequest.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "DeletePottingRegionRequest.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "Id of the potting region(s) to delete.\npotting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegionDeleteData.potting_id: str\n\nId of the potting region(s) to delete."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionDeleteData.model_fields: ClassVar[dict[str, FieldInfo]] = {'cca_name': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature.html#min_temperature",
        "title": "min_temperature",
        "section": "min_temperature",
        "text": "min_temperature\nfloat\nmin_temperature"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature.html#ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "title": "min_temperature > min_temperature > min_temperature",
        "section": "min_temperature > min_temperature",
        "text": "ImageFile.min_temperature\n\nmin_temperature\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile.html#load_harmonic_profile",
        "title": "load_harmonic_profile",
        "section": "load_harmonic_profile",
        "text": "Load a harmonic profile from a DAT or CSV file to a life cycle phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project\nphase_name (str) – Name of the life cycle phase to add the harmonic profile to.\nevent_name (str) – Name of the harmonic event.\nfile_path (str) – Path for DAT or CSV file with the harmonic profile.\nStatus code of the response. 0 for success.\nint\nload_harmonic_profile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "title": "load_harmonic_profile > load_harmonic_profile > load_harmonic_profile",
        "section": "load_harmonic_profile > load_harmonic_profile",
        "text": "Lifecycle.load_harmonic_profile(project: str, phase_name: str, event_name: str, file_path: str) -> int\n\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nphase_name (str) – Name of the life cycle phase to add the harmonic profile to.\n\nevent_name (str) – Name of the harmonic event.\n\nfile_path (str) – Path for DAT or CSV file with the harmonic profile.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n\n>>> loaded = sherlock.lifecycle.load_harmonic_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Harmonic Event\",\n        file_path=\"Test_Profile.dat\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props.html#get_parts_list_validation_analysis_props",
        "title": "get_parts_list_validation_analysis_props",
        "section": "get_parts_list_validation_analysis_props",
        "text": "Get properties for a Part List Validation analysis.\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nindicates general errors that occurred while attempting to update parts\n\npartLibrary: str\n\nPart library name\n\nprocessUseAVL: bool\n\nProcess option to use AVL\n\nprocessUseWizard: bool\n\nProcess option to use wizard\n\nprocessCheckConfirmedProperties: bool\n\nProcess option to check confirmed properties\n\nprocessCheckPartNumbers: bool\n\nProcess option to check part numbers\n\nmatching: MatchingMode\n\nMatching type\n\navlRequireInternalPartNumber: bool\n\nAVL option to require internal part number\n\navlRequireApprovedDescription: bool\n\nAVL option to require approved description\n\navlRequireApprovedManufacturer: bool\n\nAVL option to require approved manufacturer\nStatus code of the response. 0 for success.\nindicates general errors that occurred while attempting to update parts\nPart library name\nProcess option to use AVL\nProcess option to use wizard\nProcess option to check confirmed properties\nProcess option to check part numbers\nMatching type\nAVL option to require internal part number\nAVL option to require approved description\nAVL option to require approved manufacturer\nPartsListValidationPropsResponse\nget_parts_list_validation_analysis_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props.html#ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "title": "get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props",
        "section": "get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props",
        "text": "Analysis.get_parts_list_validation_analysis_props(project: str, cca_name: str) -> SherlockAnalysisService_pb2.PartsListValidationPropsResponse\n\nGet properties for a Part List Validation analysis.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nReturns\n\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nindicates general errors that occurred while attempting to update parts\n\npartLibrary: str\n\nPart library name\n\nprocessUseAVL: bool\n\nProcess option to use AVL\n\nprocessUseWizard: bool\n\nProcess option to use wizard\n\nprocessCheckConfirmedProperties: bool\n\nProcess option to check confirmed properties\n\nprocessCheckPartNumbers: bool\n\nProcess option to check part numbers\n\nmatching: MatchingMode\n\nMatching type\n\navlRequireInternalPartNumber: bool\n\nAVL option to require internal part number\n\navlRequireApprovedDescription: bool\n\nAVL option to require approved description\n\navlRequireApprovedManufacturer: bool\n\nAVL option to require approved manufacturer\n\nReturn type\n\nPartsListValidationPropsResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> analysis_props = sherlock.analysis.get_parts_list_validation_analysis_props(\n    \"Test\", \"Card\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod UpdatePottingRegionRequest.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property RectangularShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis.html#run_strain_map_analysis",
        "title": "run_strain_map_analysis",
        "section": "run_strain_map_analysis",
        "text": "Run one or more strain map analyses.\nAvailable Since: 2023R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the main CCA for the analysis.\nstrain_map_analyses (list[list[RunStrainMapAnalysisRequestAnalysisType | list[list[str]]]]) – Analyses consisting of these properties:analysis_type: RunStrainMapAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent_strain_maps: list\n\nStrain maps assigned to the desired life cycle events for\na given PCB side. The list consists of these properties:\n\nphase_name: str\n\nLife cycle phase name for the strain map assignment.\n\nevent_name: str\n\nLife cycle event name for the strain map assignment.\n\npcb_side: str\n\nPCB side for the strain map. Options are \"TOP\" and \"BOTTOM\".\n\nstrain_map: str\n\nName of the strain map assigned to the life cycle event.\n\nsub_assembly_name: str, optional\n\nName of the subassembly CCA to assign the strain map to.\nAnalyses consisting of these properties:\nType of analysis to run.\nStrain maps assigned to the desired life cycle events for\na given PCB side. The list consists of these properties:\nLife cycle phase name for the strain map assignment.\nLife cycle event name for the strain map assignment.\nPCB side for the strain map. Options are \"TOP\" and \"BOTTOM\".\nName of the strain map assigned to the life cycle event.\nName of the subassembly CCA to assign the strain map to.\nStatus code of the response. 0 for success.\nint\nrun_strain_map_analysis\n\"TOP\"\n\"BOTTOM\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis.html#ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "title": "run_strain_map_analysis > run_strain_map_analysis > run_strain_map_analysis",
        "section": "run_strain_map_analysis > run_strain_map_analysis",
        "text": "Analysis.run_strain_map_analysis(project: str, cca_name: str, strain_map_analyses: list[list[RunStrainMapAnalysisRequestAnalysisType | list[list[str]]]]) -> int\n\nRun one or more strain map analyses.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the main CCA for the analysis.\n\nstrain_map_analyses (list[list[RunStrainMapAnalysisRequestAnalysisType | list[list[str]]]]) – Analyses consisting of these properties:analysis_type: RunStrainMapAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent_strain_maps: list\n\nStrain maps assigned to the desired life cycle events for\na given PCB side. The list consists of these properties:\n\nphase_name: str\n\nLife cycle phase name for the strain map assignment.\n\nevent_name: str\n\nLife cycle event name for the strain map assignment.\n\npcb_side: str\n\nPCB side for the strain map. Options are \"TOP\" and \"BOTTOM\".\n\nstrain_map: str\n\nName of the strain map assigned to the life cycle event.\n\nsub_assembly_name: str, optional\n\nName of the subassembly CCA to assign the strain map to.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.analysis_types import (\n>>>     RunStrainMapAnalysisRequestAnalysisType\n>>> )\n>>> sherlock = launch_sherlock()\n>>> analysis_request = SherlockAnalysisService_pb2.RunStrainMapAnalysisRequest\n>>> sherlock.analysis.run_strain_map_analysis(\n        \"AssemblyTutorial\",\n        \"Main Board\",\n        [[\n            RunStrainMapAnalysisRequestAnalysisType.RANDOM_VIBE,\n            [[\"Phase 1\", \"Random Vibe\", \"TOP\", \"MainBoardStrain - Top\"],\n             [\"Phase 1\", \"Random Vibe\", \"BOTTOM\", \"MainBoardStrain - Bottom\"],\n             [\"Phase 1\", \"Random Vibe\", \"TOP\", \"MemoryCard1Strain\", \"Memory Card 1\"]],\n        ]]\n    )"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionUpdateData.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionUpdateData.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod UpdatePottingRegionRequest.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CopyPottingRegionRequest.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod RectangularShape.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "Name of the CCA containing the potting region(s) to delete.\ncca_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegionDeleteData.cca_name: str\n\nName of the CCA containing the potting region(s) to delete."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionUpdateData.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the project containing the potting region(s) to be copied.\nproject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "CopyPottingRegionRequest.project: str\n\nName of the project containing the potting region(s) to be copied."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump.html#ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CircularShape.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds.html#bounds",
        "title": "bounds",
        "section": "bounds",
        "text": "bounds (two tuples of the form (x, y)\nlist[tuple[float, float]]\nbounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds.html#ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "title": "bounds > bounds > bounds",
        "section": "bounds > bounds",
        "text": "BoardBounds.bounds\n\nbounds (two tuples of the form (x, y)\n\nType\n\nlist[tuple[float, float]]"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionDeleteData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nValidate the given JSON data against the Pydantic model.\njson_data – The JSON data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CircularShape.model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data – The JSON data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property UpdatePottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.html#ansyssherlockcoretypesproject_typesicepakfile",
        "title": "ansys.sherlock.core.types.project_types.IcepakFile",
        "section": "ansys.sherlock.core.types.project_types.IcepakFile",
        "text": "Contains the properties for a thermal map Icepak file.\nansys.sherlock.core.types.project_types.IcepakFile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.html#ansys.sherlock.core.types.project_types.IcepakFile",
        "title": "ansys.sherlock.core.types.project_types.IcepakFile > ansys.sherlock.core.types.project_types.IcepakFile > IcepakFile",
        "section": "ansys.sherlock.core.types.project_types.IcepakFile > IcepakFile",
        "text": "class ansys.sherlock.core.types.project_types.IcepakFile\n\nContains the properties for a thermal map Icepak file.\n\nMethods\n\n\n\n\n\n\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "RectangularShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema.html#ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegion.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "UpdatePottingRegionRequest.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update.html#potting_region_id_to_update",
        "title": "potting_region_id_to_update",
        "section": "potting_region_id_to_update",
        "text": "Id of the potting region to update.\npotting_region_id_to_update"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "title": "potting_region_id_to_update > potting_region_id_to_update > potting_region_id_to_update",
        "section": "potting_region_id_to_update > potting_region_id_to_update",
        "text": "PottingRegionUpdateData.potting_region_id_to_update: str\n\nId of the potting region to update."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionCopyData.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionCopyData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "DeletePottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/common",
        "href": "api/common.html#common",
        "title": "Common",
        "section": "Common",
        "text": "Module for running the gRPC APIs in the Sherlock Common service.\nCommon(channel, server_version)\nContains methods from the Sherlock Common service.\nCommon\nCommon"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.html#ansyssherlockcoreprojectproject",
        "title": "ansys.sherlock.core.project.Project",
        "section": "ansys.sherlock.core.project.Project",
        "text": "Contains all project management capabilities.\nProject.add_cca(project, cca_properties)\nAdd one or more CCAs to a project.\nProject.add_project(project_name, ...)\nAdd a sherlock project to sherlock.\nProject.add_strain_maps(project, strain_maps)\nAdd strain map files to CCAs in a Sherlock project.\nProject.add_thermal_maps(project, ...)\nAdd thermal map files to a Sherlock project.\nProject.create_cca_from_modeling_region(...)\nCreate one or more CCAs from modeling regions in a given project.\nProject.delete_project(project)\nDelete a Sherlock project.\nProject.export_project(project_name, ...)\nExport a sherlock project.\nProject.generate_project_report(project, ...)\nGenerate a project report.\nProject.import_ipc2581_archive(archive_file, ...)\nImport an IPC-2581 archive file.\nProject.import_odb_archive(archive_file, ...)\nImport an ODB++ archive file.\nProject.import_project_zip_archive(project, ...)\nImport a zipped project archive -- multiple project mode.\nProject.import_project_zip_archive_single_mode(...)\nImport a zipped project archive -- single project mode.\nProject.list_ccas(project[, cca_names])\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\nProject.list_strain_maps(project[, cca_names])\nList the strain maps assigned to each CCA or given CCAs.\nProject.list_thermal_maps(project[, cca_names])\nList the thermal map files and their type assigned to each CCA of given CCAs.\nProject.update_thermal_maps(project, ...)\nUpdate thermal map files to a Sherlock project.\nansys.sherlock.core.project.Project\nProject.add_cca\nProject.add_project\nProject.add_strain_maps\nProject.add_thermal_maps\nProject.create_cca_from_modeling_region\nProject.delete_project\nProject.export_project\nProject.generate_project_report\nProject.import_ipc2581_archive\nProject.import_odb_archive\nProject.import_project_zip_archive\nProject.import_project_zip_archive_single_mode\nProject.list_ccas\nProject.list_strain_maps\nProject.list_thermal_maps\nProject.update_thermal_maps"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.html#ansys.sherlock.core.project.Project",
        "title": "ansys.sherlock.core.project.Project > ansys.sherlock.core.project.Project > Project",
        "section": "ansys.sherlock.core.project.Project > Project",
        "text": "class ansys.sherlock.core.project.Project(channel: grpc.Channel, server_version: int)\n\nContains all project management capabilities.\n\nMethods\n\n\n\n\n\n\n\nProject.add_cca(project, cca_properties)\n\nAdd one or more CCAs to a project.\n\nProject.add_project(project_name, ...)\n\nAdd a sherlock project to sherlock.\n\nProject.add_strain_maps(project, strain_maps)\n\nAdd strain map files to CCAs in a Sherlock project.\n\nProject.add_thermal_maps(project, ...)\n\nAdd thermal map files to a Sherlock project.\n\nProject.create_cca_from_modeling_region(...)\n\nCreate one or more CCAs from modeling regions in a given project.\n\nProject.delete_project(project)\n\nDelete a Sherlock project.\n\nProject.export_project(project_name, ...)\n\nExport a sherlock project.\n\nProject.generate_project_report(project, ...)\n\nGenerate a project report.\n\nProject.import_ipc2581_archive(archive_file, ...)\n\nImport an IPC-2581 archive file.\n\nProject.import_odb_archive(archive_file, ...)\n\nImport an ODB++ archive file.\n\nProject.import_project_zip_archive(project, ...)\n\nImport a zipped project archive -- multiple project mode.\n\nProject.import_project_zip_archive_single_mode(...)\n\nImport a zipped project archive -- single project mode.\n\nProject.list_ccas(project[, cca_names])\n\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\n\nProject.list_strain_maps(project[, cca_names])\n\nList the strain maps assigned to each CCA or given CCAs.\n\nProject.list_thermal_maps(project[, cca_names])\n\nList the thermal map files and their type assigned to each CCA of given CCAs.\n\nProject.update_thermal_maps(project, ...)\n\nUpdate thermal map files to a Sherlock project.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape.html#shape",
        "title": "shape",
        "section": "shape",
        "text": "The shape of the potting region.\nshape"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape.html#ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "title": "shape > shape > shape",
        "section": "shape > shape",
        "text": "PottingRegion.shape: CircularShape | PCBShape | PolygonalShape | RectangularShape | SlotShape\n\nThe shape of the potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionCopyData.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra.html#ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property SlotShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config.html#ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CircularShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegion.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionUpdateData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list.html#update_parts_list",
        "title": "update_parts_list",
        "section": "update_parts_list",
        "text": "Update a parts list based on matching and duplication preferences.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\npart_library (str) – Name of the parts library.\nmatching_mode (str) – Matching mode for updates.\nduplication_mode (PartsListSearchDuplicationMode) – How to handle duplication during the update.\nStatus code of the response. 0 for success.\nint\nupdate_parts_list"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list.html#ansys.sherlock.core.parts.Parts.update_parts_list",
        "title": "update_parts_list > update_parts_list > update_parts_list",
        "section": "update_parts_list > update_parts_list",
        "text": "Parts.update_parts_list(project: str, cca_name: str, part_library: str, matching_mode: str, duplication_mode: PartsListSearchDuplicationMode) -> int\n\nUpdate a parts list based on matching and duplication preferences.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\npart_library (str) – Name of the parts library.\n\nmatching_mode (str) – Matching mode for updates.\n\nduplication_mode (PartsListSearchDuplicationMode) – How to handle duplication during the update.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_list(\n    \"Test\",\n    \"Card\",\n    \"Sherlock Part Library\",\n    \"Both\",\n    PartsListSearchDuplicationMode.ERROR\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json.html#ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "RectangularShape.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema.html#ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod RectangularShape.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias – Whether to use attribute aliases or not.\nref_template – The reference template.\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode – The mode in which to generate the schema.\nThe JSON schema for the given model class.\nmodel_json_schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod RectangularShape.model_json_schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}', schema_generator: type[~pydantic.json_schema.GenerateJsonSchema] = <class 'pydantic.json_schema.GenerateJsonSchema'>, mode: ~typing.Literal['validation', 'serialization'] = 'validation') -> dict[str, Any]\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias – Whether to use attribute aliases or not.\n\nref_template – The reference template.\n\nschema_generator – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode – The mode in which to generate the schema.\n\nReturns\n\nThe JSON schema for the given model class."
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#project-types",
        "title": "Project Types",
        "section": "Project Types",
        "text": "Classes used for the Project API.\nBoardBounds(bounds)\nContains the properties of the board bounds.\nCsvExcelFile(header_row_count, ...)\nContains the properties for a thermal map, CSV, or Excel file.\nIcepakFile()\nContains the properties for a thermal map Icepak file.\nImageBounds(image_x, image_y, height, width)\nContains the properties of the image bounds.\nImageFile(board_bounds, coordinate_units, ...)\nContains the properties for a thermal map image file.\nLegendBounds(legend_x, legend_y, height, width)\nContains the properties of the legend bounds.\nProject Types\nBoardBounds\nCsvExcelFile\nIcepakFile\nImageBounds\nImageFile\nLegendBounds"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#constants",
        "title": "Project Types > Constants",
        "section": "Constants",
        "text": "Constants for legend orientation in the update thermal maps request.\nHorizontal\nVertical\nConstants for File Type in the Add Strain Maps request.\nCSV\nExcel\nImage\nConstants for legend orientation in the add strain maps request.\nHorizontal\nVertical\nConstants for thermal board side in the update thermal maps request.\nBoth\nBottom\nTop\nConstants for File Type in the Update Thermal Maps request.\nCSV\nExcel\nImage\nIcepak Thermal Map (.TMAP)\nConstants"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation",
        "title": "Project Types > Constants > LegendOrientation",
        "section": "Constants > LegendOrientation",
        "text": "class ansys.sherlock.core.types.project_types.LegendOrientation\n\nConstants for legend orientation in the update thermal maps request.\n\n\n\nHORIZONTAL\n\nHorizontal\n\n\n\nVERTICAL\n\nVertical"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation.HORIZONTAL",
        "title": "Project Types > Constants > HORIZONTAL",
        "section": "Constants > HORIZONTAL",
        "text": "HORIZONTAL\n\nHorizontal"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation.VERTICAL",
        "title": "Project Types > Constants > VERTICAL",
        "section": "Constants > VERTICAL",
        "text": "VERTICAL\n\nVertical"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType",
        "title": "Project Types > Constants > StrainMapsFileType",
        "section": "Constants > StrainMapsFileType",
        "text": "class ansys.sherlock.core.types.project_types.StrainMapsFileType\n\nConstants for File Type in the Add Strain Maps request.\n\n\n\nCSV\n\nCSV\n\n\n\nEXCEL\n\nExcel\n\n\n\nIMAGE\n\nImage"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.CSV",
        "title": "Project Types > Constants > CSV",
        "section": "Constants > CSV",
        "text": "CSV\n\nCSV"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.EXCEL",
        "title": "Project Types > Constants > EXCEL",
        "section": "Constants > EXCEL",
        "text": "EXCEL\n\nExcel"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.IMAGE",
        "title": "Project Types > Constants > IMAGE",
        "section": "Constants > IMAGE",
        "text": "IMAGE\n\nImage"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation",
        "title": "Project Types > Constants > StrainMapLegendOrientation",
        "section": "Constants > StrainMapLegendOrientation",
        "text": "class ansys.sherlock.core.types.project_types.StrainMapLegendOrientation\n\nConstants for legend orientation in the add strain maps request.\n\n\n\nHORIZONTAL\n\nHorizontal\n\n\n\nVERTICAL\n\nVertical"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation.HORIZONTAL",
        "title": "Project Types > Constants > HORIZONTAL",
        "section": "Constants > HORIZONTAL",
        "text": "HORIZONTAL\n\nHorizontal"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation.VERTICAL",
        "title": "Project Types > Constants > VERTICAL",
        "section": "Constants > VERTICAL",
        "text": "VERTICAL\n\nVertical"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide",
        "title": "Project Types > Constants > ThermalBoardSide",
        "section": "Constants > ThermalBoardSide",
        "text": "class ansys.sherlock.core.types.project_types.ThermalBoardSide\n\nConstants for thermal board side in the update thermal maps request.\n\n\n\nBOTH\n\nBoth\n\n\n\nBOTTOM\n\nBottom\n\n\n\nTOP\n\nTop"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.BOTH",
        "title": "Project Types > Constants > BOTH",
        "section": "Constants > BOTH",
        "text": "BOTH\n\nBoth"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.BOTTOM",
        "title": "Project Types > Constants > BOTTOM",
        "section": "Constants > BOTTOM",
        "text": "BOTTOM\n\nBottom"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.TOP",
        "title": "Project Types > Constants > TOP",
        "section": "Constants > TOP",
        "text": "TOP\n\nTop"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType",
        "title": "Project Types > Constants > ThermalMapsFileType",
        "section": "Constants > ThermalMapsFileType",
        "text": "class ansys.sherlock.core.types.project_types.ThermalMapsFileType\n\nConstants for File Type in the Update Thermal Maps request.\n\n\n\nCSV\n\nCSV\n\n\n\nEXCEL\n\nExcel\n\n\n\nIMAGE\n\nImage\n\n\n\nTMAP\n\nIcepak Thermal Map (.TMAP)"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.CSV",
        "title": "Project Types > Constants > CSV",
        "section": "Constants > CSV",
        "text": "CSV\n\nCSV"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.EXCEL",
        "title": "Project Types > Constants > EXCEL",
        "section": "Constants > EXCEL",
        "text": "EXCEL\n\nExcel"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.IMAGE",
        "title": "Project Types > Constants > IMAGE",
        "section": "Constants > IMAGE",
        "text": "IMAGE\n\nImage"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.TMAP",
        "title": "Project Types > Constants > TMAP",
        "section": "Constants > TMAP",
        "text": "TMAP\n\nIcepak Thermal Map (.TMAP)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CopyPottingRegionRequest.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds.html#legend_bounds",
        "title": "legend_bounds",
        "section": "legend_bounds",
        "text": "legend_bounds\nLegendBounds\nlegend_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "title": "legend_bounds > legend_bounds > legend_bounds",
        "section": "legend_bounds > legend_bounds",
        "text": "ImageFile.legend_bounds\n\nlegend_bounds\n\nType\n\nLegendBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors – Whether to raise errors, defaults to True.\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n_types_namespace – The types namespace, defaults to None.\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod RectangularShape.model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -> bool | None\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace – The types namespace, defaults to None.\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False."
    },
    {
        "objectID": "api/layer_types",
        "href": "api/layer_types.html#layer-types",
        "title": "Layer Types",
        "section": "Layer Types",
        "text": "Classes used for the Layer API.\nModule containing types for the Layer Service.\nCopyPottingRegionRequest(*, project, ...)\nRequest to delete 1 or more potting regions.\nDeletePottingRegionRequest(*, project, ...)\nRequest to delete 1 or more potting regions.\nPolygonalShape(*, points, rotation)\nContains the properties for a polygonal shape.\nRectangularShape(*, length, width, center_x, ...)\nContains the properties for a rectangular shape.\nSlotShape(*, length, width, node_count, ...)\nContains the properties for a slot shape.\nCircularShape(*, diameter, node_count, ...)\nContains the properties for a circular shape.\nPCBShape()\nContains the properties for a PCB shape.\nPottingRegion(*, cca_name, potting_id, ...)\nContains the properties of a Potting Region add or update request.\nPottingRegionCopyData(*, cca_name, ...)\nData identifying which potting regions to copy.\nPottingRegionDeleteData(*, cca_name, potting_id)\nData specifying potting regions to delete.\nPottingRegionUpdateData(*, ...)\nContains the properties of a potting region update request.\nUpdatePottingRegionRequest(*, project, ...)\nContains the properties of a potting region update per project.\nLayer Types\nCopyPottingRegionRequest\nDeletePottingRegionRequest\nPolygonalShape\nRectangularShape\nSlotShape\nCircularShape\nPCBShape\nPottingRegion\nPottingRegionCopyData\nPottingRegionDeleteData\nPottingRegionUpdateData\nUpdatePottingRegionRequest"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod UpdatePottingRegionRequest.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property CopyPottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "getting_started/launch_sherlock",
        "href": "getting_started/launch_sherlock.html#launch-sherlock",
        "title": "Launch Sherlock",
        "section": "Launch Sherlock",
        "text": "To launch Sherlock, use the launch_sherlock()\nmethod. This method takes an optional port parameter and automatically searches for the\nlatest version of Sherlock installed locally. It then launches the Sherlock gRPC server on\nthe port specified. If a port is not specified, port 9090 is used.\nThis method also launches a Sherlock client connected to the same port and\nreturns a sherlock gRPC connection object that can be used to invoke the APIs from their\nrespective services.\nThis code starts the Sherlock gRPC server on the default port:\nThis code uses the optional port parameter to start the Sherlock gRPC server on port\n11000:\nYou can use the Common.check()\nmethod to perform a health check on the sherlock gRPC connection object:\nLaunch Sherlock\nlaunch_sherlock()\nport\n9090\nsherlock\nport\n11000\nCommon.check()\nsherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields.html#get_solder_fatigue_input_fields",
        "title": "get_solder_fatigue_input_fields",
        "section": "get_solder_fatigue_input_fields",
        "text": "Get solder fatigue property fields based on the user configuration.\nAvailable Since: 2024R1\nSolder fatigue property fields based on the user configuration.\nlist[str]\nget_solder_fatigue_input_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "title": "get_solder_fatigue_input_fields > get_solder_fatigue_input_fields > get_solder_fatigue_input_fields",
        "section": "get_solder_fatigue_input_fields > get_solder_fatigue_input_fields",
        "text": "Analysis.get_solder_fatigue_input_fields() -> list[str]\n\nGet solder fatigue property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nReturns\n\nSolder fatigue property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_solder_fatigue_input_fields()"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CopyPottingRegionRequest.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod DeletePottingRegionRequest.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init.html#ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CircularShape.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json.html#ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PCBShape.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionCopyData.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema.html#ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CircularShape.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "UpdatePottingRegionRequest.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list.html#import_parts_list",
        "title": "import_parts_list",
        "section": "import_parts_list",
        "text": "Import a parts list for a CCA.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nimport_file (str) – Full path to the CSV file with the parts list.\nimport_as_user_src (bool) – Whether to set the data source of the properties to \"User\".\nOtherwise, the data source is set to the name of the CSV file.\nStatus code of the response. 0 for success.\nint\nimport_parts_list\n\"User\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list.html#ansys.sherlock.core.parts.Parts.import_parts_list",
        "title": "import_parts_list > import_parts_list > import_parts_list",
        "section": "import_parts_list > import_parts_list",
        "text": "Parts.import_parts_list(project: str, cca_name: str, import_file: str, import_as_user_src: bool) -> int\n\nImport a parts list for a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nimport_file (str) – Full path to the CSV file with the parts list.\n\nimport_as_user_src (bool) – Whether to set the data source of the properties to \"User\".\nOtherwise, the data source is set to the name of the CSV file.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.import_parts_list(\n    \"Test\",\n    \"Card\",\n    \"Parts List.csv\",\n    False\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.html#ansyssherlockcoretypeslayer_typespottingregionupdatedata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "text": "Contains the properties of a potting region update request.\nPottingRegionUpdateData.construct([_fields_set])\n\nPottingRegionUpdateData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionUpdateData.dict(*[, include, ...])\n\nPottingRegionUpdateData.from_orm(obj)\n\nPottingRegionUpdateData.json(*[, include, ...])\n\nPottingRegionUpdateData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionUpdateData.model_copy(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nPottingRegionUpdateData.model_dump(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nPottingRegionUpdateData.model_dump_json(*[, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nPottingRegionUpdateData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionUpdateData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionUpdateData.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionUpdateData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionUpdateData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionUpdateData.model_validate_json(...)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nPottingRegionUpdateData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionUpdateData.parse_file(path, *)\n\nPottingRegionUpdateData.parse_obj(obj)\n\nPottingRegionUpdateData.parse_raw(b, *[, ...])\n\nPottingRegionUpdateData.schema([by_alias, ...])\n\nPottingRegionUpdateData.schema_json(*[, ...])\n\nPottingRegionUpdateData.str_validation(...)\nValidate string fields listed.\nPottingRegionUpdateData.update_forward_refs(...)\n\nPottingRegionUpdateData.validate(value)\n\nPottingRegionUpdateData.model_computed_fields\n\nPottingRegionUpdateData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionUpdateData.model_extra\nGet extra fields set during validation.\nPottingRegionUpdateData.model_fields\n\nPottingRegionUpdateData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionUpdateData.potting_region_id_to_update\nId of the potting region to update.\nPottingRegionUpdateData.potting_region\nPotting region data used to update the potting region.\nansys.sherlock.core.types.layer_types.PottingRegionUpdateData\nPottingRegionUpdateData.construct\nPottingRegionUpdateData.copy\nPottingRegionUpdateData.dict\nPottingRegionUpdateData.from_orm\nPottingRegionUpdateData.json\nPottingRegionUpdateData.model_construct\nPottingRegionUpdateData.model_copy\nPottingRegionUpdateData.model_dump\nPottingRegionUpdateData.model_dump_json\nPottingRegionUpdateData.model_json_schema\nPottingRegionUpdateData.model_parametrized_name\nPottingRegionUpdateData.model_post_init\nPottingRegionUpdateData.model_rebuild\nPottingRegionUpdateData.model_validate\nPottingRegionUpdateData.model_validate_json\nPottingRegionUpdateData.model_validate_strings\nPottingRegionUpdateData.parse_file\nPottingRegionUpdateData.parse_obj\nPottingRegionUpdateData.parse_raw\nPottingRegionUpdateData.schema\nPottingRegionUpdateData.schema_json\nPottingRegionUpdateData.str_validation\nPottingRegionUpdateData.update_forward_refs\nPottingRegionUpdateData.validate\nPottingRegionUpdateData.model_computed_fields\nPottingRegionUpdateData.model_config\nPottingRegionUpdateData.model_extra\nPottingRegionUpdateData.model_fields\nPottingRegionUpdateData.model_fields_set\nPottingRegionUpdateData.potting_region_id_to_update\nPottingRegionUpdateData.potting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > PottingRegionUpdateData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > PottingRegionUpdateData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionUpdateData(*, potting_region_id_to_update: str, potting_region: PottingRegion)\n\nContains the properties of a potting region update request.\n\nMethods\n\n\n\n\n\n\n\nPottingRegionUpdateData.construct([_fields_set])\n\n\n\nPottingRegionUpdateData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionUpdateData.dict(*[, include, ...])\n\n\n\nPottingRegionUpdateData.from_orm(obj)\n\n\n\nPottingRegionUpdateData.json(*[, include, ...])\n\n\n\nPottingRegionUpdateData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionUpdateData.model_copy(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nPottingRegionUpdateData.model_dump(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nPottingRegionUpdateData.model_dump_json(*[, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nPottingRegionUpdateData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionUpdateData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionUpdateData.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionUpdateData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionUpdateData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionUpdateData.model_validate_json(...)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nPottingRegionUpdateData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionUpdateData.parse_file(path, *)\n\n\n\nPottingRegionUpdateData.parse_obj(obj)\n\n\n\nPottingRegionUpdateData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionUpdateData.schema([by_alias, ...])\n\n\n\nPottingRegionUpdateData.schema_json(*[, ...])\n\n\n\nPottingRegionUpdateData.str_validation(...)\n\nValidate string fields listed.\n\nPottingRegionUpdateData.update_forward_refs(...)\n\n\n\nPottingRegionUpdateData.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionUpdateData.model_computed_fields\n\n\n\nPottingRegionUpdateData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionUpdateData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionUpdateData.model_fields\n\n\n\nPottingRegionUpdateData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionUpdateData.potting_region_id_to_update\n\nId of the potting region to update.\n\nPottingRegionUpdateData.potting_region\n\nPotting region data used to update the potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod DeletePottingRegionRequest.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event.html#add_harmonic_event",
        "title": "add_harmonic_event",
        "section": "add_harmonic_event",
        "text": "Add a harmonic event to a life cycle phase.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nphase_name (str) – Name of the life cycle phase to add the harmonic event to.\nevent_name (str) – Name of the harmonic event.\nduration (float) – Event duration length.\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\nnum_of_cycles (float) – Number of cycles for the harmonic event.\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\nsweep_rate (float) – Sweep rate for the harmonic event.\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nprofile_type (str) – Profile type of the harmonic load. Options are \"Uniaxial\" and \"Triaxial\".\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\ndescription (str, optional) – Description of the harmonic event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_harmonic_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY_CYCLE\"\n\"PER_YEAR\"\n\"PER_DAY\"\n\"PER_HOUR\"\n\"PER_MIN\"\n\"PER_SEC\"\n\"azimuth, elevation\"\n\"30,15\"\n\"Uniaxial\"\n\"Triaxial\"\n\"x,y,z\"\n\"0,0,1\"\n\"\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "title": "add_harmonic_event > add_harmonic_event > add_harmonic_event",
        "section": "add_harmonic_event > add_harmonic_event",
        "text": "Lifecycle.add_harmonic_event(project: str, phase_name: str, event_name: str, duration: float, duration_units: str, num_of_cycles: float, cycle_type: str, sweep_rate: float, orientation: str, profile_type: str, load_direction: str, description: str = '') -> int\n\nAdd a harmonic event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nphase_name (str) – Name of the life cycle phase to add the harmonic event to.\n\nevent_name (str) – Name of the harmonic event.\n\nduration (float) – Event duration length.\n\nduration_units (str) – Event duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\n\nnum_of_cycles (float) – Number of cycles for the harmonic event.\n\ncycle_type (str) – Cycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\n\nsweep_rate (float) – Sweep rate for the harmonic event.\n\norientation (str) – PCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nprofile_type (str) – Profile type of the harmonic load. Options are \"Uniaxial\" and \"Triaxial\".\n\nload_direction (str) – Load direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription (str, optional) – Description of the harmonic event. The default is \"\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\"\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_harmonic_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    5,\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod UpdatePottingRegionRequest.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod RectangularShape.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.html#ansyssherlockcoretypesproject_typesboardbounds",
        "title": "ansys.sherlock.core.types.project_types.BoardBounds",
        "section": "ansys.sherlock.core.types.project_types.BoardBounds",
        "text": "Contains the properties of the board bounds.\nBoardBounds.bounds\nbounds (two tuples of the form (x, y)\nansys.sherlock.core.types.project_types.BoardBounds\nBoardBounds.bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.html#ansys.sherlock.core.types.project_types.BoardBounds",
        "title": "ansys.sherlock.core.types.project_types.BoardBounds > ansys.sherlock.core.types.project_types.BoardBounds > BoardBounds",
        "section": "ansys.sherlock.core.types.project_types.BoardBounds > BoardBounds",
        "text": "class ansys.sherlock.core.types.project_types.BoardBounds(bounds: list[tuple[float, float]])\n\nContains the properties of the board bounds.\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nBoardBounds.bounds\n\nbounds (two tuples of the form (x, y)\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionDeleteData.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionCopyData.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nReturns a copy of the model.\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep – Set to True to make a deep copy of the model.\nNew model instance.\nmodel_copy"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "UpdatePottingRegionRequest.model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -> Self\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nReturns a copy of the model.\n\nParameters\n\nupdate – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep – Set to True to make a deep copy of the model.\n\nReturns\n\nNew model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegion.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude – A set of fields to include in the output.\nexclude – A set of fields to exclude from the output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA dictionary representation of the model.\nmodel_dump"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionUpdateData.model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> dict[str, Any]\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude – A set of fields to include in the output.\n\nexclude – A set of fields to exclude from the output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA dictionary representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PolygonalShape.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionCopyData.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct.html#ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod SlotShape.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionDeleteData.model_parametrized_name(params: tuple[type[Any], ...]) -> str\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness.html#potting_thickness",
        "title": "potting_thickness",
        "section": "potting_thickness",
        "text": "The potting thickness.\npotting_thickness"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "title": "potting_thickness > potting_thickness > potting_thickness",
        "section": "potting_thickness > potting_thickness",
        "text": "PottingRegion.potting_thickness: float\n\nThe potting thickness."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format.html#numeric_format",
        "title": "numeric_format",
        "section": "numeric_format",
        "text": "numeric_format\nstr\nnumeric_format"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format.html#ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "title": "numeric_format > numeric_format > numeric_format",
        "section": "numeric_format > numeric_format",
        "text": "CsvExcelFile.numeric_format\n\nnumeric_format\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy.html#ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PolygonalShape.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "SlotShape.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation.html#legend_orientation",
        "title": "legend_orientation",
        "section": "legend_orientation",
        "text": "legend_orientation\nLegendOrientation\nlegend_orientation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation.html#ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "title": "legend_orientation > legend_orientation > legend_orientation",
        "section": "legend_orientation > legend_orientation",
        "text": "ImageFile.legend_orientation\n\nlegend_orientation\n\nType\n\nLegendOrientation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict.html#ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PCBShape.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionDeleteData.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionCopyData.validate(value: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "update_forward_refs"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CopyPottingRegionRequest.update_forward_refs(**localns: Any) -> None\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "schema"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionDeleteData.schema(by_alias: bool = True, ref_template: str = '#/$defs/{model}') -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "The name of the CCA.\ncca_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegion.cca_name: str\n\nThe name of the CCA."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionCopyData.str_validation(value: str, info: ValidationInfo)\n\nValidate string fields listed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct.html#ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod SlotShape.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property UpdatePottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region.html#add_potting_region",
        "title": "add_potting_region",
        "section": "add_potting_region",
        "text": "Add one or more potting regions to a given project.\nAvailable Since: 2024R1\nproject (str) – Name of the Sherlock project.\npotting_regions (list[dict[str, float | str | PolygonalShape | RectangularShape | SlotShape | CircularShape | PCBShape]]) – Potting region properties consisting of these properties:cca_name: str\n\nName of the CCA.\n\npotting_id: str\n\nPotting ID. The default is None.\n\nside: str\n\nThe side to add the potting region to. The default is None.\nOptions are \"TOP\", \"BOTTOM\", and \"BOT\".\n\nmaterial: str\n\nThe potting material. The default is None.\n\npotting_units: str\n\nThe potting region units. The default is None.\n\nthickness: float\n\nThe potting thickness. The default is None.\n\nstandoff: float\n\nThe potting standoff. The default is None.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the potting region.\nPotting region properties consisting of these properties:\nName of the CCA.\nPotting ID. The default is None.\nThe side to add the potting region to. The default is None.\nOptions are \"TOP\", \"BOTTOM\", and \"BOT\".\nThe potting material. The default is None.\nThe potting region units. The default is None.\nThe potting thickness. The default is None.\nThe potting standoff. The default is None.\nThe shape of the potting region.\nStatus code of the response. 0 for success.\nint\nadd_potting_region\nNone\nNone\n\"TOP\"\n\"BOTTOM\"\n\"BOT\"\nNone\nNone\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region.html#ansys.sherlock.core.layer.Layer.add_potting_region",
        "title": "add_potting_region > add_potting_region > add_potting_region",
        "section": "add_potting_region > add_potting_region",
        "text": "Layer.add_potting_region(project: str, potting_regions: list[dict[str, float | str | PolygonalShape | RectangularShape | SlotShape | CircularShape | PCBShape]]) -> int\n\nAdd one or more potting regions to a given project.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\npotting_regions (list[dict[str, float | str | PolygonalShape | RectangularShape | SlotShape | CircularShape | PCBShape]]) – Potting region properties consisting of these properties:cca_name: str\n\nName of the CCA.\n\npotting_id: str\n\nPotting ID. The default is None.\n\nside: str\n\nThe side to add the potting region to. The default is None.\nOptions are \"TOP\", \"BOTTOM\", and \"BOT\".\n\nmaterial: str\n\nThe potting material. The default is None.\n\npotting_units: str\n\nThe potting region units. The default is None.\n\nthickness: float\n\nThe potting thickness. The default is None.\n\nstandoff: float\n\nThe potting standoff. The default is None.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the potting region.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import PolygonalShape\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> polygonal_shape = PolygonalShape(points=[\n                (0, 0),\n                (0, 6.35),\n                (9.77, 0)\n            ], rotation=87.8)\n>>> sherlock.layer.add_potting_region(\n    \"Test\",\n    [{\n        'cca_name': 'Card',\n        'potting_id': 'Test Region',\n        'side': 'TOP',\n        'material': 'epoxyencapsulant',\n        'potting_units': 'in',\n        'thickness': 0.1,\n        'standoff': 0.2,\n        'shape': polygonal_shape\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width.html#width",
        "title": "width",
        "section": "width",
        "text": "width of the image\nfloat\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width.html#ansys.sherlock.core.types.project_types.ImageBounds.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "ImageBounds.width\n\nwidth of the image\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.exit",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.exit.html#exit",
        "title": "exit",
        "section": "exit",
        "text": "Close the gRPC connection.\nAvailable Since: 2023R1\nclose_sherlock_client (bool, optional) – Whether to close the Sherlock client when the gRPC connection is closed. The default\nis False, in which case the Sherlock client remains open when the gRPC connection\nis closed.\nexit\nFalse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.exit",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.exit.html#ansys.sherlock.core.common.Common.exit",
        "title": "exit > exit > exit",
        "section": "exit > exit",
        "text": "Common.exit(close_sherlock_client: bool = False)\n\nClose the gRPC connection.\n\nAvailable Since: 2023R1\n\nParameters\n\nclose_sherlock_client (bool, optional) – Whether to close the Sherlock client when the gRPC connection is closed. The default\nis False, in which case the Sherlock client remains open when the gRPC connection\nis closed."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props.html#update_part_list_validation_analysis_props",
        "title": "update_part_list_validation_analysis_props",
        "section": "update_part_list_validation_analysis_props",
        "text": "Update properties for a Part List Validation analysis.\nproject (str) – Name of the Sherlock project.\nproperties_per_cca (list[dict[str, bool | str]]) – Part List Validation analysis properties for each CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nprocess_use_avl: bool\n\nWhether to use AVL.\n\nprocess_use_wizard: bool\n\nWhether to use the wizard.\n\nprocess_check_confirmed_properties: bool\n\nWhether to check confirmed properties.\n\nprocess_check_part_numbers: bool\n\nWhether to check part numbers.\n\nmatching_mode: str\n\nMatching type.\n\navl_require_internal_part_number: bool\n\nWhether to require an internal part number.\n\navl_require_approved_description: bool\n\nWhether to require an approved description.\n\navl_require_approved_manufacturer: bool\n\nWhether to require an approved manufacturer.\nPart List Validation analysis properties for each CCA consisting of these properties:\nName of the CCA.\nWhether to use AVL.\nWhether to use the wizard.\nWhether to check confirmed properties.\nWhether to check part numbers.\nMatching type.\nWhether to require an internal part number.\nWhether to require an approved description.\nWhether to require an approved manufacturer.\nStatus code of the response. 0 for success.\nint\nupdate_part_list_validation_analysis_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props.html#ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "title": "update_part_list_validation_analysis_props > update_part_list_validation_analysis_props > update_part_list_validation_analysis_props",
        "section": "update_part_list_validation_analysis_props > update_part_list_validation_analysis_props",
        "text": "Analysis.update_part_list_validation_analysis_props(project: str, properties_per_cca: list[dict[str, bool | str]]) -> int\n\nUpdate properties for a Part List Validation analysis.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nproperties_per_cca (list[dict[str, bool | str]]) – Part List Validation analysis properties for each CCA consisting of these properties:cca_name: str\n\nName of the CCA.\n\nprocess_use_avl: bool\n\nWhether to use AVL.\n\nprocess_use_wizard: bool\n\nWhether to use the wizard.\n\nprocess_check_confirmed_properties: bool\n\nWhether to check confirmed properties.\n\nprocess_check_part_numbers: bool\n\nWhether to check part numbers.\n\nmatching_mode: str\n\nMatching type.\n\navl_require_internal_part_number: bool\n\nWhether to require an internal part number.\n\navl_require_approved_description: bool\n\nWhether to require an approved description.\n\navl_require_approved_manufacturer: bool\n\nWhether to require an approved manufacturer.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_part_list_validation_analysis_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"process_use_avl\": True,\n        \"process_use_wizard\": False,\n        \"process_check_confirmed_properties\": True,\n        \"process_check_part_numbers\": True,\n        \"matching_mode\": \"Part\",\n        \"avl_require_internal_part_number\": True,\n        \"avl_require_approved_description\": False,\n        \"avl_require_approved_manufacturer\": True,\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CopyPottingRegionRequest.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.html#ansyssherlockcoremodelmodel",
        "title": "ansys.sherlock.core.model.Model",
        "section": "ansys.sherlock.core.model.Model",
        "text": "Contains all model generation capabilities.\nModel.createExportTraceCopperLayerParams(...)\nCreate a set of parameters to be used to export a single copper layer.\nModel.exportTraceModel(layer_params)\nExport a trace model to a specified output file.\nModel.export_FEA_model(project, cca_name, ...)\nExport a FEA model.\nModel.export_aedb(project_name, cca_name, ...)\nExport an Electronics Desktop model.\nModel.export_trace_reinforcement_model(...)\nExport a trace reinforcement model.\nModel.generate_trace_model(project_name[, ...])\nGenerate one or more trace models for a project.\nansys.sherlock.core.model.Model\nModel.createExportTraceCopperLayerParams\nModel.exportTraceModel\nModel.export_FEA_model\nModel.export_aedb\nModel.export_trace_reinforcement_model\nModel.generate_trace_model"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.html#ansys.sherlock.core.model.Model",
        "title": "ansys.sherlock.core.model.Model > ansys.sherlock.core.model.Model > Model",
        "section": "ansys.sherlock.core.model.Model > Model",
        "text": "class ansys.sherlock.core.model.Model(channel: grpc.Channel, server_version: int)\n\nContains all model generation capabilities.\n\nMethods\n\n\n\n\n\n\n\nModel.createExportTraceCopperLayerParams(...)\n\nCreate a set of parameters to be used to export a single copper layer.\n\nModel.exportTraceModel(layer_params)\n\nExport a trace model to a specified output file.\n\nModel.export_FEA_model(project, cca_name, ...)\n\nExport a FEA model.\n\nModel.export_aedb(project_name, cca_name, ...)\n\nExport an Electronics Desktop model.\n\nModel.export_trace_reinforcement_model(...)\n\nExport a trace reinforcement model.\n\nModel.generate_trace_model(project_name[, ...])\n\nGenerate one or more trace models for a project.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CircularShape.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "parse_obj"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod DeletePottingRegionRequest.parse_obj(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units.html#max_temperature_units",
        "title": "max_temperature_units",
        "section": "max_temperature_units",
        "text": "max_temperature_units\nstr\nmax_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units.html#ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "title": "max_temperature_units > max_temperature_units > max_temperature_units",
        "section": "max_temperature_units > max_temperature_units",
        "text": "ImageFile.max_temperature_units\n\nmax_temperature_units\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report.html#generate_project_report",
        "title": "generate_project_report",
        "section": "generate_project_report",
        "text": "Generate a project report.\nAvailable Since: 2021R1\nproject (str) – Name of the Sherlock project.\nauthor (str) – Name of the author who is generating the report.\ncompany (str) – Name of the author’s company.\nreport_file (str) – Full path to where to create the report.\nStatus code of the response. 0 for success.\nint\ngenerate_project_report"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report.html#ansys.sherlock.core.project.Project.generate_project_report",
        "title": "generate_project_report > generate_project_report > generate_project_report",
        "section": "generate_project_report > generate_project_report",
        "text": "Project.generate_project_report(project: str, author: str, company: str, report_file: str) -> int\n\nGenerate a project report.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nauthor (str) – Name of the author who is generating the report.\n\ncompany (str) – Name of the author’s company.\n\nreport_file (str) – Full path to where to create the report.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\"ODB++ Tutorial.tgz\", True, True,\n                        True, True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\")\n>>> sherlock.project.generate_project_report(\n    \"Tutorial\",\n    \"John Doe\",\n    \"Example\",\n    \"Project Report.pdf\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.html#ansyssherlockcoretypeslayer_typescircularshape",
        "title": "ansys.sherlock.core.types.layer_types.CircularShape",
        "section": "ansys.sherlock.core.types.layer_types.CircularShape",
        "text": "Contains the properties for a circular shape.\nCircularShape.construct([_fields_set])\n\nCircularShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nCircularShape.dict(*[, include, exclude, ...])\n\nCircularShape.from_orm(obj)\n\nCircularShape.json(*[, include, exclude, ...])\n\nCircularShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nCircularShape.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nCircularShape.model_dump(*[, mode, include, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nCircularShape.model_dump_json(*[, indent, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nCircularShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nCircularShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCircularShape.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCircularShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nCircularShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nCircularShape.model_validate_json(json_data, *)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nCircularShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCircularShape.parse_file(path, *[, ...])\n\nCircularShape.parse_obj(obj)\n\nCircularShape.parse_raw(b, *[, ...])\n\nCircularShape.schema([by_alias, ref_template])\n\nCircularShape.schema_json(*[, by_alias, ...])\n\nCircularShape.update_forward_refs(**localns)\n\nCircularShape.validate(value)\n\nCircularShape.model_computed_fields\n\nCircularShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCircularShape.model_extra\nGet extra fields set during validation.\nCircularShape.model_fields\n\nCircularShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nCircularShape.diameter\nfloat\nCircularShape.node_count\nint\nCircularShape.center_x\nfloat\nCircularShape.center_y\nfloat\nCircularShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.CircularShape\nCircularShape.construct\nCircularShape.copy\nCircularShape.dict\nCircularShape.from_orm\nCircularShape.json\nCircularShape.model_construct\nCircularShape.model_copy\nCircularShape.model_dump\nCircularShape.model_dump_json\nCircularShape.model_json_schema\nCircularShape.model_parametrized_name\nCircularShape.model_post_init\nCircularShape.model_rebuild\nCircularShape.model_validate\nCircularShape.model_validate_json\nCircularShape.model_validate_strings\nCircularShape.parse_file\nCircularShape.parse_obj\nCircularShape.parse_raw\nCircularShape.schema\nCircularShape.schema_json\nCircularShape.update_forward_refs\nCircularShape.validate\nCircularShape.model_computed_fields\nCircularShape.model_config\nCircularShape.model_extra\nCircularShape.model_fields\nCircularShape.model_fields_set\nCircularShape.diameter\nCircularShape.node_count\nCircularShape.center_x\nCircularShape.center_y\nCircularShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.html#ansys.sherlock.core.types.layer_types.CircularShape",
        "title": "ansys.sherlock.core.types.layer_types.CircularShape > ansys.sherlock.core.types.layer_types.CircularShape > CircularShape",
        "section": "ansys.sherlock.core.types.layer_types.CircularShape > CircularShape",
        "text": "class ansys.sherlock.core.types.layer_types.CircularShape(*, diameter: float, node_count: int, center_x: float, center_y: float, rotation: float)\n\nContains the properties for a circular shape.\n\nMethods\n\n\n\n\n\n\n\nCircularShape.construct([_fields_set])\n\n\n\nCircularShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nCircularShape.dict(*[, include, exclude, ...])\n\n\n\nCircularShape.from_orm(obj)\n\n\n\nCircularShape.json(*[, include, exclude, ...])\n\n\n\nCircularShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nCircularShape.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nCircularShape.model_dump(*[, mode, include, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nCircularShape.model_dump_json(*[, indent, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nCircularShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nCircularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCircularShape.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCircularShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCircularShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nCircularShape.model_validate_json(json_data, *)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nCircularShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCircularShape.parse_file(path, *[, ...])\n\n\n\nCircularShape.parse_obj(obj)\n\n\n\nCircularShape.parse_raw(b, *[, ...])\n\n\n\nCircularShape.schema([by_alias, ref_template])\n\n\n\nCircularShape.schema_json(*[, by_alias, ...])\n\n\n\nCircularShape.update_forward_refs(**localns)\n\n\n\nCircularShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCircularShape.model_computed_fields\n\n\n\nCircularShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCircularShape.model_extra\n\nGet extra fields set during validation.\n\nCircularShape.model_fields\n\n\n\nCircularShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nCircularShape.diameter\n\nfloat\n\nCircularShape.node_count\n\nint\n\nCircularShape.center_x\n\nfloat\n\nCircularShape.center_y\n\nfloat\n\nCircularShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height.html#height",
        "title": "height",
        "section": "height",
        "text": "height of the image\nfloat\nheight"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height.html#ansys.sherlock.core.types.project_types.ImageBounds.height",
        "title": "height > height > height",
        "section": "height > height",
        "text": "ImageBounds.height\n\nheight of the image\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields.html#ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PCBShape.model_fields: ClassVar[dict[str, FieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PolygonalShape.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod SlotShape.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict.html#ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "SlotShape.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb.html#export_aedb",
        "title": "export_aedb",
        "section": "export_aedb",
        "text": "Export an Electronics Desktop model.\nAvailable Since: 2024R2\nproject_name (str) – Name of the Sherlock project to generate the EDB model for.\ncca_name (str) – Name of the CCA to generate the EDB model from.\nexport_file (str) – Directory for saving exported model to.\noverwrite (bool, optional) – Whether to overwrite an existing file having the same file name.\nThe default is True.\ndisplay_model (bool, optional) – Whether to launch and display the exported model in Ansys Electronics\nDesktop once the export finishes. The default is False.\nStatus code of the response. 0 for success.\nint\nexport_aedb\nTrue\nFalse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb.html#ansys.sherlock.core.model.Model.export_aedb",
        "title": "export_aedb > export_aedb > export_aedb",
        "section": "export_aedb > export_aedb",
        "text": "Model.export_aedb(project_name: str, cca_name: str, export_file: str, overwrite: bool = True, display_model: bool = False) -> int\n\nExport an Electronics Desktop model.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject_name (str) – Name of the Sherlock project to generate the EDB model for.\n\ncca_name (str) – Name of the CCA to generate the EDB model from.\n\nexport_file (str) – Directory for saving exported model to.\n\noverwrite (bool, optional) – Whether to overwrite an existing file having the same file name.\nThe default is True.\n\ndisplay_model (bool, optional) – Whether to launch and display the exported model in Ansys Electronics\nDesktop once the export finishes. The default is False.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_aedb(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.aedb',\n    True, False)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive.html#import_ipc2581_archive",
        "title": "import_ipc2581_archive",
        "section": "import_ipc2581_archive",
        "text": "Import an IPC-2581 archive file.\nAvailable Since: 2021R1\narchive_file (str) – Full path to the IPC-2581 archive file.\ninclude_other_layers (bool) – Whether to include other layers.\nguess_part_properties (bool) – Whether to guess part properties\nproject (str, optional) – Name of the Sherlock project. The default is None, in which case\nthe name of the IPC-2581 archive file is used for the project name.\ncca_name (str, optional) – Name of the CCA. The default is None, in which case the name of\nthe IPC-2581 archive file is used for the CCA name.\npolyline_simplification (bool, optional) – Whether to enable polyline simplification\npolyline_tolerance (float, optional) – Polyline simplification tolerance\npolyline_tolerance_units (str, optional) – Polyline simplification tolerance units\nStatus code of the response. 0 for success.\nint\nimport_ipc2581_archive\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive.html#ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "title": "import_ipc2581_archive > import_ipc2581_archive > import_ipc2581_archive",
        "section": "import_ipc2581_archive > import_ipc2581_archive",
        "text": "Project.import_ipc2581_archive(archive_file: str, include_other_layers: bool, guess_part_properties: bool, project: str | None = None, cca_name: str | None = None, polyline_simplification: bool = False, polyline_tolerance: float = 0.1, polyline_tolerance_units: str = 'mm') -> int\n\nImport an IPC-2581 archive file.\n\nAvailable Since: 2021R1\n\nParameters\n\narchive_file (str) – Full path to the IPC-2581 archive file.\n\ninclude_other_layers (bool) – Whether to include other layers.\n\nguess_part_properties (bool) – Whether to guess part properties\n\nproject (str, optional) – Name of the Sherlock project. The default is None, in which case\nthe name of the IPC-2581 archive file is used for the project name.\n\ncca_name (str, optional) – Name of the CCA. The default is None, in which case the name of\nthe IPC-2581 archive file is used for the CCA name.\n\npolyline_simplification (bool, optional) – Whether to enable polyline simplification\n\npolyline_tolerance (float, optional) – Polyline simplification tolerance\n\npolyline_tolerance_units (str, optional) – Polyline simplification tolerance units\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_ipc2581_archive(\"Tutorial.zip\", True, True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\",\n                        polyline_simplification=True,\n                        polyline_tolerance=0.1,\n                        polyline_tolerance_units=\"mm\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionDeleteData.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod RectangularShape.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionUpdateData.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PCBShape.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj – The object to validate.\nstrict – Whether to enforce types strictly.\nfrom_attributes – Whether to extract data from object attributes.\ncontext – Additional context to pass to the validator.\nValidationError – If the object could not be validated.\nThe validated model instance.\nmodel_validate"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionUpdateData.model_validate(obj: Any, *, strict: bool | None = None, from_attributes: bool | None = None, context: Any | None = None) -> Self\n\nValidate a pydantic model instance.\n\nParameters\n\nobj – The object to validate.\n\nstrict – Whether to enforce types strictly.\n\nfrom_attributes – Whether to extract data from object attributes.\n\ncontext – Additional context to pass to the validator.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturns\n\nThe validated model instance."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model.html#generate_trace_model",
        "title": "generate_trace_model",
        "section": "generate_trace_model",
        "text": "Generate one or more trace models for a project.\nAvailable Since: 2023R2\nproject_name (str) – Name of the Sherlock project to generate one or more trace models for.\ncca_name (str, optional) – Name of the CCA to generate one or more trace models from. The default is\n\"\", in which case trace models are generated for CCAs and\nall layers.\ncopper_layer_name (str, optional) – Name of the copper layer to generate one or more trace models from. The default\nis \"\", in which case trace models are generated either for the given CCA\nor for all layers.\nmax_arc_segment (float, optional) – Maximum length of the segment to generate when Sherlock\nconverts EDA arc drawing commands to line segments. The default is\n0.0. Smaller values for the maximum arc segment result in smoother\narc representations on the FEA model. However, the cost of generating a\nlarger number of shorter segments is higher. Such short segments cause\nthe FEA tool to generate a larger number of smaller elements to represent\nthe curved solid.\nmax_arc_segment_units (str, optional) – Units for the maximum arc segment. The default is \"mm\".\nmin_trace_area (float, optional) – Minimum area of any trace polygon to include in the trace model.\nThe default is 0.0, which turns off any area filtering.\nmin_trace_area_units (str, optional) – Units for the minimum trace area. The default is \"mm2\".\nmin_hole_area (float, optional) – Minimum area of any trace hole to include in the trace model.\nThe default is 0.0, which turns off any hole filtering.\nmin_hole_area_units (str, optional) – Units for the minimum hole area. The default is \"mm2\".\nuse_snapshot_for_non_image_layer (bool, optional) – Whether to use an image to generate the trace model for layers that are not\nimage layers. The default is False. If True and a snapshot image for\nthe layer exists, the snapshot image is used. Otherwise, an image is created\nin the same way as a snapshot image is created.\nStatus code of the response. 0 for success.\nint\ngenerate_trace_model\n\"\"\n\"\"\n0.0\n\"mm\"\n0.0\n\"mm2\"\n0.0\n\"mm2\"\nFalse\nTrue"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model.html#ansys.sherlock.core.model.Model.generate_trace_model",
        "title": "generate_trace_model > generate_trace_model > generate_trace_model",
        "section": "generate_trace_model > generate_trace_model",
        "text": "Model.generate_trace_model(project_name, cca_name: str = '', copper_layer_name: str = '', max_arc_segment: float = 0.0, max_arc_segment_units: str = 'mm', min_trace_area: float = 0.0, min_trace_area_units: str = 'mm2', min_hole_area: float = 0.0, min_hole_area_units: str = 'mm2', use_snapshot_for_non_image_layer: bool = False) -> int\n\nGenerate one or more trace models for a project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject_name (str) – Name of the Sherlock project to generate one or more trace models for.\n\ncca_name (str, optional) – Name of the CCA to generate one or more trace models from. The default is\n\"\", in which case trace models are generated for CCAs and\nall layers.\n\ncopper_layer_name (str, optional) – Name of the copper layer to generate one or more trace models from. The default\nis \"\", in which case trace models are generated either for the given CCA\nor for all layers.\n\nmax_arc_segment (float, optional) – Maximum length of the segment to generate when Sherlock\nconverts EDA arc drawing commands to line segments. The default is\n0.0. Smaller values for the maximum arc segment result in smoother\narc representations on the FEA model. However, the cost of generating a\nlarger number of shorter segments is higher. Such short segments cause\nthe FEA tool to generate a larger number of smaller elements to represent\nthe curved solid.\n\nmax_arc_segment_units (str, optional) – Units for the maximum arc segment. The default is \"mm\".\n\nmin_trace_area (float, optional) – Minimum area of any trace polygon to include in the trace model.\nThe default is 0.0, which turns off any area filtering.\n\nmin_trace_area_units (str, optional) – Units for the minimum trace area. The default is \"mm2\".\n\nmin_hole_area (float, optional) – Minimum area of any trace hole to include in the trace model.\nThe default is 0.0, which turns off any hole filtering.\n\nmin_hole_area_units (str, optional) – Units for the minimum hole area. The default is \"mm2\".\n\nuse_snapshot_for_non_image_layer (bool, optional) – Whether to use an image to generate the trace model for layers that are not\nimage layers. The default is False. If True and a snapshot image for\nthe layer exists, the snapshot image is used. Otherwise, an image is created\nin the same way as a snapshot image is created.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.generate_trace_model(\n    'Tutorial Project', 'Main Board', 0.05, 'mm'\n    0.0, 'mm2', 0.0, 'mm2')"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.html#ansyssherlockcoretypeslayer_typesslotshape",
        "title": "ansys.sherlock.core.types.layer_types.SlotShape",
        "section": "ansys.sherlock.core.types.layer_types.SlotShape",
        "text": "Contains the properties for a slot shape.\nSlotShape.construct([_fields_set])\n\nSlotShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nSlotShape.dict(*[, include, exclude, ...])\n\nSlotShape.from_orm(obj)\n\nSlotShape.json(*[, include, exclude, ...])\n\nSlotShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nSlotShape.model_copy(*[, update, deep])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\nSlotShape.model_dump(*[, mode, include, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\nSlotShape.model_dump_json(*[, indent, ...])\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nSlotShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nSlotShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nSlotShape.model_post_init(_BaseModel__context)\nOverride this method to perform additional initialization after __init__ and model_construct.\nSlotShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nSlotShape.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nSlotShape.model_validate_json(json_data, *)\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\nSlotShape.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nSlotShape.parse_file(path, *[, ...])\n\nSlotShape.parse_obj(obj)\n\nSlotShape.parse_raw(b, *[, content_type, ...])\n\nSlotShape.schema([by_alias, ref_template])\n\nSlotShape.schema_json(*[, by_alias, ...])\n\nSlotShape.update_forward_refs(**localns)\n\nSlotShape.validate(value)\n\nSlotShape.model_computed_fields\n\nSlotShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nSlotShape.model_extra\nGet extra fields set during validation.\nSlotShape.model_fields\n\nSlotShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nSlotShape.length\nfloat\nSlotShape.width\nfloat\nSlotShape.node_count\nint\nSlotShape.center_x\nfloat\nSlotShape.center_y\nfloat\nSlotShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.SlotShape\nSlotShape.construct\nSlotShape.copy\nSlotShape.dict\nSlotShape.from_orm\nSlotShape.json\nSlotShape.model_construct\nSlotShape.model_copy\nSlotShape.model_dump\nSlotShape.model_dump_json\nSlotShape.model_json_schema\nSlotShape.model_parametrized_name\nSlotShape.model_post_init\nSlotShape.model_rebuild\nSlotShape.model_validate\nSlotShape.model_validate_json\nSlotShape.model_validate_strings\nSlotShape.parse_file\nSlotShape.parse_obj\nSlotShape.parse_raw\nSlotShape.schema\nSlotShape.schema_json\nSlotShape.update_forward_refs\nSlotShape.validate\nSlotShape.model_computed_fields\nSlotShape.model_config\nSlotShape.model_extra\nSlotShape.model_fields\nSlotShape.model_fields_set\nSlotShape.length\nSlotShape.width\nSlotShape.node_count\nSlotShape.center_x\nSlotShape.center_y\nSlotShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.html#ansys.sherlock.core.types.layer_types.SlotShape",
        "title": "ansys.sherlock.core.types.layer_types.SlotShape > ansys.sherlock.core.types.layer_types.SlotShape > SlotShape",
        "section": "ansys.sherlock.core.types.layer_types.SlotShape > SlotShape",
        "text": "class ansys.sherlock.core.types.layer_types.SlotShape(*, length: float, width: float, node_count: int, center_x: float, center_y: float, rotation: float)\n\nContains the properties for a slot shape.\n\nMethods\n\n\n\n\n\n\n\nSlotShape.construct([_fields_set])\n\n\n\nSlotShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nSlotShape.dict(*[, include, exclude, ...])\n\n\n\nSlotShape.from_orm(obj)\n\n\n\nSlotShape.json(*[, include, exclude, ...])\n\n\n\nSlotShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nSlotShape.model_copy(*[, update, deep])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#model_copy\n\nSlotShape.model_dump(*[, mode, include, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump\n\nSlotShape.model_dump_json(*[, indent, ...])\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nSlotShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nSlotShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nSlotShape.model_post_init(_BaseModel__context)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nSlotShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nSlotShape.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nSlotShape.model_validate_json(json_data, *)\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/json/#json-parsing\n\nSlotShape.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nSlotShape.parse_file(path, *[, ...])\n\n\n\nSlotShape.parse_obj(obj)\n\n\n\nSlotShape.parse_raw(b, *[, content_type, ...])\n\n\n\nSlotShape.schema([by_alias, ref_template])\n\n\n\nSlotShape.schema_json(*[, by_alias, ...])\n\n\n\nSlotShape.update_forward_refs(**localns)\n\n\n\nSlotShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nSlotShape.model_computed_fields\n\n\n\nSlotShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nSlotShape.model_extra\n\nGet extra fields set during validation.\n\nSlotShape.model_fields\n\n\n\nSlotShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nSlotShape.length\n\nfloat\n\nSlotShape.width\n\nfloat\n\nSlotShape.node_count\n\nint\n\nSlotShape.center_x\n\nfloat\n\nSlotShape.center_y\n\nfloat\n\nSlotShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "getting_started/installation",
        "href": "getting_started/installation.html#install-packages",
        "title": "Install packages",
        "section": "Install packages",
        "text": "The ansys-sherlock-core package supports Python 3.10 through Python 3.12 on Windows.\nTo use PySherlock, you must download and install both the ansys-api-sherlock\nand ansys-sherlock-core packages. By using pip, ansys-api-sherlock is\ninstalled as part of ansys-sherlock-core. Run the following to install\nthe publicly distributed version of the package.\nIf you want to install the ansys-api-sherlock and ansys-sherlock-core packages\nfrom its source code directly, follow these instructions.\nDownload the latest ansys-api-sherlock package by running this\ngit clone command:\nAlternatively, you can download the ZIP file from the Release area of the\nansys-api-sherlock GitHub\nrepository and unzip it before proceeding with the installation.\nAfter the package is downloaded, execute these commands to install it:\nDownload the latest ansys-sherlock-core package by running this\ngit clone command:\nAlternatively, you can download the ZIP file from the Release area of the\npysherlock GitHub repository\nand unzip it before proceeding with the installation.\nAfter the package is downloaded, execute these commands to install it:\nInstall packages\nansys-sherlock-core\nansys-api-sherlock\nansys-sherlock-core\npip\nansys-api-sherlock\nansys-sherlock-core\nansys-api-sherlock\nansys-sherlock-core\nansys-api-sherlock\ngit clone\nansys-sherlock-core\ngit clone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict.html#ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CircularShape.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CopyPottingRegionRequest.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PolygonalShape.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region.html#create_cca_from_modeling_region",
        "title": "create_cca_from_modeling_region",
        "section": "create_cca_from_modeling_region",
        "text": "Create one or more CCAs from modeling regions in a given project.\nproject (str) – Name of the Sherlock project.\ncca_from_mr_properties (list[dict[str, bool | float | str]]) – CCAs to be created from modeling regions consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodeling_region_id: str\n\nName of the modeling region.\n\ndescription: str\n\nDescription of the CCA.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties: bool\n\nWhether to enable guess part properties. The default is None.\n\ngenerate_image_layers: bool\n\nWhether to generate image layers or not.  The default is None.\nCCAs to be created from modeling regions consisting of these properties:\nName of the CCA.\nName of the modeling region.\nDescription of the CCA.\nThe default solder type. The default is None.\nThe default stencil thickness. The default is None.\nUnits for default stencil thickness. The default is None.\nDefault part temp rise. The default is None.\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nWhether to enable guess part properties. The default is None.\nWhether to generate image layers or not.  The default is None.\nStatus code of the response. 0 for success.\nint\ncreate_cca_from_modeling_region\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region.html#ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "title": "create_cca_from_modeling_region > create_cca_from_modeling_region > create_cca_from_modeling_region",
        "section": "create_cca_from_modeling_region > create_cca_from_modeling_region",
        "text": "Project.create_cca_from_modeling_region(project: str, cca_from_mr_properties: list[dict[str, bool | float | str]]) -> int\n\nCreate one or more CCAs from modeling regions in a given project.\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_from_mr_properties (list[dict[str, bool | float | str]]) – CCAs to be created from modeling regions consisting of these properties:cca_name: str\n\nName of the CCA.\n\nmodeling_region_id: str\n\nName of the modeling region.\n\ndescription: str\n\nDescription of the CCA.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties: bool\n\nWhether to enable guess part properties. The default is None.\n\ngenerate_image_layers: bool\n\nWhether to generate image layers or not.  The default is None.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.project.create_cca_from_modeling_region(\n    \"Test\",\n    [{\n        'cca_name': 'Card',\n        'modeling_region_id': 'MR1'\n        'description': 'Test',\n        'default_solder_type': 'SAC305',\n        'default_stencil_thickness': 10,\n        'default_stencil_thickness_units': 'mm',\n        'default_part_temp_rise': 20,\n        'default_part_temp_rise_units': 'C',\n        'guess_part_properties': False,\n        'generate_image_layers': False,\n    },\n    ]\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions.html#update_potting_regions",
        "title": "update_potting_regions",
        "section": "update_potting_regions",
        "text": "List of potting region data to update.\nupdate_potting_regions"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "title": "update_potting_regions > update_potting_regions > update_potting_regions",
        "section": "update_potting_regions > update_potting_regions",
        "text": "UpdatePottingRegionRequest.update_potting_regions: list[PottingRegionUpdateData]\n\nList of potting region data to update."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config.html#ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "SlotShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict]."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod DeletePottingRegionRequest.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff.html#potting_standoff",
        "title": "potting_standoff",
        "section": "potting_standoff",
        "text": "The potting standoff.\npotting_standoff"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "title": "potting_standoff > potting_standoff > potting_standoff",
        "section": "potting_standoff > potting_standoff",
        "text": "PottingRegion.potting_standoff: float\n\nThe potting standoff."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionDeleteData.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile.html#load_random_vibe_profile",
        "title": "load_random_vibe_profile",
        "section": "load_random_vibe_profile",
        "text": "Load random vibe profile from .csv or .dat file.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project\nphase_name (str) – Name of the lifecycle phase to add this event to.\nevent_name (str) – Name of the random vibe event.\nfile_path (str) – File path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_random_vibe_profile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "title": "load_random_vibe_profile > load_random_vibe_profile > load_random_vibe_profile",
        "section": "load_random_vibe_profile > load_random_vibe_profile",
        "text": "Lifecycle.load_random_vibe_profile(project: str, phase_name: str, event_name: str, file_path: str) -> int\n\nLoad random vibe profile from .csv or .dat file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project\n\nphase_name (str) – Name of the lifecycle phase to add this event to.\n\nevent_name (str) – Name of the random vibe event.\n\nfile_path (str) – File path for thermal profile .dat or .csv file\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n\n>>> sherlock.lifecycle.load_random_vibe_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Random Event\",\n        file_path=\"TestProfile.dat\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionCopyData.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#common-types",
        "title": "Common Types",
        "section": "Common Types",
        "text": "Module containing types for the Common Service.\nCommon Types"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#constants",
        "title": "Common Types > Constants",
        "section": "Constants",
        "text": "Constants for Unit Type in the List Units request.\nACCELERATION\nACCEL_DENSITY\nAREA\nBANDWIDTH\nCAPACITANCE\nCTE\nCURRENT\nDENSITY\nDISP_DENSITY\nFORCE\nFREQUENCY\nINDUCTANCE\nLENGTH\nPOWER\nRESISTANCE\nSIZE\nSPECIFIC_HEAT\nSTRAIN\nSTRESS\nTEMPERATURE\nTHERMAL_CONDUCTIVITY\nTHERMAL_RESISTANCE\nTIME\nVELOCITY\nVELOCITY_DENSITY\nVOLTAGE\nVOLUME\nWEIGHT\nTypes of delimiters that can be used for exporting tables.\nCOMMA\nSEMICOLON\nSPACE\nTAB\nContains the properties of the measurement.\nmeasurement units\nstr\nmeasurement value\nfloat\nConstants"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType",
        "title": "Common Types > Constants > ListUnitsRequestUnitType",
        "section": "Constants > ListUnitsRequestUnitType",
        "text": "class ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType\n\nConstants for Unit Type in the List Units request.\n\n\n\nACCELERATION\n\nACCELERATION\n\n\n\nACCEL_DENSITY\n\nACCEL_DENSITY\n\n\n\nAREA\n\nAREA\n\n\n\nBANDWIDTH\n\nBANDWIDTH\n\n\n\nCAPACITANCE\n\nCAPACITANCE\n\n\n\nCTE\n\nCTE\n\n\n\nCURRENT\n\nCURRENT\n\n\n\nDENSITY\n\nDENSITY\n\n\n\nDISP_DENSITY\n\nDISP_DENSITY\n\n\n\nFORCE\n\nFORCE\n\n\n\nFREQUENCY\n\nFREQUENCY\n\n\n\nINDUCTANCE\n\nINDUCTANCE\n\n\n\nLENGTH\n\nLENGTH\n\n\n\nPOWER\n\nPOWER\n\n\n\nRESISTANCE\n\nRESISTANCE\n\n\n\nSIZE\n\nSIZE\n\n\n\nSPECIFIC_HEAT\n\nSPECIFIC_HEAT\n\n\n\nSTRAIN\n\nSTRAIN\n\n\n\nSTRESS\n\nSTRESS\n\n\n\nTEMPERATURE\n\nTEMPERATURE\n\n\n\nTHERMAL_CONDUCTIVITY\n\nTHERMAL_CONDUCTIVITY\n\n\n\nTHERMAL_RESISTANCE\n\nTHERMAL_RESISTANCE\n\n\n\nTIME\n\nTIME\n\n\n\nVELOCITY\n\nVELOCITY\n\n\n\nVELOCITY_DENSITY\n\nVELOCITY_DENSITY\n\n\n\nVOLTAGE\n\nVOLTAGE\n\n\n\nVOLUME\n\nVOLUME\n\n\n\nWEIGHT\n\nWEIGHT"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.ACCELERATION",
        "title": "Common Types > Constants > ACCELERATION",
        "section": "Constants > ACCELERATION",
        "text": "ACCELERATION\n\nACCELERATION"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.ACCEL_DENSITY",
        "title": "Common Types > Constants > ACCEL_DENSITY",
        "section": "Constants > ACCEL_DENSITY",
        "text": "ACCEL_DENSITY\n\nACCEL_DENSITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.AREA",
        "title": "Common Types > Constants > AREA",
        "section": "Constants > AREA",
        "text": "AREA\n\nAREA"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.BANDWIDTH",
        "title": "Common Types > Constants > BANDWIDTH",
        "section": "Constants > BANDWIDTH",
        "text": "BANDWIDTH\n\nBANDWIDTH"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CAPACITANCE",
        "title": "Common Types > Constants > CAPACITANCE",
        "section": "Constants > CAPACITANCE",
        "text": "CAPACITANCE\n\nCAPACITANCE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CTE",
        "title": "Common Types > Constants > CTE",
        "section": "Constants > CTE",
        "text": "CTE\n\nCTE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CURRENT",
        "title": "Common Types > Constants > CURRENT",
        "section": "Constants > CURRENT",
        "text": "CURRENT\n\nCURRENT"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.DENSITY",
        "title": "Common Types > Constants > DENSITY",
        "section": "Constants > DENSITY",
        "text": "DENSITY\n\nDENSITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.DISP_DENSITY",
        "title": "Common Types > Constants > DISP_DENSITY",
        "section": "Constants > DISP_DENSITY",
        "text": "DISP_DENSITY\n\nDISP_DENSITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.FORCE",
        "title": "Common Types > Constants > FORCE",
        "section": "Constants > FORCE",
        "text": "FORCE\n\nFORCE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.FREQUENCY",
        "title": "Common Types > Constants > FREQUENCY",
        "section": "Constants > FREQUENCY",
        "text": "FREQUENCY\n\nFREQUENCY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.INDUCTANCE",
        "title": "Common Types > Constants > INDUCTANCE",
        "section": "Constants > INDUCTANCE",
        "text": "INDUCTANCE\n\nINDUCTANCE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.LENGTH",
        "title": "Common Types > Constants > LENGTH",
        "section": "Constants > LENGTH",
        "text": "LENGTH\n\nLENGTH"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.POWER",
        "title": "Common Types > Constants > POWER",
        "section": "Constants > POWER",
        "text": "POWER\n\nPOWER"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.RESISTANCE",
        "title": "Common Types > Constants > RESISTANCE",
        "section": "Constants > RESISTANCE",
        "text": "RESISTANCE\n\nRESISTANCE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.SIZE",
        "title": "Common Types > Constants > SIZE",
        "section": "Constants > SIZE",
        "text": "SIZE\n\nSIZE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.SPECIFIC_HEAT",
        "title": "Common Types > Constants > SPECIFIC_HEAT",
        "section": "Constants > SPECIFIC_HEAT",
        "text": "SPECIFIC_HEAT\n\nSPECIFIC_HEAT"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.STRAIN",
        "title": "Common Types > Constants > STRAIN",
        "section": "Constants > STRAIN",
        "text": "STRAIN\n\nSTRAIN"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.STRESS",
        "title": "Common Types > Constants > STRESS",
        "section": "Constants > STRESS",
        "text": "STRESS\n\nSTRESS"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.TEMPERATURE",
        "title": "Common Types > Constants > TEMPERATURE",
        "section": "Constants > TEMPERATURE",
        "text": "TEMPERATURE\n\nTEMPERATURE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.THERMAL_CONDUCTIVITY",
        "title": "Common Types > Constants > THERMAL_CONDUCTIVITY",
        "section": "Constants > THERMAL_CONDUCTIVITY",
        "text": "THERMAL_CONDUCTIVITY\n\nTHERMAL_CONDUCTIVITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.THERMAL_RESISTANCE",
        "title": "Common Types > Constants > THERMAL_RESISTANCE",
        "section": "Constants > THERMAL_RESISTANCE",
        "text": "THERMAL_RESISTANCE\n\nTHERMAL_RESISTANCE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.TIME",
        "title": "Common Types > Constants > TIME",
        "section": "Constants > TIME",
        "text": "TIME\n\nTIME"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VELOCITY",
        "title": "Common Types > Constants > VELOCITY",
        "section": "Constants > VELOCITY",
        "text": "VELOCITY\n\nVELOCITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VELOCITY_DENSITY",
        "title": "Common Types > Constants > VELOCITY_DENSITY",
        "section": "Constants > VELOCITY_DENSITY",
        "text": "VELOCITY_DENSITY\n\nVELOCITY_DENSITY"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VOLTAGE",
        "title": "Common Types > Constants > VOLTAGE",
        "section": "Constants > VOLTAGE",
        "text": "VOLTAGE\n\nVOLTAGE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VOLUME",
        "title": "Common Types > Constants > VOLUME",
        "section": "Constants > VOLUME",
        "text": "VOLUME\n\nVOLUME"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.WEIGHT",
        "title": "Common Types > Constants > WEIGHT",
        "section": "Constants > WEIGHT",
        "text": "WEIGHT\n\nWEIGHT"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter",
        "title": "Common Types > Constants > TableDelimiter",
        "section": "Constants > TableDelimiter",
        "text": "class ansys.sherlock.core.types.common_types.TableDelimiter\n\nTypes of delimiters that can be used for exporting tables.\n\n\n\nCOMMA\n\nCOMMA\n\n\n\nSEMICOLON\n\nSEMICOLON\n\n\n\nSPACE\n\nSPACE\n\n\n\nTAB\n\nTAB"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.COMMA",
        "title": "Common Types > Constants > COMMA",
        "section": "Constants > COMMA",
        "text": "COMMA\n\nCOMMA"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.SEMICOLON",
        "title": "Common Types > Constants > SEMICOLON",
        "section": "Constants > SEMICOLON",
        "text": "SEMICOLON\n\nSEMICOLON"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.SPACE",
        "title": "Common Types > Constants > SPACE",
        "section": "Constants > SPACE",
        "text": "SPACE\n\nSPACE"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.TAB",
        "title": "Common Types > Constants > TAB",
        "section": "Constants > TAB",
        "text": "TAB\n\nTAB"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement",
        "title": "Common Types > Constants > Measurement",
        "section": "Constants > Measurement",
        "text": "class ansys.sherlock.core.types.common_types.Measurement(value: float, unit: str)\n\nContains the properties of the measurement.\n\n\n\nunit\n\nmeasurement units\n\nType\n\nstr\n\n\n\nvalue\n\nmeasurement value\n\nType\n\nfloat"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement.unit",
        "title": "Common Types > Constants > unit",
        "section": "Constants > unit",
        "text": "unit\n\nmeasurement units\n\nType\n\nstr"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement.value",
        "title": "Common Types > Constants > value",
        "section": "Constants > value",
        "text": "value\n\nmeasurement value\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file.html#update_test_fixtures_by_file",
        "title": "update_test_fixtures_by_file",
        "section": "update_test_fixtures_by_file",
        "text": "Update test fixture properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nfile_path (str) – Path for the CSV file with the test fixture properties.\nStatus code of the response. 0 for success.\nint\nupdate_test_fixtures_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file.html#ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "title": "update_test_fixtures_by_file > update_test_fixtures_by_file > update_test_fixtures_by_file",
        "section": "update_test_fixtures_by_file > update_test_fixtures_by_file",
        "text": "Layer.update_test_fixtures_by_file(project: str, cca_name: str, file_path: str) -> int\n\nUpdate test fixture properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nfile_path (str) – Path for the CSV file with the test fixture properties.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_test_fixtures_by_file(\n    \"Test\",\n    \"Card\",\n    \"TestFixturesImport.csv\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nmodel_post_init"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init.html#ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PCBShape.model_post_init(_BaseModel__context: Any) -> None\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized."
    },
    {
        "objectID": "api/launcher",
        "href": "api/launcher.html#launcher",
        "title": "Launcher",
        "section": "Launcher",
        "text": "Module for launching Sherlock locally or connecting to a local instance with gRPC.\nlaunch_sherlock([host, port, ...])\nLaunch Sherlock and start gRPC on a given host and port.\nconnect_grpc_channel([port, server_version])\nCreate a gRPC connection to a specified port and return the Sherlock connection object.\nLauncher\nlaunch_sherlock\nconnect_grpc_channel\nSherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj – The object containing string data to validate.\nstrict – Whether to enforce types strictly.\ncontext – Extra variables to pass to the validator.\nThe validated Pydantic model.\nmodel_validate_strings"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CircularShape.model_validate_strings(obj: Any, *, strict: bool | None = None, context: Any | None = None) -> Self\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj – The object containing string data to validate.\n\nstrict – Whether to enforce types strictly.\n\ncontext – Extra variables to pass to the validator.\n\nReturns\n\nThe validated Pydantic model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "DeletePottingRegionRequest.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CopyPottingRegionRequest.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "Usage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude – Field(s) to include in the JSON output.\nexclude – Field(s) to exclude from the JSON output.\ncontext – Additional context to pass to the serializer.\nby_alias – Whether to serialize using field aliases.\nexclude_unset – Whether to exclude fields that have not been explicitly set.\nexclude_defaults – Whether to exclude fields that are set to their default value.\nexclude_none – Whether to exclude fields that have a value of None.\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\nA JSON string representation of the model.\nmodel_dump_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PCBShape.model_dump_json(*, indent: int | None = None, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, context: Any | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -> str\n\nUsage docs: https://docs.pydantic.dev/2.10/concepts/serialization/#modelmodel_dump_json\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude – Field(s) to include in the JSON output.\n\nexclude – Field(s) to exclude from the JSON output.\n\ncontext – Additional context to pass to the serializer.\n\nby_alias – Whether to serialize using field aliases.\n\nexclude_unset – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults – Whether to exclude fields that are set to their default value.\n\nexclude_none – Whether to exclude fields that have a value of None.\n\nround_trip – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nserialize_as_any – Whether to serialize fields with duck-typing serialization behavior.\n\nReturns\n\nA JSON string representation of the model."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "parse_raw"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PolygonalShape.parse_raw(b: str | bytes, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness.html#get_total_conductor_thickness",
        "title": "get_total_conductor_thickness",
        "section": "get_total_conductor_thickness",
        "text": "Return the total conductor thickness.\nAvailable Since: 2021R2\nproject (str) – Sherlock project name.\ncca_name (str) – The CCA name.\nthickness_unit (str, optional) – Units for laminate thickness.\nThe conductor thickness of the CCA in the specified units.\nfloat\nget_total_conductor_thickness"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness.html#ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "title": "get_total_conductor_thickness > get_total_conductor_thickness > get_total_conductor_thickness",
        "section": "get_total_conductor_thickness > get_total_conductor_thickness",
        "text": "Stackup.get_total_conductor_thickness(project: str, cca_name: str, thickness_unit: str) -> float\n\nReturn the total conductor thickness.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Sherlock project name.\n\ncca_name (str) – The CCA name.\n\nthickness_unit (str, optional) – Units for laminate thickness.\n\nReturns\n\nThe conductor thickness of the CCA in the specified units.\n\nReturn type\n\nfloat\n\nExample\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> total_thickness = sherlock.stackup.get_total_conductor_thickness(project=\"Tutorial\",\n                                                         cca_name=\"Main Board\",\n                                                         thickness_unit=\"oz\")\n>>>print(f\"{total_thickness}\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict.html#ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PolygonalShape.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PolygonalShape.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "Name of the cca.\ncca_name"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegionCopyData.cca_name: str\n\nName of the cca."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file.html#update_mount_points_by_file",
        "title": "update_mount_points_by_file",
        "section": "update_mount_points_by_file",
        "text": "Update mount point properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nfile_path (str) – Path for the CSV file with the mount point properties.\nStatus code of the response. 0 for success.\nint\nupdate_mount_points_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file.html#ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "title": "update_mount_points_by_file > update_mount_points_by_file > update_mount_points_by_file",
        "section": "update_mount_points_by_file > update_mount_points_by_file",
        "text": "Layer.update_mount_points_by_file(project: str, cca_name: str, file_path: str) -> int\n\nUpdate mount point properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nfile_path (str) – Path for the CSV file with the mount point properties.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.layer.update_mount_points_by_file(\n    \"Test\",\n    \"Card\",\n    \"MountPointImport.csv\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues – Trusted or pre-validated data dictionary.\nA new instance of the Model class with validated data.\nmodel_construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct.html#ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CircularShape.model_construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues – Trusted or pre-validated data dictionary.\n\nReturns\n\nA new instance of the Model class with validated data."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model.html#export_trace_reinforcement_model",
        "title": "export_trace_reinforcement_model",
        "section": "export_trace_reinforcement_model",
        "text": "Export a trace reinforcement model.\nAvailable Since: 2023R1\nproject_name (str) – Name of the Sherlock project to generate the trace reinforcement model for.\ncca_name (str) – Name of the CCA to generate the trace reinforcement model from.\nexport_file (str) – Path for saving exported files to. The file extension must be .wbjn.\noverwrite (bool, optional) – Whether to overwrite an existing file having the same file name.\nThe default is True.\ndisplay_model (bool, optional) – Whether to launch and display the exported model in Ansys Workbench\nMechanical once the export finishes. The default is False.\ngenerate_models_for_all_layers (bool, optional) – Whether to generate and export trace models for not only the generated trace\nreinforcement layers but also all other layers. The default is False, in\nwhich case only trace reinforcement layers are generated and exported.\ncoordinate_units (str, optional) – Units of the model coordinates to use when exporting a model.\nThe default is \"mm\".\ntrace_param_diameter_threshold_val (float, optional) – Threshold value that determines whether a hole is modeled with shell\nreinforcement elements or beam elements. The default is 2, with the\ndefault units being \"mm\" as specified by the next parameter. Holes with\ndiameters equal to or greater than this threshold value are modeled with shell\nreinforcement elements. Holes with diameters less than this threshold value\nare modeled with beam elements. Holes buried inside the board are always modeled\nwith beam elements.\ntrace_param_diameter_threshold_unit (str, optional) – Units associated with the threshold value for the trace parameter diameter.\nThe default is \"mm\".\ntrace_param_min_hole_diameter_val (float, optional) – Minimum trace parameter diameter for determining whether a via is exported.\nThe default is 0.25, with the default units being \"mm\" as specified\nby the next parameter. Vias with diameters smaller than this diameter\nare not exported. Setting the value to 0 exports all vias.\ntrace_param_min_hole_diameter_unit (str, optional) – Units associated with the value for the minimum trace parameter diameter.\nThe default is \"mm\".\ntrace_drill_hole_modeling (str, optional) – Whether to enable or disable the modeling of trace drill holes. Options are\n\"ENABLED\" and \"DISABLED\". The default is \"DISABLED\", in which\ncase the trace_drill_hole_min_diameter and trace_drill_hole_max_edge\nparameters are not used.\ntrace_drill_hole_min_diameter_val (float, optional) – Minimimun diameter value for determining whether a trace drill hole is\nexported. The default is 2, with the default units being \"mm\"\nas specified by the next parameter. Trace drill holes with diameters smaller\nthan this diameter are not exported. Setting the value to 0 exports all\ntrace drill holes.\ntrace_drill_hole_min_diameter_unit (str, optional) – Units associated with the value for the minimum trace drill hole diameter.\nThe default is \"mm\".\ntrace_drill_hole_max_edge_val (float, optional) – Maximum segment size for representing round drill holes by a polygon.\nThe default is 1, with the default units being \"mm\" as specified\nby the next parameter.\ntrace_drill_hole_max_edge_unit (str, optional) – Units associated with the maximum segment for representing round drill holes\nby a polygon. The default is \"mm\".\nStatus code of the response. 0 for success.\nint\nexport_trace_reinforcement_model\n.wbjn\nTrue\nFalse\nFalse\n\"mm\"\n2\n\"mm\"\n\"mm\"\n0.25\n\"mm\"\n0\n\"mm\"\n\"ENABLED\"\n\"DISABLED\"\n\"DISABLED\"\ntrace_drill_hole_min_diameter\ntrace_drill_hole_max_edge\n2\n\"mm\"\n0\n\"mm\"\n1\n\"mm\"\n\"mm\""
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model.html#ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "title": "export_trace_reinforcement_model > export_trace_reinforcement_model > export_trace_reinforcement_model",
        "section": "export_trace_reinforcement_model > export_trace_reinforcement_model",
        "text": "Model.export_trace_reinforcement_model(project_name: str, cca_name: str, export_file: str, overwrite: bool = True, display_model: bool = False, generate_models_for_all_layers: bool = False, coordinate_units: str = 'mm', trace_param_diameter_threshold_val: float = 2, trace_param_diameter_threshold_unit: str = 'mm', trace_param_min_hole_diameter_val: float = 0.25, trace_param_min_hole_diameter_unit: str = 'mm', trace_drill_hole_modeling: str = 'DISABLED', trace_drill_hole_min_diameter_val: float = 2, trace_drill_hole_min_diameter_unit: str = 'mm', trace_drill_hole_max_edge_val: float = 1, trace_drill_hole_max_edge_unit: str = 'mm') -> int\n\nExport a trace reinforcement model.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject_name (str) – Name of the Sherlock project to generate the trace reinforcement model for.\n\ncca_name (str) – Name of the CCA to generate the trace reinforcement model from.\n\nexport_file (str) – Path for saving exported files to. The file extension must be .wbjn.\n\noverwrite (bool, optional) – Whether to overwrite an existing file having the same file name.\nThe default is True.\n\ndisplay_model (bool, optional) – Whether to launch and display the exported model in Ansys Workbench\nMechanical once the export finishes. The default is False.\n\ngenerate_models_for_all_layers (bool, optional) – Whether to generate and export trace models for not only the generated trace\nreinforcement layers but also all other layers. The default is False, in\nwhich case only trace reinforcement layers are generated and exported.\n\ncoordinate_units (str, optional) – Units of the model coordinates to use when exporting a model.\nThe default is \"mm\".\n\ntrace_param_diameter_threshold_val (float, optional) – Threshold value that determines whether a hole is modeled with shell\nreinforcement elements or beam elements. The default is 2, with the\ndefault units being \"mm\" as specified by the next parameter. Holes with\ndiameters equal to or greater than this threshold value are modeled with shell\nreinforcement elements. Holes with diameters less than this threshold value\nare modeled with beam elements. Holes buried inside the board are always modeled\nwith beam elements.\n\ntrace_param_diameter_threshold_unit (str, optional) – Units associated with the threshold value for the trace parameter diameter.\nThe default is \"mm\".\n\ntrace_param_min_hole_diameter_val (float, optional) – Minimum trace parameter diameter for determining whether a via is exported.\nThe default is 0.25, with the default units being \"mm\" as specified\nby the next parameter. Vias with diameters smaller than this diameter\nare not exported. Setting the value to 0 exports all vias.\n\ntrace_param_min_hole_diameter_unit (str, optional) – Units associated with the value for the minimum trace parameter diameter.\nThe default is \"mm\".\n\ntrace_drill_hole_modeling (str, optional) – Whether to enable or disable the modeling of trace drill holes. Options are\n\"ENABLED\" and \"DISABLED\". The default is \"DISABLED\", in which\ncase the trace_drill_hole_min_diameter and trace_drill_hole_max_edge\nparameters are not used.\n\ntrace_drill_hole_min_diameter_val (float, optional) – Minimimun diameter value for determining whether a trace drill hole is\nexported. The default is 2, with the default units being \"mm\"\nas specified by the next parameter. Trace drill holes with diameters smaller\nthan this diameter are not exported. Setting the value to 0 exports all\ntrace drill holes.\n\ntrace_drill_hole_min_diameter_unit (str, optional) – Units associated with the value for the minimum trace drill hole diameter.\nThe default is \"mm\".\n\ntrace_drill_hole_max_edge_val (float, optional) – Maximum segment size for representing round drill holes by a polygon.\nThe default is 1, with the default units being \"mm\" as specified\nby the next parameter.\n\ntrace_drill_hole_max_edge_unit (str, optional) – Units associated with the maximum segment for representing round drill holes\nby a polygon. The default is \"mm\".\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_trace_reinforcement_model(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.wbjn',\n    True, False, False)\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_trace_reinforcement_model(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.wbjn',\n    True, False, False, \"mm\", 1.5, \"mm\", 0, \"mm\", \"ENABLED\", 1.5, \"mm\", 1, \"mm\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PolygonalShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "dict"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "DeletePottingRegionRequest.dict(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Dict[str, Any]\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionDeleteData.model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]] = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PCBShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation.html#ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "CircularShape.rotation: float\n\nfloat\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region.html#potting_region",
        "title": "potting_region",
        "section": "potting_region",
        "text": "Potting region data used to update the potting region.\npotting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "title": "potting_region > potting_region > potting_region",
        "section": "potting_region > potting_region",
        "text": "PottingRegionUpdateData.potting_region: PottingRegion\n\nPotting region data used to update the potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "construct"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct.html#ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PCBShape.construct(_fields_set: set[str] | None = None, **values: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project.html#delete_project",
        "title": "delete_project",
        "section": "delete_project",
        "text": "Delete a Sherlock project.\nAvailable Since: 2022R2\nproject (str) – Name of the Sherlock project.\nStatus code of the response. 0 for success.\nint\ndelete_project"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project.html#ansys.sherlock.core.project.Project.delete_project",
        "title": "delete_project > delete_project > delete_project",
        "section": "delete_project > delete_project",
        "text": "Project.delete_project(project: str) -> int\n\nDelete a Sherlock project.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.delete_project(\"Test Project\")"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "from_orm"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm.html#ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod SlotShape.from_orm(obj: Any) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list.html#export_parts_list",
        "title": "export_parts_list",
        "section": "export_parts_list",
        "text": "Export a parts list for a CCA.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nexport_file (str) – Full path for the CSV file to export the parts list to.\nStatus code of the response. 0 for success.\nint\nexport_parts_list"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list.html#ansys.sherlock.core.parts.Parts.export_parts_list",
        "title": "export_parts_list > export_parts_list > export_parts_list",
        "section": "export_parts_list > export_parts_list",
        "text": "Parts.export_parts_list(project: str, cca_name: str, export_file: str) -> int\n\nExport a parts list for a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nexport_file (str) – Full path for the CSV file to export the parts list to.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.export_parts_list(\n    \"Test\",\n    \"Card\",\n    \"Parts List.csv\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties.html#update_parts_list_properties",
        "title": "update_parts_list_properties",
        "section": "update_parts_list_properties",
        "text": "Update one or more properties of one or more parts in a parts list.\nAvailable Since: 2024R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\npart_properties (list[dict[str, list[str] | list[dict[str, str]]]]) – Part properties consisting of these properties:reference_designators: list[str], optional\n\nReference designator for each part to be updated. If not included,\nupdate properties for all parts in the CCA.\n\nproperties: list[dict[str, str]]\n\nPart properties consisting of these properties:\n\nname: str\n\nName of property to be updated.\n\nvalue: str\n\nValue to be applied to the chosen part property.\nPart properties consisting of these properties:\nReference designator for each part to be updated. If not included,\nupdate properties for all parts in the CCA.\nPart properties consisting of these properties:\nName of property to be updated.\nValue to be applied to the chosen part property.\nStatus code of the response. 0 for success.\nint\nupdate_parts_list_properties"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties.html#ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "title": "update_parts_list_properties > update_parts_list_properties > update_parts_list_properties",
        "section": "update_parts_list_properties > update_parts_list_properties",
        "text": "Parts.update_parts_list_properties(project: str, cca_name: str, part_properties: list[dict[str, list[dict[str, str]] | list[str]]]) -> int\n\nUpdate one or more properties of one or more parts in a parts list.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\npart_properties (list[dict[str, list[str] | list[dict[str, str]]]]) – Part properties consisting of these properties:reference_designators: list[str], optional\n\nReference designator for each part to be updated. If not included,\nupdate properties for all parts in the CCA.\n\nproperties: list[dict[str, str]]\n\nPart properties consisting of these properties:\n\nname: str\n\nName of property to be updated.\n\nvalue: str\n\nValue to be applied to the chosen part property.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.parts.update_parts_list_properties(\n        \"Test\",\n        \"Card\",\n        [\n            {\n                \"reference_designators\": [\"C1\"],\n                \"properties\": [\n                    {\"name\": \"partType\", \"value\": \"RESISTOR\"}\n                ]\n            },\n            {\n                \"reference_designators\": [\"C2\"],\n                \"properties\": [\n                    {\"name\": \"locX\", \"value\": \"1\"}\n                ]\n            }\n        ]\n    )"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup.html#gen_stackup",
        "title": "gen_stackup",
        "section": "gen_stackup",
        "text": "Generate a new stackup from given properties.\nAvailable Since: 2021R2\nproject (str) – Name of the Sherlock project.\ncca_name (str) – Name of the CCA.\nboard_thickness (float) – Board thickness.\nboard_thickness_unit (str) – Units for the board thickness.\npcb_material_manufacturer (str) – Manufacturer for the PCB material.\npcb_material_grade (str) – Grade for the PCB material.\npcb_material (str) – Material for the PCB.\nconductor_layers_cnt (int32) – Number of conductor layers.\nsignal_layer_thickness (float) – Signal layer thickness.\nsignal_layer_thickness_unit (str) – Units for the signal layer thickness.\nmin_laminate_thickness (float) – Minimum thickness of laminate layers.\nmin_laminate_thickness_unit (str) – Units for the minimum thickness of laminate layers.\nmaintain_symmetry (bool) – Whether to maintain symmetry.\npower_layer_thickness (float) – Power layer thickness.\npower_layer_thickness_unit (str) – Units for the power layer thickness.\nStatus code of the response. 0 for success.\nint\ngen_stackup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup.html#ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "title": "gen_stackup > gen_stackup > gen_stackup",
        "section": "gen_stackup > gen_stackup",
        "text": "Stackup.gen_stackup(project: str, cca_name: str, board_thickness: float, board_thickness_unit: str, pcb_material_manufacturer: str, pcb_material_grade: str, pcb_material: str, conductor_layers_cnt: int, signal_layer_thickness: float, signal_layer_thickness_unit: str, min_laminate_thickness: float, min_laminate_thickness_unit: str, maintain_symmetry: bool, power_layer_thickness: float, power_layer_thickness_unit: str) -> int\n\nGenerate a new stackup from given properties.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject (str) – Name of the Sherlock project.\n\ncca_name (str) – Name of the CCA.\n\nboard_thickness (float) – Board thickness.\n\nboard_thickness_unit (str) – Units for the board thickness.\n\npcb_material_manufacturer (str) – Manufacturer for the PCB material.\n\npcb_material_grade (str) – Grade for the PCB material.\n\npcb_material (str) – Material for the PCB.\n\nconductor_layers_cnt (int32) – Number of conductor layers.\n\nsignal_layer_thickness (float) – Signal layer thickness.\n\nsignal_layer_thickness_unit (str) – Units for the signal layer thickness.\n\nmin_laminate_thickness (float) – Minimum thickness of laminate layers.\n\nmin_laminate_thickness_unit (str) – Units for the minimum thickness of laminate layers.\n\nmaintain_symmetry (bool) – Whether to maintain symmetry.\n\npower_layer_thickness (float) – Power layer thickness.\n\npower_layer_thickness_unit (str) – Units for the power layer thickness.\n\nReturns\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.gen_stackup(\n    \"Test\",\n    \"Card\",\n    82.6,\n    \"mil\",\n    \"Generic\",\n    \"FR-4\",\n    \"Generic FR-4\",\n    6,\n    0.5,\n    \"oz\",\n    1.0,\n    \"mil\",\n    False,\n    1.0,\n    \"mil\"\n)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields.html#ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "SlotShape.model_fields: ClassVar[dict[str, FieldInfo]] = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'length': FieldInfo(annotation=float, required=True), 'node_count': FieldInfo(annotation=int, required=True), 'rotation': FieldInfo(annotation=float, required=True), 'width': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width.html#width",
        "title": "width",
        "section": "width",
        "text": "float\nwidth\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width.html#ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "RectangularShape.width: float\n\nfloat\n\nType\n\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json.html#ansys.sherlock.core.types.layer_types.PCBShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PCBShape.json(*, include: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, exclude: Set[int] | Set[str] | Mapping[int, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | Mapping[str, Set[int] | Set[str] | Mapping[int, IncEx | bool] | Mapping[str, IncEx | bool] | bool] | None = None, by_alias: bool = False, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, encoder: Callable[[Any], Any] | None = PydanticUndefined, models_as_dict: bool = PydanticUndefined, **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionDeleteData.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields.html#get_mechanical_shock_input_fields",
        "title": "get_mechanical_shock_input_fields",
        "section": "get_mechanical_shock_input_fields",
        "text": "Get mechanical shock property fields based on the user configuration.\nAvailable Since: 2024R1\nmodel_source (ModelSource, optional) – Model source to get the random vibe property fields from.\nOnly GENERATED is supported.\nDefault is None.\nMechanical shock property fields based on the user configuration.\nlist[str]\nget_mechanical_shock_input_fields\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "title": "get_mechanical_shock_input_fields > get_mechanical_shock_input_fields > get_mechanical_shock_input_fields",
        "section": "get_mechanical_shock_input_fields > get_mechanical_shock_input_fields",
        "text": "Analysis.get_mechanical_shock_input_fields(model_source: ModelSource | None = None) -> list[str]\n\nGet mechanical shock property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nParameters\n\nmodel_source (ModelSource, optional) – Model source to get the random vibe property fields from.\nOnly GENERATED is supported.\nDefault is None.\n\nReturns\n\nMechanical shock property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_mechanical_shock_input_fields(ModelSource.GENERATED)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy.html#ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "RectangularShape.copy(*, include: AbstractSetIntStr | MappingIntStrAny | None = None, exclude: AbstractSetIntStr | MappingIntStrAny | None = None, update: Dict[str, Any] | None = None, deep: bool = False) -> Self\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units.html#potting_units",
        "title": "potting_units",
        "section": "potting_units",
        "text": "The units to use for the potting region.\npotting_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "title": "potting_units > potting_units > potting_units",
        "section": "potting_units > potting_units",
        "text": "PottingRegion.potting_units: str\n\nThe units to use for the potting region."
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "parse_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod SlotShape.parse_file(path: str | Path, *, content_type: str | None = None, encoding: str = 'utf8', proto: DeprecatedParseProtocol | None = None, allow_pickle: bool = False) -> Self\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "schema_json"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CopyPottingRegionRequest.schema_json(*, by_alias: bool = True, ref_template: str = '#/$defs/{model}', **dumps_kwargs: Any) -> str\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionUpdateData.model_fields: ClassVar[dict[str, FieldInfo]] = {'potting_region': FieldInfo(annotation=PottingRegion, required=True), 'potting_region_id_to_update': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/parts",
        "href": "api/parts.html#parts",
        "title": "Parts",
        "section": "Parts",
        "text": "Module containing all parts management capabilities.\nParts(channel, server_version)\nContains all parts management capabilities.\nParts\nParts"
    }
]