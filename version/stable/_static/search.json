[
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width.html#width",
        "title": "width",
        "section": "width",
        "text": "float\nwidth\nwidth\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.width.html#ansys.sherlock.core.types.layer_types.SlotShape.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "SlotShape.width: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length.html#length",
        "title": "length",
        "section": "length",
        "text": "float\nlength\nlength\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.length.html#ansys.sherlock.core.types.layer_types.SlotShape.length",
        "title": "length > length > length",
        "section": "length > length",
        "text": "SlotShape.length: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x.html#legend_x",
        "title": "legend_x",
        "section": "legend_x",
        "text": "x coordinate of the upper left corner\nfloat\nlegend_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_x.html#ansys.sherlock.core.types.project_types.LegendBounds.legend_x",
        "title": "legend_x > legend_x > legend_x",
        "section": "legend_x > legend_x",
        "text": "LegendBounds.legend_x\n\nx coordinate of the upper left corner\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file.html#update_mount_points_by_file",
        "title": "update_mount_points_by_file",
        "section": "update_mount_points_by_file",
        "text": "Update mount point properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nPath for the CSV file with the mount point properties.\nStatus code of the response. 0 for success.\nint\nupdate_mount_points_by_file\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_mount_points_by_file.html#ansys.sherlock.core.layer.Layer.update_mount_points_by_file",
        "title": "update_mount_points_by_file > update_mount_points_by_file > update_mount_points_by_file",
        "section": "update_mount_points_by_file > update_mount_points_by_file",
        "text": "Layer.update_mount_points_by_file(project, cca_name, file_path)\n\nUpdate mount point properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nfile_path: str\n\nPath for the CSV file with the mount point properties.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_mount_points_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"MountPointImport.csv\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.update_forward_refs.html#ansys.sherlock.core.types.project_types.OutlineFile.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod OutlineFile.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod RectangularShape.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/launcher",
        "href": "api/launcher.html#launcher",
        "title": "Launcher",
        "section": "Launcher",
        "text": "Module for launching Sherlock locally or connecting to a local instance with gRPC.\nlaunch_and_connect([host, port, ...])\nLaunch Sherlock, start gRPC on a given host and port, and wait until connected to Sherlock.\nlaunch([host, port, single_project_path, ...])\nLaunch Sherlock using the specified host and port for the gRPC connection.\nconnect([port, timeout])\nConnect to a local instance of Sherlock.\nlaunch_sherlock([host, port, ...])\nLaunch Sherlock and start gRPC on a given host and port.\nLauncher\nlaunch_and_connect\nlaunch\nconnect\nlaunch_sherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.y_location_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.y_location_column.html#y_location_column",
        "title": "y_location_column",
        "section": "y_location_column",
        "text": "Y location column name\ny_location_column\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.y_location_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.y_location_column.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.y_location_column",
        "title": "y_location_column > y_location_column > y_location_column",
        "section": "y_location_column > y_location_column",
        "text": "CsvExcelOutlineFile.y_location_column: str\n\nY location column name\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/lifecycle",
        "href": "api/lifecycle.html#lifecycle",
        "title": "Lifecycle",
        "section": "Lifecycle",
        "text": "Module containing all life cycle management capabilities.\nLifecycle(channel, server_version)\nContains all life cycle management capabilities.\nLifecycle\nLifecycle"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.html#ansyssherlockcoretypeslayer_typesdeletepottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "text": "Request to delete 1 or more potting regions.\nDeletePottingRegionRequest.construct([...])\n\nDeletePottingRegionRequest.copy(*[, ...])\nReturns a copy of the model.\nDeletePottingRegionRequest.dict(*[, ...])\n\nDeletePottingRegionRequest.from_orm(obj)\n\nDeletePottingRegionRequest.json(*[, ...])\n\nDeletePottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nDeletePottingRegionRequest.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nDeletePottingRegionRequest.model_dump(*[, ...])\n!!! abstract \"Usage Documentation\"\nDeletePottingRegionRequest.model_dump_json(*)\n!!! abstract \"Usage Documentation\"\nDeletePottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nDeletePottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nDeletePottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nDeletePottingRegionRequest.model_rebuild(*)\nTry to rebuild the pydantic-core schema for the model.\nDeletePottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nDeletePottingRegionRequest.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nDeletePottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nDeletePottingRegionRequest.parse_file(path, *)\n\nDeletePottingRegionRequest.parse_obj(obj)\n\nDeletePottingRegionRequest.parse_raw(b, *[, ...])\n\nDeletePottingRegionRequest.schema([...])\n\nDeletePottingRegionRequest.schema_json(*[, ...])\n\nDeletePottingRegionRequest.str_validation(...)\nValidate string fields listed.\nDeletePottingRegionRequest.update_forward_refs(...)\n\nDeletePottingRegionRequest.validate(value)\n\nDeletePottingRegionRequest.model_computed_fields\n\nDeletePottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nDeletePottingRegionRequest.model_extra\nGet extra fields set during validation.\nDeletePottingRegionRequest.model_fields\n\nDeletePottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nDeletePottingRegionRequest.project\nName of the project containing the potting regions to delete.\nDeletePottingRegionRequest.potting_region_delete_data\nData identifying which potting regions should be deleted.\nansys.sherlock.core.types.layer_types.DeletePottingRegionRequest\nDeletePottingRegionRequest.construct\nDeletePottingRegionRequest.copy\nDeletePottingRegionRequest.dict\nDeletePottingRegionRequest.from_orm\nDeletePottingRegionRequest.json\nDeletePottingRegionRequest.model_construct\nDeletePottingRegionRequest.model_copy\nDeletePottingRegionRequest.model_dump\nDeletePottingRegionRequest.model_dump_json\nDeletePottingRegionRequest.model_json_schema\nDeletePottingRegionRequest.model_parametrized_name\nDeletePottingRegionRequest.model_post_init\nDeletePottingRegionRequest.model_rebuild\nDeletePottingRegionRequest.model_validate\nDeletePottingRegionRequest.model_validate_json\nDeletePottingRegionRequest.model_validate_strings\nDeletePottingRegionRequest.parse_file\nDeletePottingRegionRequest.parse_obj\nDeletePottingRegionRequest.parse_raw\nDeletePottingRegionRequest.schema\nDeletePottingRegionRequest.schema_json\nDeletePottingRegionRequest.str_validation\nDeletePottingRegionRequest.update_forward_refs\nDeletePottingRegionRequest.validate\nDeletePottingRegionRequest.model_computed_fields\nDeletePottingRegionRequest.model_config\nDeletePottingRegionRequest.model_extra\nDeletePottingRegionRequest.model_fields\nDeletePottingRegionRequest.model_fields_set\nDeletePottingRegionRequest.project\nDeletePottingRegionRequest.potting_region_delete_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > DeletePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest > DeletePottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest(**data)\n\nRequest to delete 1 or more potting regions.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nDeletePottingRegionRequest.construct([...])\n\n\n\nDeletePottingRegionRequest.copy(*[, ...])\n\nReturns a copy of the model.\n\nDeletePottingRegionRequest.dict(*[, ...])\n\n\n\nDeletePottingRegionRequest.from_orm(obj)\n\n\n\nDeletePottingRegionRequest.json(*[, ...])\n\n\n\nDeletePottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nDeletePottingRegionRequest.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDeletePottingRegionRequest.model_dump(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nDeletePottingRegionRequest.model_dump_json(*)\n\n!!! abstract \"Usage Documentation\"\n\nDeletePottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nDeletePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nDeletePottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nDeletePottingRegionRequest.model_rebuild(*)\n\nTry to rebuild the pydantic-core schema for the model.\n\nDeletePottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nDeletePottingRegionRequest.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nDeletePottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nDeletePottingRegionRequest.parse_file(path, *)\n\n\n\nDeletePottingRegionRequest.parse_obj(obj)\n\n\n\nDeletePottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nDeletePottingRegionRequest.schema([...])\n\n\n\nDeletePottingRegionRequest.schema_json(*[, ...])\n\n\n\nDeletePottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nDeletePottingRegionRequest.update_forward_refs(...)\n\n\n\nDeletePottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nDeletePottingRegionRequest.model_computed_fields\n\n\n\nDeletePottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nDeletePottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nDeletePottingRegionRequest.model_fields\n\n\n\nDeletePottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nDeletePottingRegionRequest.project\n\nName of the project containing the potting regions to delete.\n\nDeletePottingRegionRequest.potting_region_delete_data\n\nData identifying which potting regions should be deleted.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_raw.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CsvExcelOutlineFile.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.copy.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "GerberOutlineFile.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.PCBShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PCBShape.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#add-modeling-regions-for-pcb-analysis",
        "title": "Add Modeling Regions for PCB Analysis",
        "section": "Add Modeling Regions for PCB Analysis",
        "text": "This example demonstrates how to use the Sherlock gRPC service to:\n- Import a project.\n- Add modeling regions to a PCB model.\n- Define different region shapes like polygonal, rectangular, circular, and slot shapes.\n- Configure PCB and trace model properties for simulation.\nAdd Modeling Regions for PCB Analysis"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#description",
        "title": "Add Modeling Regions for PCB Analysis > Description",
        "section": "Description",
        "text": "Connect to the Sherlock gRPC service, import a project,\nand create modeling regions with different shapes for a PCB analysis. The script\nshows how to configure the modeling region shapes, PCB modeling properties, and trace\nmodeling properties for each region.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#connect-to-sherlock",
        "title": "Add Modeling Regions for PCB Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#delete-project",
        "title": "Add Modeling Regions for PCB Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#import-tutorial-project",
        "title": "Add Modeling Regions for PCB Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_modeling_region",
        "href": "examples/gallery_examples/01-project-configuration/add_modeling_region.html#create-modeling-regions",
        "title": "Add Modeling Regions for PCB Analysis > Create Modeling Regions",
        "section": "Create Modeling Regions",
        "text": "Define different shapes (polygonal, rectangular, circular, and slot) for modeling regions.\nDownload Jupyter notebook: add_modeling_region.ipynb\nDownload Python source code: add_modeling_region.py\nDownload zipped: add_modeling_region.zip\nCreate Modeling Regions\nDownload Jupyter notebook: add_modeling_region.ipynb\nDownload Python source code: add_modeling_region.py\nDownload zipped: add_modeling_region.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PCBShape.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "RectangularShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionCopyData.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading.html#is_sherlock_client_loading",
        "title": "is_sherlock_client_loading",
        "section": "is_sherlock_client_loading",
        "text": "Check if the Sherlock client is opened and done initializing.\nAvailable Since: 2023R2\nWhether the Sherlock client is opened and done initializing.\nbool\nis_sherlock_client_loading\nbool"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.is_sherlock_client_loading.html#ansys.sherlock.core.common.Common.is_sherlock_client_loading",
        "title": "is_sherlock_client_loading > is_sherlock_client_loading > is_sherlock_client_loading",
        "section": "is_sherlock_client_loading > is_sherlock_client_loading",
        "text": "Common.is_sherlock_client_loading()\n\nCheck if the Sherlock client is opened and done initializing.\n\nAvailable Since: 2023R2\n\nReturns\n\n:\n\n\n\nbool\n\nWhether the Sherlock client is opened and done initializing.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_copy.html#ansys.sherlock.core.types.layer_types.PCBShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PCBShape.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.from_orm.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CsvExcelOutlineFile.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_rebuild.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CsvExcelOutlineFile.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.dict.html#ansys.sherlock.core.types.layer_types.CircularShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CircularShape.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "Name of the CCA containing the potting region(s) to delete.\ncca_name\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegionDeleteData.cca_name: str\n\nName of the CCA containing the potting region(s) to delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CopyPottingRegionRequest.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.html#ansyssherlockcoreprojectproject",
        "title": "ansys.sherlock.core.project.Project",
        "section": "ansys.sherlock.core.project.Project",
        "text": "Contains all project management capabilities.\nProject.add_cca(project, cca_properties)\nAdd one or more CCAs to a project.\nProject.add_outline_file(request)\nAdd outline files to a Sherlock project.\nProject.add_project(project_name, ...)\nAdd a sherlock project to sherlock.\nProject.add_strain_maps(project, strain_maps)\nAdd strain map files to CCAs in a Sherlock project.\nProject.add_thermal_maps(project, ...)\nAdd thermal map files to a Sherlock project.\nProject.create_cca_from_modeling_region(...)\nCreate one or more CCAs from modeling regions in a given project.\nProject.delete_project(project)\nDelete a Sherlock project.\nProject.export_project(project_name, ...)\nExport a sherlock project.\nProject.generate_project_report(project, ...)\nGenerate a project report.\nProject.import_GDSII_file(request)\nImport a GDSII project file and any optional config files.\nProject.import_ipc2581_archive(archive_file, ...)\nImport an IPC-2581 archive file.\nProject.import_odb_archive(archive_file, ...)\nImport an ODB++ archive file.\nProject.import_project_zip_archive(project, ...)\nImport a zipped project archive -- multiple project mode.\nProject.import_project_zip_archive_single_mode(...)\nImport a zipped project archive -- single project mode.\nProject.list_ccas(project[, cca_names])\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\nProject.list_strain_maps(project[, cca_names])\nList the strain maps assigned to each CCA or given CCAs.\nProject.list_thermal_maps(project[, cca_names])\nList the thermal map files and their type assigned to each CCA of given CCAs.\nProject.update_thermal_maps(project, ...)\nUpdate thermal map files to a Sherlock project.\nansys.sherlock.core.project.Project\nProject.add_cca\nProject.add_outline_file\nProject.add_project\nProject.add_strain_maps\nProject.add_thermal_maps\nProject.create_cca_from_modeling_region\nProject.delete_project\nProject.export_project\nProject.generate_project_report\nProject.import_GDSII_file\nProject.import_ipc2581_archive\nProject.import_odb_archive\nProject.import_project_zip_archive\nProject.import_project_zip_archive_single_mode\nProject.list_ccas\nProject.list_strain_maps\nProject.list_thermal_maps\nProject.update_thermal_maps"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.html#ansys.sherlock.core.project.Project",
        "title": "ansys.sherlock.core.project.Project > ansys.sherlock.core.project.Project > Project",
        "section": "ansys.sherlock.core.project.Project > Project",
        "text": "class ansys.sherlock.core.project.Project(channel, server_version)\n\nContains all project management capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nProject.add_cca(project, cca_properties)\n\nAdd one or more CCAs to a project.\n\nProject.add_outline_file(request)\n\nAdd outline files to a Sherlock project.\n\nProject.add_project(project_name, ...)\n\nAdd a sherlock project to sherlock.\n\nProject.add_strain_maps(project, strain_maps)\n\nAdd strain map files to CCAs in a Sherlock project.\n\nProject.add_thermal_maps(project, ...)\n\nAdd thermal map files to a Sherlock project.\n\nProject.create_cca_from_modeling_region(...)\n\nCreate one or more CCAs from modeling regions in a given project.\n\nProject.delete_project(project)\n\nDelete a Sherlock project.\n\nProject.export_project(project_name, ...)\n\nExport a sherlock project.\n\nProject.generate_project_report(project, ...)\n\nGenerate a project report.\n\nProject.import_GDSII_file(request)\n\nImport a GDSII project file and any optional config files.\n\nProject.import_ipc2581_archive(archive_file, ...)\n\nImport an IPC-2581 archive file.\n\nProject.import_odb_archive(archive_file, ...)\n\nImport an ODB++ archive file.\n\nProject.import_project_zip_archive(project, ...)\n\nImport a zipped project archive -- multiple project mode.\n\nProject.import_project_zip_archive_single_mode(...)\n\nImport a zipped project archive -- single project mode.\n\nProject.list_ccas(project[, cca_names])\n\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\n\nProject.list_strain_maps(project[, cca_names])\n\nList the strain maps assigned to each CCA or given CCAs.\n\nProject.list_thermal_maps(project[, cca_names])\n\nList the thermal map files and their type assigned to each CCA of given CCAs.\n\nProject.update_thermal_maps(project, ...)\n\nUpdate thermal map files to a Sherlock project.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionUpdateData.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points.html#delete_all_test_points",
        "title": "delete_all_test_points",
        "section": "delete_all_test_points",
        "text": "Delete all test points for a CCA.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_test_points\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_test_points.html#ansys.sherlock.core.layer.Layer.delete_all_test_points",
        "title": "delete_all_test_points > delete_all_test_points > delete_all_test_points",
        "section": "delete_all_test_points > delete_all_test_points",
        "text": "Layer.delete_all_test_points(project, cca_name)\n\nDelete all test points for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_test_points_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"TestPointsImport.csv\",\n>>> )\n>>> sherlock.layer.delete_all_test_points(\"Test\", \"Card\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionCopyData.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod UpdatePottingRegionRequest.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod UpdatePottingRegionRequest.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CopyPottingRegionRequest.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#update-and-export-parts-list-properties",
        "title": "Update and Export Parts List Properties",
        "section": "Update and Export Parts List Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nupdate the parts list properties, export the parts list, and properly close the connection.\nUpdate and Export Parts List Properties"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#description",
        "title": "Update and Export Parts List Properties > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating the\nparts list properties and exporting the parts list for printed circuit boards (PCBs).\nThis script demonstrates how to:\n- Launch the Sherlock service.\n- Import a project.\n- Update the parts list properties.\nThe updated properties and exported list ensure consistency and provide\ndocumentation for further use.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#connect-to-sherlock",
        "title": "Update and Export Parts List Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#delete-project",
        "title": "Update and Export Parts List Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#import-tutorial-project",
        "title": "Update and Export Parts List Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list_properties.html#update-parts-list-properties",
        "title": "Update and Export Parts List Properties > Update Parts List Properties",
        "section": "Update Parts List Properties",
        "text": "Update the parts list properties for the “Card” of the “Test” project.\nDownload Jupyter notebook: update_parts_list_properties.ipynb\nDownload Python source code: update_parts_list_properties.py\nDownload zipped: update_parts_list_properties.zip\nUpdate Parts List Properties\nDownload Jupyter notebook: update_parts_list_properties.ipynb\nDownload Python source code: update_parts_list_properties.py\nDownload zipped: update_parts_list_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data.html#potting_region_delete_data",
        "title": "potting_region_delete_data",
        "section": "potting_region_delete_data",
        "text": "Data identifying which potting regions should be deleted.\npotting_region_delete_data\nlist\nPottingRegionDeleteData"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.potting_region_delete_data",
        "title": "potting_region_delete_data > potting_region_delete_data > potting_region_delete_data",
        "section": "potting_region_delete_data > potting_region_delete_data",
        "text": "DeletePottingRegionRequest.potting_region_delete_data: list[PottingRegionDeleteData]\n\nData identifying which potting regions should be deleted.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis.html#run_strain_map_analysis",
        "title": "run_strain_map_analysis",
        "section": "run_strain_map_analysis",
        "text": "Run one or more strain map analyses.\nAvailable Since: 2023R2\nName of the Sherlock project.\nName of the main CCA for the analysis.\nAnalyses consisting of these properties:\nType of analysis to run.\nStrain maps assigned to the desired life cycle events for\na given PCB side. The list consists of these properties:\nLife cycle phase name for the strain map assignment.\nLife cycle event name for the strain map assignment.\nPCB side for the strain map. Options are \"TOP\" and \"BOTTOM\".\nName of the strain map assigned to the life cycle event.\nName of the subassembly CCA to assign the strain map to.\nStatus code of the response. 0 for success.\nint\nrun_strain_map_analysis\n\"TOP\"\n\"BOTTOM\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis.html#ansys.sherlock.core.analysis.Analysis.run_strain_map_analysis",
        "title": "run_strain_map_analysis > run_strain_map_analysis > run_strain_map_analysis",
        "section": "run_strain_map_analysis > run_strain_map_analysis",
        "text": "Analysis.run_strain_map_analysis(project, cca_name, strain_map_analyses)\n\nRun one or more strain map analyses.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the main CCA for the analysis.\n\nstrain_map_analyses: list[list[RunStrainMapAnalysisRequestAnalysisType | list[list[str]]]]\n\nAnalyses consisting of these properties:\n\nanalysis_type: RunStrainMapAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent_strain_maps: list\n\nStrain maps assigned to the desired life cycle events for\na given PCB side. The list consists of these properties:\n\nphase_name: str\n\nLife cycle phase name for the strain map assignment.\n\nevent_name: str\n\nLife cycle event name for the strain map assignment.\n\npcb_side: str\n\nPCB side for the strain map. Options are \"TOP\" and \"BOTTOM\".\n\nstrain_map: str\n\nName of the strain map assigned to the life cycle event.\n\nsub_assembly_name: str, optional\n\nName of the subassembly CCA to assign the strain map to.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.analysis_types import (\n>>>     RunStrainMapAnalysisRequestAnalysisType\n>>> )\n>>> sherlock = launch_sherlock()\n>>> analysis_request = SherlockAnalysisService_pb2.RunStrainMapAnalysisRequest\n>>> sherlock.analysis.run_strain_map_analysis(\n        \"AssemblyTutorial\",\n        \"Main Board\",\n        [[\n            RunStrainMapAnalysisRequestAnalysisType.RANDOM_VIBE,\n            [[\"Phase 1\", \"Random Vibe\", \"TOP\", \"MainBoardStrain - Top\"],\n             [\"Phase 1\", \"Random Vibe\", \"BOTTOM\", \"MainBoardStrain - Bottom\"],\n             [\"Phase 1\", \"Random Vibe\", \"TOP\", \"MemoryCard1Strain\", \"Memory Card 1\"]],\n        ]]\n    )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset.html#load_shock_profile_dataset",
        "title": "load_shock_profile_dataset",
        "section": "load_shock_profile_dataset",
        "text": "Load shock profile dataset from a .csv or .dat file.\nAvailable Since: 2021R1\nName of the Sherlock project\nName of the lifecycle phase to add this event to.\nName of the random vibe event.\nFile path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_shock_profile_dataset\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset.html#ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_dataset",
        "title": "load_shock_profile_dataset > load_shock_profile_dataset > load_shock_profile_dataset",
        "section": "load_shock_profile_dataset > load_shock_profile_dataset",
        "text": "Lifecycle.load_shock_profile_dataset(project, phase_name, event_name, file_path)\n\nLoad shock profile dataset from a .csv or .dat file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nphase_name: str\n\nName of the lifecycle phase to add this event to.\n\nevent_name: str\n\nName of the random vibe event.\n\nfile_path: str\n\nFile path for thermal profile .dat or .csv file\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis.html#run_analysis",
        "title": "run_analysis",
        "section": "run_analysis",
        "text": "Run one or more Sherlock analyses.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the CCA.\nTuples (type, event)\nType of analysis to run.\nTuples (phase_name, event_name)\nName of the life cycle phase.\nName of the life cycle event.\nStatus code of the response. 0 for success.\nint\nrun_analysis\ntype\nevent\nphase_name\nevent_name\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.run_analysis.html#ansys.sherlock.core.analysis.Analysis.run_analysis",
        "title": "run_analysis > run_analysis > run_analysis",
        "section": "run_analysis > run_analysis",
        "text": "Analysis.run_analysis(project, cca_name, analyses)\n\nRun one or more Sherlock analyses.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nanalyses: list of ``elements``\n\nelements: list[tuple[RunAnalysisRequestAnalysisType, tuple[str, str]]]\n\nTuples (type, event)\n\nanalysis_type: RunAnalysisRequestAnalysisType\n\nType of analysis to run.\n\nevent: list[tuple[str, str]]\n\nTuples (phase_name, event_name)\n\nphase_name: str\n\nName of the life cycle phase.\n\nevent_name: str\n\nName of the life cycle event.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.run_analysis(\n    \"Test\",\n    \"Card\",\n    [\n        (RunAnalysisRequestAnalysisType.NATURAL_FREQ,\n        [\n            (\"Phase 1\", [\"Harmonic Event\"])\n        ]\n        )\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionDeleteData.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the project containing the potting regions to delete.\nproject\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "DeletePottingRegionRequest.project: str\n\nName of the project containing the potting regions to delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.validate.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod GerberOutlineFile.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.CircularShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CircularShape.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod RectangularShape.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CopyPottingRegionRequest.model_fields = {'potting_region_copy_data': FieldInfo(annotation=list[PottingRegionCopyData], required=True), 'project': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.json.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CsvExcelOutlineFile.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegion.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds.html#image_bounds",
        "title": "image_bounds",
        "section": "image_bounds",
        "text": "image_bounds\nImageBounds\nimage_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.image_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.image_bounds",
        "title": "image_bounds > image_bounds > image_bounds",
        "section": "image_bounds > image_bounds",
        "text": "ImageFile.image_bounds\n\nimage_bounds\n\n!! processed by numpydoc !!\n\nType\n\nImageBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.html#ansyssherlockcorepartsparts",
        "title": "ansys.sherlock.core.parts.Parts",
        "section": "ansys.sherlock.core.parts.Parts",
        "text": "Contains all parts management capabilities.\nParts.delete_parts_from_parts_list(request)\nDelete parts from the parts list for a given project's CCA.\nParts.enable_lead_modeling(project, cca_name)\nEnable lead modeling for leaded parts.\nParts.export_net_list(project, cca_name, ...)\nExport a net list to a delimited output file.\nParts.export_parts_list(project, cca_name, ...)\nExport a parts list for a CCA.\nParts.get_part_location(project, cca_name, ...)\nReturn the location properties for one or more part.\nParts.get_parts_list_properties(request)\nReturn the properties for one or more parts in the parts list for the CCA.\nParts.import_parts_list(project, cca_name, ...)\nImport a parts list for a CCA.\nParts.update_pad_properties(request)\nUpdate pad properties for one or more parts in a parts list.\nParts.update_parts_from_AVL(project, ...)\nUpdate the parts list from the Approved Vendor List (AVL).\nParts.update_parts_list(project, cca_name, ...)\nUpdate a parts list based on matching and duplication preferences.\nParts.update_parts_list_properties(project, ...)\nUpdate one or more properties of one or more parts in a parts list.\nParts.update_parts_locations(project, ...)\nUpdate one or more part locations.\nParts.update_parts_locations_by_file(...[, ...])\nUpdate one or more part locations using a CSV file.\nansys.sherlock.core.parts.Parts\nParts.delete_parts_from_parts_list\nParts.enable_lead_modeling\nParts.export_net_list\nParts.export_parts_list\nParts.get_part_location\nParts.get_parts_list_properties\nParts.import_parts_list\nParts.update_pad_properties\nParts.update_parts_from_AVL\nParts.update_parts_list\nParts.update_parts_list_properties\nParts.update_parts_locations\nParts.update_parts_locations_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.html#ansys.sherlock.core.parts.Parts",
        "title": "ansys.sherlock.core.parts.Parts > ansys.sherlock.core.parts.Parts > Parts",
        "section": "ansys.sherlock.core.parts.Parts > Parts",
        "text": "class ansys.sherlock.core.parts.Parts(channel, server_version)\n\nContains all parts management capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nParts.delete_parts_from_parts_list(request)\n\nDelete parts from the parts list for a given project's CCA.\n\nParts.enable_lead_modeling(project, cca_name)\n\nEnable lead modeling for leaded parts.\n\nParts.export_net_list(project, cca_name, ...)\n\nExport a net list to a delimited output file.\n\nParts.export_parts_list(project, cca_name, ...)\n\nExport a parts list for a CCA.\n\nParts.get_part_location(project, cca_name, ...)\n\nReturn the location properties for one or more part.\n\nParts.get_parts_list_properties(request)\n\nReturn the properties for one or more parts in the parts list for the CCA.\n\nParts.import_parts_list(project, cca_name, ...)\n\nImport a parts list for a CCA.\n\nParts.update_pad_properties(request)\n\nUpdate pad properties for one or more parts in a parts list.\n\nParts.update_parts_from_AVL(project, ...)\n\nUpdate the parts list from the Approved Vendor List (AVL).\n\nParts.update_parts_list(project, cca_name, ...)\n\nUpdate a parts list based on matching and duplication preferences.\n\nParts.update_parts_list_properties(project, ...)\n\nUpdate one or more properties of one or more parts in a parts list.\n\nParts.update_parts_locations(project, ...)\n\nUpdate one or more part locations.\n\nParts.update_parts_locations_by_file(...[, ...])\n\nUpdate one or more part locations using a CSV file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock.html#launch_sherlock",
        "title": "launch_sherlock",
        "section": "launch_sherlock",
        "text": "Launch Sherlock and start gRPC on a given host and port. Wait up to two minutes to connect.\n:rtype: Sherlock\nDeprecated since version 2025: R2\nUse launch() or launch_and_connect() instead.\nIP address to start gRPC on. The default is \"127.0.0.1\", which\nis the IP address for the local host.\nPort number for the connection.\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\nAdditional command arguments for launching Sherlock.\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nThe instance of sherlock.\nlaunch_sherlock\nSherlock\nlaunch()\nlaunch_and_connect()\n\"127.0.0.1\"\npython:str\noptional\npython:str\noptional\nSherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_sherlock.html#ansys.sherlock.core.launcher.launch_sherlock",
        "title": "launch_sherlock > launch_sherlock > launch_sherlock",
        "section": "launch_sherlock > launch_sherlock",
        "text": "ansys.sherlock.core.launcher.launch_sherlock(host='127.0.0.1', port=9090, single_project_path='', sherlock_command_args='', year=None, release_number=None)\n\nLaunch Sherlock and start gRPC on a given host and port. Wait up to two minutes to connect.\n:rtype: Sherlock\n\nDeprecated since version 2025: R2\n\nUse launch() or launch_and_connect() instead.\n\nParameters\n\nhost: str, optional\n\nIP address to start gRPC on. The default is \"127.0.0.1\", which\nis the IP address for the local host.\n\nport: int, optional\n\nPort number for the connection.\n\nsingle_project_path\n\npython:str, optional\n\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\n\nsherlock_command_args\n\npython:str, optional\n\nAdditional command arguments for launching Sherlock.\n\nyear: int, optional\n\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nrelease_number: int, optional\n\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nReturns\n\n:\n\n\n\nSherlock\n\nThe instance of sherlock.\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> launcher.launch_sherlock()\n\n>>> from ansys.sherlock.core import launcher\n>>> launcher.launch_sherlock(port=9092, year=2024, release_number=1)\n\n>>> from ansys.sherlock.core import launcher\n>>> project = \"C:\\\\Default Projects Directory\\\\ODB++ Tutorial\"\n>>> launcher.launch_sherlock(port=9092, single_project_path=project)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod GerberOutlineFile.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionUpdateData.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.from_orm.html#ansys.sherlock.core.types.project_types.OutlineFile.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod OutlineFile.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property RectangularShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures.html#delete_all_ict_fixtures",
        "title": "delete_all_ict_fixtures",
        "section": "delete_all_ict_fixtures",
        "text": "Delete all ICT fixtures for a CCA.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_ict_fixtures\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures.html#ansys.sherlock.core.layer.Layer.delete_all_ict_fixtures",
        "title": "delete_all_ict_fixtures > delete_all_ict_fixtures > delete_all_ict_fixtures",
        "section": "delete_all_ict_fixtures > delete_all_ict_fixtures",
        "text": "Layer.delete_all_ict_fixtures(project, cca_name)\n\nDelete all ICT fixtures for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_ict_fixtures_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"ICTFixturesImport.csv\",\n>>> )\n>>> sherlock.layer.delete_all_ict_fixtures(\"Test\", \"Card\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields.html#get_solder_fatigue_input_fields",
        "title": "get_solder_fatigue_input_fields",
        "section": "get_solder_fatigue_input_fields",
        "text": "Get solder fatigue property fields based on the user configuration.\nAvailable Since: 2024R1\nSolder fatigue property fields based on the user configuration.\nlist[str]\nget_solder_fatigue_input_fields\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_solder_fatigue_input_fields",
        "title": "get_solder_fatigue_input_fields > get_solder_fatigue_input_fields > get_solder_fatigue_input_fields",
        "section": "get_solder_fatigue_input_fields > get_solder_fatigue_input_fields",
        "text": "Analysis.get_solder_fatigue_input_fields()\n\nGet solder fatigue property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nSolder fatigue property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_solder_fatigue_input_fields()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_json_schema.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod GerberOutlineFile.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.rotation.html#ansys.sherlock.core.types.layer_types.SlotShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "SlotShape.rotation: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PolygonalShape.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema.html#ansys.sherlock.core.types.layer_types.RectangularShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod RectangularShape.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionCopyData.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions.html#update_potting_regions",
        "title": "update_potting_regions",
        "section": "update_potting_regions",
        "text": "List of potting region data to update.\nupdate_potting_regions\nlist\nPottingRegionUpdateData"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_potting_regions",
        "title": "update_potting_regions > update_potting_regions > update_potting_regions",
        "section": "update_potting_regions > update_potting_regions",
        "text": "UpdatePottingRegionRequest.update_potting_regions: list[PottingRegionUpdateData]\n\nList of potting region data to update.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#run-ict-analysis",
        "title": "Run ICT Analysis",
        "section": "Run ICT Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand configure ICT analysis properties.\nRun ICT Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#description",
        "title": "Run ICT Analysis > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform ICT (In-Circuit Test) analysis.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Configure the properties for ICT analysis.\nFor further details, refer to the official documentation on ICT analysis in Sherlock.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#connect-to-sherlock",
        "title": "Run ICT Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#delete-project",
        "title": "Run ICT Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#import-tutorial-project",
        "title": "Run ICT Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_ict_properties",
        "href": "examples/gallery_examples/04-analyses/update_ict_properties.html#update-ict-analysis-properties",
        "title": "Run ICT Analysis > Update ICT Analysis Properties",
        "section": "Update ICT Analysis Properties",
        "text": "Configure properties for ICT analysis.\nDownload Jupyter notebook: update_ict_properties.ipynb\nDownload Python source code: update_ict_properties.py\nDownload zipped: update_ict_properties.zip\nUpdate ICT Analysis Properties\nDownload Jupyter notebook: update_ict_properties.ipynb\nDownload Python source code: update_ict_properties.py\nDownload zipped: update_ict_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegion.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.construct.html#ansys.sherlock.core.types.layer_types.PolygonalShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PolygonalShape.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.SlotShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod SlotShape.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "UpdatePottingRegionRequest.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_file",
        "href": "examples/gallery_examples/02-importing/import_project_zip_file.html#sherlock-project-import-with-grpc",
        "title": "Sherlock Project Import with gRPC",
        "section": "Sherlock Project Import with gRPC",
        "text": "This example demonstrates how to launch the Sherlock gRPC service, import a\nproject archive, and handle common exceptions during the import process.\nSherlock Project Import with gRPC"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_file",
        "href": "examples/gallery_examples/02-importing/import_project_zip_file.html#description",
        "title": "Sherlock Project Import with gRPC > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API enables automation of various workflows, including project\nmanagement.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a sample project archive.\n- Handle import errors gracefully.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_file",
        "href": "examples/gallery_examples/02-importing/import_project_zip_file.html#connect-to-sherlock",
        "title": "Sherlock Project Import with gRPC > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_file",
        "href": "examples/gallery_examples/02-importing/import_project_zip_file.html#delete-project",
        "title": "Sherlock Project Import with gRPC > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_file",
        "href": "examples/gallery_examples/02-importing/import_project_zip_file.html#import-sherlock-project",
        "title": "Sherlock Project Import with gRPC > Import Sherlock Project",
        "section": "Import Sherlock Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nDownload Jupyter notebook: import_project_zip_file.ipynb\nDownload Python source code: import_project_zip_file.py\nDownload zipped: import_project_zip_file.zip\nImport Sherlock Project\nDownload Jupyter notebook: import_project_zip_file.ipynb\nDownload Python source code: import_project_zip_file.py\nDownload zipped: import_project_zip_file.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps.html#list_thermal_maps",
        "title": "list_thermal_maps",
        "section": "list_thermal_maps",
        "text": "List the thermal map files and their type assigned to each CCA of given CCAs.\nAvailable Since: 2024R2\nName of the Sherlock project.\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nAll thermal map files or thermal map files and their type for the specified CCAs.\nlist\nlist_thermal_maps\nNone\npython:list\nlist"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_thermal_maps.html#ansys.sherlock.core.project.Project.list_thermal_maps",
        "title": "list_thermal_maps > list_thermal_maps > list_thermal_maps",
        "section": "list_thermal_maps > list_thermal_maps",
        "text": "Project.list_thermal_maps(project, cca_names=None)\n\nList the thermal map files and their type assigned to each CCA of given CCAs.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\n:\n\n\n\npython:list\n\nAll thermal map files or thermal map files and their type for the specified CCAs.\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> thermal_maps = sherlock.project.list_thermal_maps(\n    \"AssemblyTutorial\",\n    [\"Main Board\",\"Power Module\"]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegion.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionUpdateData.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod DeletePottingRegionRequest.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump_json.html#ansys.sherlock.core.types.project_types.OutlineFile.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "OutlineFile.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionDeleteData.model_fields = {'cca_name': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod RectangularShape.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.SlotShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod SlotShape.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.CircularShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property CircularShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionCopyData.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.html#ansyssherlockcoretypesproject_typescsvexcelfile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelFile",
        "text": "Contains the properties for a thermal map, CSV, or Excel file.\nCsvExcelFile.header_row_count\nheader_row_count\nCsvExcelFile.numeric_format\nnumeric_format\nCsvExcelFile.reference_id_column\nreference_id_column\nCsvExcelFile.temperature_column\ntemperature_column\nCsvExcelFile.temperature_units\ntemperature_units\nansys.sherlock.core.types.project_types.CsvExcelFile\nCsvExcelFile.header_row_count\nCsvExcelFile.numeric_format\nCsvExcelFile.reference_id_column\nCsvExcelFile.temperature_column\nCsvExcelFile.temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.html#ansys.sherlock.core.types.project_types.CsvExcelFile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelFile > ansys.sherlock.core.types.project_types.CsvExcelFile > CsvExcelFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelFile > CsvExcelFile",
        "text": "class ansys.sherlock.core.types.project_types.CsvExcelFile(header_row_count, numeric_format, reference_id_column, temperature_column, temperature_units)\n\nContains the properties for a thermal map, CSV, or Excel file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCsvExcelFile.header_row_count\n\nheader_row_count\n\nCsvExcelFile.numeric_format\n\nnumeric_format\n\nCsvExcelFile.reference_id_column\n\nreference_id_column\n\nCsvExcelFile.temperature_column\n\ntemperature_column\n\nCsvExcelFile.temperature_units\n\ntemperature_units\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegion.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#update-part-locations-by-file",
        "title": "Update Part Locations by File",
        "section": "Update Part Locations by File",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update part locations using a CSV file.\nUpdate Part Locations by File"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#description",
        "title": "Update Part Locations by File > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating part\nlocations for printed circuit boards (PCBs) using a CSV file.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Update part locations using a CSV file.\nThe updated part locations can ensure consistency across various PCB designs.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#connect-to-sherlock",
        "title": "Update Part Locations by File > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#delete-project",
        "title": "Update Part Locations by File > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#import-tutorial-project",
        "title": "Update Part Locations by File > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location_by_file.html#update-part-locations-by-file",
        "title": "Update Part Locations by File",
        "section": "Update Part Locations by File",
        "text": "Update the part locations for the “Card” of the “Test” project using a CSV file.\nDownload Jupyter notebook: update_part_location_by_file.ipynb\nDownload Python source code: update_part_location_by_file.py\nDownload zipped: update_part_location_by_file.zip\nUpdate Part Locations by File\nDownload Jupyter notebook: update_part_location_by_file.ipynb\nDownload Python source code: update_part_location_by_file.py\nDownload zipped: update_part_location_by_file.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CopyPottingRegionRequest.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionDeleteData.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CopyPottingRegionRequest.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.copy.html#ansys.sherlock.core.types.layer_types.CircularShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CircularShape.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region.html#update_potting_region",
        "title": "update_potting_region",
        "section": "update_potting_region",
        "text": "Update one or more potting regions in a specific project.\nAvailable Since: 2025R1\nContains all the information needed to update one or more potting regions per project.\nReturn codes for each request.\nlist[ReturnCode]\nupdate_potting_region\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_potting_region.html#ansys.sherlock.core.layer.Layer.update_potting_region",
        "title": "update_potting_region > update_potting_region > update_potting_region",
        "section": "update_potting_region > update_potting_region",
        "text": "Layer.update_potting_region(request)\n\nUpdate one or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest: UpdatePottingRegionRequest\n\nContains all the information needed to update one or more potting regions per project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import PolygonalShape\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionUpdateData\n>>> from ansys.sherlock.core.types.layer_types import PottingRegion\n>>> sherlock = launch_sherlock()\n>>>\n>>> update1 = PottingRegionUpdateData(\n>>> potting_region_id_to_update=potting_id,\n>>> potting_region=PottingRegionData(\n>>>     cca_name=cca_name,\n>>>     potting_id=potting_id,\n>>>     potting_side=potting_side,\n>>>     potting_material=potting_material,\n>>>     potting_units=potting_units,\n>>>     potting_thickness=potting_thickness,\n>>>     potting_standoff=potting_standoff,\n>>>     shape=PolygonalShape(\n>>>         points=[(0, 1), (5, 1), (5, 5), (1, 5)],\n>>>         rotation=45.0\n>>>     )\n>>> )\n>>> )\n>>> update2 = PottingRegionUpdateData(\n>>> potting_region_id_to_update=potting_id,\n>>> potting_region=PottingRegionData(\n>>>     cca_name=cca_name,\n>>>     potting_id=potting_id,\n>>>     potting_side=potting_side,\n>>>     potting_material=potting_material,\n>>>     potting_units=potting_units,\n>>>     potting_thickness=potting_thickness,\n>>>     potting_standoff=potting_standoff,\n>>>     shape=PolygonalShape(\n>>>         points=[(0, 1), (5, 1), (5, 5), (1, 5)],\n>>>         rotation=0.0\n>>>     )\n>>> )\n>>> )\n>>> example_request = UpdatePottingRegionRequest(\n>>>     \"project_name\",\n>>>     [\n>>>         update1,\n>>>         update2\n>>>     ]\n>>> )\n>>> return_codes = sherlock.layer.update_potting_region(example_request)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegion.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.validate.html#ansys.sherlock.core.types.layer_types.CircularShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CircularShape.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.RectangularShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod RectangularShape.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/layer_types",
        "href": "api/layer_types.html#layer-types",
        "title": "Layer Types",
        "section": "Layer Types",
        "text": "Classes used for the Layer API.\nModule containing types for the Layer Service.\nCopyPottingRegionRequest(**data)\nRequest to delete 1 or more potting regions.\nDeletePottingRegionRequest(**data)\nRequest to delete 1 or more potting regions.\nPolygonalShape(**data)\nContains the properties for a polygonal shape.\nRectangularShape(**data)\nContains the properties for a rectangular shape.\nSlotShape(**data)\nContains the properties for a slot shape.\nCircularShape(**data)\nContains the properties for a circular shape.\nPCBShape(**data)\nContains the properties for a PCB shape.\nPottingRegion(**data)\nContains the properties of a Potting Region add or update request.\nPottingRegionCopyData(**data)\nData identifying which potting regions to copy.\nPottingRegionDeleteData(**data)\nData specifying potting regions to delete.\nPottingRegionUpdateData(**data)\nContains the properties of a potting region update request.\nUpdatePottingRegionRequest(**data)\nContains the properties of a potting region update per project.\nLayer Types\nCopyPottingRegionRequest\nDeletePottingRegionRequest\nPolygonalShape\nRectangularShape\nSlotShape\nCircularShape\nPCBShape\nPottingRegion\nPottingRegionCopyData\nPottingRegionDeleteData\nPottingRegionUpdateData\nUpdatePottingRegionRequest"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema.html#ansys.sherlock.core.types.layer_types.PCBShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PCBShape.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_construct.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod RectangularShape.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod UpdatePottingRegionRequest.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_post_init.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CsvExcelOutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#run-part-list-validation-analysis",
        "title": "Run Part List Validation Analysis",
        "section": "Run Part List Validation Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand configure part list validation analysis properties.\nRun Part List Validation Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#description",
        "title": "Run Part List Validation Analysis > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform part list validation analysis.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Configure the properties for part list validation analysis.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#connect-to-sherlock",
        "title": "Run Part List Validation Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#delete-project",
        "title": "Run Part List Validation Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#import-tutorial-project",
        "title": "Run Part List Validation Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_part_validation_properties",
        "href": "examples/gallery_examples/04-analyses/update_part_validation_properties.html#update-part-list-validation-properties",
        "title": "Run Part List Validation Analysis > Update Part List Validation Properties",
        "section": "Update Part List Validation Properties",
        "text": "Configure properties for part list validation analysis.\nDownload Jupyter notebook: update_part_validation_properties.ipynb\nDownload Python source code: update_part_validation_properties.py\nDownload zipped: update_part_validation_properties.zip\nUpdate Part List Validation Properties\nDownload Jupyter notebook: update_part_validation_properties.ipynb\nDownload Python source code: update_part_validation_properties.py\nDownload zipped: update_part_validation_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegionUpdateData.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.html#ansyssherlockcoretypesproject_typeslegendbounds",
        "title": "ansys.sherlock.core.types.project_types.LegendBounds",
        "section": "ansys.sherlock.core.types.project_types.LegendBounds",
        "text": "Contains the properties of the legend bounds.\nLegendBounds.legend_x\nx coordinate of the upper left corner\nLegendBounds.legend_y\ny coordinate of the upper left corner\nLegendBounds.height\nheight of the legend\nLegendBounds.width\nwidth of the legend\nansys.sherlock.core.types.project_types.LegendBounds\nLegendBounds.legend_x\nLegendBounds.legend_y\nLegendBounds.height\nLegendBounds.width"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.html#ansys.sherlock.core.types.project_types.LegendBounds",
        "title": "ansys.sherlock.core.types.project_types.LegendBounds > ansys.sherlock.core.types.project_types.LegendBounds > LegendBounds",
        "section": "ansys.sherlock.core.types.project_types.LegendBounds > LegendBounds",
        "text": "class ansys.sherlock.core.types.project_types.LegendBounds(legend_x, legend_y, height, width)\n\nContains the properties of the legend bounds.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nLegendBounds.legend_x\n\nx coordinate of the upper left corner\n\nLegendBounds.legend_y\n\ny coordinate of the upper left corner\n\nLegendBounds.height\n\nheight of the legend\n\nLegendBounds.width\n\nwidth of the legend\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_config.html#ansys.sherlock.core.types.layer_types.CircularShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CircularShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionCopyData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod RectangularShape.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_rebuild.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod GerberOutlineFile.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#update-random-vibration-properties",
        "title": "Update Random Vibration Properties",
        "section": "Update Random Vibration Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update random vibration properties.\nUpdate Random Vibration Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#description",
        "title": "Update Random Vibration Properties > Description",
        "section": "Description",
        "text": "Sherlock allows you to configure random vibration properties for specific PCBs.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Update random vibration properties.\nFor further details, refer to the official documentation on random vibration properties in Sherlock.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#connect-to-sherlock",
        "title": "Update Random Vibration Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#delete-project",
        "title": "Update Random Vibration Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#import-tutorial-project",
        "title": "Update Random Vibration Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_random_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_random_vibe_properties.html#update-random-vibration-properties",
        "title": "Update Random Vibration Properties",
        "section": "Update Random Vibration Properties",
        "text": "Configure random vibration properties for the PCB.\nDownload Jupyter notebook: update_random_vibe_properties.ipynb\nDownload Python source code: update_random_vibe_properties.py\nDownload zipped: update_random_vibe_properties.zip\nUpdate Random Vibration Properties\nDownload Jupyter notebook: update_random_vibe_properties.ipynb\nDownload Python source code: update_random_vibe_properties.py\nDownload zipped: update_random_vibe_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props.html#update_part_modeling_props",
        "title": "update_part_modeling_props",
        "section": "update_part_modeling_props",
        "text": "Update part modeling properties for a given project’s CCA.\nAvailable Since: 2024R1\nName of the Sherlock project.\nPart modeling properties for a CCA consisting of these properties:\nName of the CCA.\nWhether to enable part modeling. All other fields are ignored if disabled.\nMinimum part size.\nMinimum part size units.\nPart element order.\nOptions are \"First Order (Linear)\", \"Second Order (Quadratic)\",\nor \"Solid Shell\".\nPart max edge length.\nPart max edge length units.\nPart max vertical.\nPart max vertical units.\nWhether to enable filtered part results.\nStatus code of the response. 0 for success.\nint\nupdate_part_modeling_props\n\"First Order (Linear)\"\n\"Second Order (Quadratic)\"\n\"Solid Shell\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_modeling_props.html#ansys.sherlock.core.analysis.Analysis.update_part_modeling_props",
        "title": "update_part_modeling_props > update_part_modeling_props > update_part_modeling_props",
        "section": "update_part_modeling_props > update_part_modeling_props",
        "text": "Analysis.update_part_modeling_props(project, part_modeling_props)\n\nUpdate part modeling properties for a given project’s CCA.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\npart_modeling_props: dict[str, bool | float | str]\n\nPart modeling properties for a CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\npart_enabled: bool\n\nWhether to enable part modeling. All other fields are ignored if disabled.\n\npart_min_size: float, optional\n\nMinimum part size.\n\npart_min_size_units: str, optional\n\nMinimum part size units.\n\npart_elem_order: str, optional\n\nPart element order.\nOptions are \"First Order (Linear)\", \"Second Order (Quadratic)\",\nor \"Solid Shell\".\n\npart_max_edge_length: float, optional\n\nPart max edge length.\n\npart_max_edge_length_units: str, optional\n\nPart max edge length units.\n\npart_max_vertical: float, optional\n\nPart max vertical.\n\npart_max_vertical_units: str, optional\n\nPart max vertical units.\n\npart_results_filtered: bool, optional\n\nWhether to enable filtered part results.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_part_modeling_props(\n    \"Test\",\n    {\n        \"cca_name\": \"Card\",\n        \"part_enabled\": True,\n        \"part_min_size\": 1,\n        \"part_min_size_units\": \"in\",\n        \"part_elem_order\": \"First Order (Linear)\",\n        \"part_max_edge_length\": 1,\n        \"part_max_edge_length_units\": \"in\",\n        \"part_max_vertical\": 1,\n        \"part_max_vertical_units\": \"in\",\n        \"part_results_filtered\": True\n    }\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.construct.html#ansys.sherlock.core.types.layer_types.CircularShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CircularShape.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegion.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "UpdatePottingRegionRequest.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/sg_execution_times",
        "href": "examples/gallery_examples/99-teardown/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 1 file from examplesgallery_examples99-teardown:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_99-teardown_teardown.py (teardown.py)\n00:00.000\n0.0\nComputation times\nteardown.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegion.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionCopyData.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema_json.html#ansys.sherlock.core.types.layer_types.SlotShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod SlotShape.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.html#ansyssherlockcoretypesproject_typesgerberoutlinefile",
        "title": "ansys.sherlock.core.types.project_types.GerberOutlineFile",
        "section": "ansys.sherlock.core.types.project_types.GerberOutlineFile",
        "text": "Contains the properties for a Gerber outline file.\nGerberOutlineFile.construct([_fields_set])\n\nGerberOutlineFile.copy(*[, include, ...])\nReturns a copy of the model.\nGerberOutlineFile.dict(*[, include, ...])\n\nGerberOutlineFile.from_orm(obj)\n\nGerberOutlineFile.json(*[, include, ...])\n\nGerberOutlineFile.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nGerberOutlineFile.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nGerberOutlineFile.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nGerberOutlineFile.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nGerberOutlineFile.model_json_schema([...])\nGenerates a JSON schema for a model class.\nGerberOutlineFile.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nGerberOutlineFile.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nGerberOutlineFile.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nGerberOutlineFile.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nGerberOutlineFile.model_validate_json(...[, ...])\n!!! abstract \"Usage Documentation\"\nGerberOutlineFile.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nGerberOutlineFile.parse_file(path, *[, ...])\n\nGerberOutlineFile.parse_obj(obj)\n\nGerberOutlineFile.parse_raw(b, *[, ...])\n\nGerberOutlineFile.schema([by_alias, ...])\n\nGerberOutlineFile.schema_json(*[, by_alias, ...])\n\nGerberOutlineFile.update_forward_refs(**localns)\n\nGerberOutlineFile.validate(value)\n\nGerberOutlineFile.model_computed_fields\n\nGerberOutlineFile.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nGerberOutlineFile.model_extra\nGet extra fields set during validation.\nGerberOutlineFile.model_fields\n\nGerberOutlineFile.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nGerberOutlineFile.parse_decimal_first\nIndicates to parse decimals based on the length of the format specifier.\nansys.sherlock.core.types.project_types.GerberOutlineFile\nGerberOutlineFile.construct\nGerberOutlineFile.copy\nGerberOutlineFile.dict\nGerberOutlineFile.from_orm\nGerberOutlineFile.json\nGerberOutlineFile.model_construct\nGerberOutlineFile.model_copy\nGerberOutlineFile.model_dump\nGerberOutlineFile.model_dump_json\nGerberOutlineFile.model_json_schema\nGerberOutlineFile.model_parametrized_name\nGerberOutlineFile.model_post_init\nGerberOutlineFile.model_rebuild\nGerberOutlineFile.model_validate\nGerberOutlineFile.model_validate_json\nGerberOutlineFile.model_validate_strings\nGerberOutlineFile.parse_file\nGerberOutlineFile.parse_obj\nGerberOutlineFile.parse_raw\nGerberOutlineFile.schema\nGerberOutlineFile.schema_json\nGerberOutlineFile.update_forward_refs\nGerberOutlineFile.validate\nGerberOutlineFile.model_computed_fields\nGerberOutlineFile.model_config\nGerberOutlineFile.model_extra\nGerberOutlineFile.model_fields\nGerberOutlineFile.model_fields_set\nGerberOutlineFile.parse_decimal_first"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.html#ansys.sherlock.core.types.project_types.GerberOutlineFile",
        "title": "ansys.sherlock.core.types.project_types.GerberOutlineFile > ansys.sherlock.core.types.project_types.GerberOutlineFile > GerberOutlineFile",
        "section": "ansys.sherlock.core.types.project_types.GerberOutlineFile > GerberOutlineFile",
        "text": "class ansys.sherlock.core.types.project_types.GerberOutlineFile(**data)\n\nContains the properties for a Gerber outline file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nGerberOutlineFile.construct([_fields_set])\n\n\n\nGerberOutlineFile.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nGerberOutlineFile.dict(*[, include, ...])\n\n\n\nGerberOutlineFile.from_orm(obj)\n\n\n\nGerberOutlineFile.json(*[, include, ...])\n\n\n\nGerberOutlineFile.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nGerberOutlineFile.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nGerberOutlineFile.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nGerberOutlineFile.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nGerberOutlineFile.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nGerberOutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nGerberOutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nGerberOutlineFile.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nGerberOutlineFile.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nGerberOutlineFile.model_validate_json(...[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nGerberOutlineFile.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nGerberOutlineFile.parse_file(path, *[, ...])\n\n\n\nGerberOutlineFile.parse_obj(obj)\n\n\n\nGerberOutlineFile.parse_raw(b, *[, ...])\n\n\n\nGerberOutlineFile.schema([by_alias, ...])\n\n\n\nGerberOutlineFile.schema_json(*[, by_alias, ...])\n\n\n\nGerberOutlineFile.update_forward_refs(**localns)\n\n\n\nGerberOutlineFile.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nGerberOutlineFile.model_computed_fields\n\n\n\nGerberOutlineFile.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nGerberOutlineFile.model_extra\n\nGet extra fields set during validation.\n\nGerberOutlineFile.model_fields\n\n\n\nGerberOutlineFile.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nGerberOutlineFile.parse_decimal_first\n\nIndicates to parse decimals based on the length of the format specifier.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.validate.html#ansys.sherlock.core.types.layer_types.PottingRegion.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegion.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema_json.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CsvExcelOutlineFile.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_name.html#file_name",
        "title": "file_name",
        "section": "file_name",
        "text": "The filename of the outline file.\nfile_name\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_name.html#ansys.sherlock.core.types.project_types.OutlineFile.file_name",
        "title": "file_name > file_name > file_name",
        "section": "file_name > file_name",
        "text": "OutlineFile.file_name: str\n\nThe filename of the outline file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_json.html#ansys.sherlock.core.types.project_types.OutlineFile.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod OutlineFile.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod UpdatePottingRegionRequest.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_semiconductor_wearout_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_semiconductor_wearout_props.html#update_semiconductor_wearout_props",
        "title": "update_semiconductor_wearout_props",
        "section": "update_semiconductor_wearout_props",
        "text": "Update properties for one or more Semiconductor Wearout Analysis.\nContains all the information needed to update the properties for one or more\nsemiconductor wearout analyses per project.\nReturn codes for each request.\nlist[ReturnCode]\nupdate_semiconductor_wearout_props\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_semiconductor_wearout_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_semiconductor_wearout_props.html#ansys.sherlock.core.analysis.Analysis.update_semiconductor_wearout_props",
        "title": "update_semiconductor_wearout_props > update_semiconductor_wearout_props > update_semiconductor_wearout_props",
        "section": "update_semiconductor_wearout_props > update_semiconductor_wearout_props",
        "text": "Analysis.update_semiconductor_wearout_props(request)\n\nUpdate properties for one or more Semiconductor Wearout Analysis.\n\nParameters\n\nrequest: UpdateSemiconductorWearoutAnalysisPropsRequest\n\nContains all the information needed to update the properties for one or more\nsemiconductor wearout analyses per project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.analysis_types import (\n    SemiconductorWearoutAnalysis,\n    UpdateSemiconductorWearoutAnalysisPropsRequest,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\n    project=\"Assembly Tutorial\",\n    category=\"category\",\n    archive_file=\\\n        \"C:\\\\Program Files\\\\ANSYS Inc\\\\v252\\\\sherlock\\\\tutorial\\\\Assembly Tutorial.zip\",\n)\n>>> update_request1 = SemiconductorWearoutAnalysis(\n    cca_name=\"Main Board\",\n    max_feature_size=1.5,\n    max_feature_size_units=\"mm\",\n    part_temp_rise=10.0,\n    part_temp_rise_units=\"C\",\n    part_temp_rise_min_enabled=True,\n    part_validation_enabled=False,\n)\n>>> update_request2 = SemiconductorWearoutAnalysis(\n    cca_name=\"Memory Card 1\",\n    max_feature_size=2.0,\n    max_feature_size_units=\"mm\",\n    part_temp_rise=15.0,\n    part_temp_rise_units=\"C\",\n    part_temp_rise_min_enabled=False,\n    part_validation_enabled=True,\n)\n>>> request = UpdateSemiconductorWearoutAnalysisPropsRequest(\n    project=\"Test\",\n    semiconductor_wearout_analysis_properties=[\n        update_request1,\n        update_request2\n    ]\n)\n>>> return_codes = sherlock.analysis.update_semiconductor_wearout_props(request)\n>>> for return_code in return_codes:\n        print(f\"Return code: value={return_code.value}, message={return_code.message}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas.html#list_ccas",
        "title": "list_ccas",
        "section": "list_ccas",
        "text": "List CCAs and subassembly CCAs assigned to each CCA or given CCAs.\nAvailable Since: 2023R2\nName of the Sherlock project.\nCCA names. The default is None, in which case all CCAs\nin the project are returned.\nCCAs and subassembly CCAs.\ndict[str, str | dict[str, str]]\nlist_ccas\nNone\npython:list\ndict\nstr\nstr\ndict\nstr\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_ccas.html#ansys.sherlock.core.project.Project.list_ccas",
        "title": "list_ccas > list_ccas > list_ccas",
        "section": "list_ccas > list_ccas",
        "text": "Project.list_ccas(project, cca_names=None)\n\nList CCAs and subassembly CCAs assigned to each CCA or given CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_names: list[str], optional\n\nCCA names. The default is None, in which case all CCAs\nin the project are returned.\n\nReturns\n\n:\n\n\n\npython:list\n\nCCAs and subassembly CCAs.\n\nReturn type\n\ndict[str, str | dict[str, str]]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> ccas = sherlock.project.list_ccas(\"AssemblyTutorial\", [\"Main Board\"])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_x.html#ansys.sherlock.core.types.layer_types.RectangularShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "RectangularShape.center_x: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod UpdatePottingRegionRequest.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod UpdatePottingRegionRequest.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode.html#import_project_zip_archive_single_mode",
        "title": "import_project_zip_archive_single_mode",
        "section": "import_project_zip_archive_single_mode",
        "text": "Import a zipped project archive – single project mode.\nAvailable Since: 2024R2\nName of the Sherlock project.\nSherlock project category.\nFull path to the .zip archive file containing the project data.\nDirectory in which the Sherlock project folder will be created.\nStatus code of the response. 0 for success.\nimport_project_zip_archive_single_mode\npython:int"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode.html#ansys.sherlock.core.project.Project.import_project_zip_archive_single_mode",
        "title": "import_project_zip_archive_single_mode > import_project_zip_archive_single_mode > import_project_zip_archive_single_mode",
        "section": "import_project_zip_archive_single_mode > import_project_zip_archive_single_mode",
        "text": "Project.import_project_zip_archive_single_mode(project, category, archive_file, destination_file_directory)\n\nImport a zipped project archive – single project mode.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncategory: str\n\nSherlock project category.\n\narchive_file: str\n\nFull path to the .zip archive file containing the project data.\n\ndestination_file_directory: str\n\nDirectory in which the Sherlock project folder will be created.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive_single_mode(\"Tutorial Project\",\n\"Demos\",\n\"Tutorial Project.zip\",\n\"New Tutorial Project\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionDeleteData.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.construct.html#ansys.sherlock.core.types.layer_types.RectangularShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod RectangularShape.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles.html#add_random_vibe_profiles",
        "title": "add_random_vibe_profiles",
        "section": "add_random_vibe_profiles",
        "text": "Add random vibe profiles to a life cycle phase.\nAvailable Since: 2023R2\nName of the Sherlock project.\nRandom vibe profiles consisting of these properties:\nName of the life cycle phase to add the random vibe profile to.\nName of the random vibe event.\nName of the random vibe profile.\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nAmplitude units. Options are \"G2/Hz\", \"m2/s4/Hz\", \"mm2/s4/Hz\",                 \"in2/s4/Hz\", and \"ft2/s4/Hz\".\nRandom vibe profile entries consisting of these properties:\nFrequency of the profile entry expressed in frequency units.\nAmplitude of the profile entry expressed in amplitude units.\nStatus code of the response. 0 for success.\nadd_random_vibe_profiles\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"G2/Hz\"\n\"m2/s4/Hz\"\n\"mm2/s4/Hz\"\n\"in2/s4/Hz\"\n\"ft2/s4/Hz\"\npython:int"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_profiles",
        "title": "add_random_vibe_profiles > add_random_vibe_profiles > add_random_vibe_profiles",
        "section": "add_random_vibe_profiles > add_random_vibe_profiles",
        "text": "Lifecycle.add_random_vibe_profiles(project, random_vibe_profiles)\n\nAdd random vibe profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nrandom_vibe_profiles: list[tuple[str, str, str, str, str, list[tuple[float, float]]]]\n\nRandom vibe profiles consisting of these properties:\n\nphase_name: str\n\nName of the life cycle phase to add the random vibe profile to.\n\nevent_name: str\n\nName of the random vibe event.\n\nprofile_name: str\n\nName of the random vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nampl_units: str\n\nAmplitude units. Options are \"G2/Hz\", \"m2/s4/Hz\", \"mm2/s4/Hz\",                 \"in2/s4/Hz\", and \"ft2/s4/Hz\".\n\nrandom_vibe_profile_entries: list[tuple[float, float]]\n\nRandom vibe profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the profile entry expressed in frequency units.\n\namplitude: float\n\nAmplitude of the profile entry expressed in amplitude units.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_random_vibe_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_random_vibe_profiles(\n    \"Test\",\n     [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"HZ\",\n        \"G2/Hz\",\n        [(4,8), (5, 50)],\n    )]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.dict.html#ansys.sherlock.core.types.layer_types.PottingRegion.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegion.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod DeletePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionDeleteData.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_post_init.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "GerberOutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile.html#load_harmonic_profile",
        "title": "load_harmonic_profile",
        "section": "load_harmonic_profile",
        "text": "Load a harmonic profile from a DAT or CSV file to a life cycle phase.\nAvailable Since: 2021R1\nName of the Sherlock project\nName of the life cycle phase to add the harmonic profile to.\nName of the harmonic event.\nPath for DAT or CSV file with the harmonic profile.\nStatus code of the response. 0 for success.\nint\nload_harmonic_profile\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_harmonic_profile",
        "title": "load_harmonic_profile > load_harmonic_profile > load_harmonic_profile",
        "section": "load_harmonic_profile > load_harmonic_profile",
        "text": "Lifecycle.load_harmonic_profile(project, phase_name, event_name, file_path)\n\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nphase_name: str\n\nName of the life cycle phase to add the harmonic profile to.\n\nevent_name: str\n\nName of the harmonic event.\n\nfile_path: str\n\nPath for DAT or CSV file with the harmonic profile.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n\n>>> loaded = sherlock.lifecycle.load_harmonic_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Harmonic Event\",\n        file_path=\"Test_Profile.dat\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema_json.html#ansys.sherlock.core.types.layer_types.CircularShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CircularShape.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegion.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PolygonalShape.model_fields = {'points': FieldInfo(annotation=list[tuple[float, float]], required=True), 'rotation': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles.html#add_harmonic_vibe_profiles",
        "title": "add_harmonic_vibe_profiles",
        "section": "add_harmonic_vibe_profiles",
        "text": "Add harmonic vibe profiles to a life cycle phase.\nAvailable Since: 2023R2\nName of the Sherlock project.\nHarmonic vibe profiles consisting of these properties:\nName of the life cycle phase to add this harmonic vibe profile to.\nName of the event.\nName of the harmonic vibe profile.\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\",\nand \"GHZ\".\nLoad units. Options are \"G\", `\"m/s2\", \"mm/s2\",\n\"in/s2\", and \"ft/s2\".\nHarmonic profile entries consisting of these properties:\nFrequency of the harmonic profile expressed in frequency units.\nLoad of the harmonic profile expressed in load units.\nAxis that this profile should be assigned to if the harmonic\nprofile type is \"Triaxial\". Options are: \"x\", \"y\",\nand \"z\".\nStatus code of the response. 0 for success.\nint\nadd_harmonic_vibe_profiles\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"G\"\n`\"m/s2\"\n\"mm/s2\"\n\"in/s2\"\n\"ft/s2\"\n\"Triaxial\"\n\"x\"\n\"y\"\n\"z\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_vibe_profiles",
        "title": "add_harmonic_vibe_profiles > add_harmonic_vibe_profiles > add_harmonic_vibe_profiles",
        "section": "add_harmonic_vibe_profiles > add_harmonic_vibe_profiles",
        "text": "Lifecycle.add_harmonic_vibe_profiles(project, harmonic_vibe_profiles)\n\nAdd harmonic vibe profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nharmonic_vibe_profiles: list\n\nHarmonic vibe profiles consisting of these properties:\n\nphase_name: str\n\nName of the life cycle phase to add this harmonic vibe profile to.\n\nevent_name: str\n\nName of the event.\n\nprofile_name: str\n\nName of the harmonic vibe profile.\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\",\nand \"GHZ\".\n\nload_units: str\n\nLoad units. Options are \"G\", `\"m/s2\", \"mm/s2\",\n\"in/s2\", and \"ft/s2\".\n\nharmonic_profile_entries: list[tuple[float, float, str]]\n\nHarmonic profile entries consisting of these properties:\n\nfrequency: float\n\nFrequency of the harmonic profile expressed in frequency units.\n\nload: float\n\nLoad of the harmonic profile expressed in load units.\n\ntriaxial_axis: str\n\nAxis that this profile should be assigned to if the harmonic\nprofile type is \"Triaxial\". Options are: \"x\", \"y\",\nand \"z\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_harmonic_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    5,\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_harmonic_vibe_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"HZ\",\n        \"G\",\n        [\n            (10, 1),\n            (1000, 1),\n        ],\n        \"\",\n    )]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props.html#get_parts_list_validation_analysis_props",
        "title": "get_parts_list_validation_analysis_props",
        "section": "get_parts_list_validation_analysis_props",
        "text": "Get properties for a Part List Validation analysis.\nName of the Sherlock project.\nName of the CCA.\nStatus code of the response. 0 for success.\nindicates general errors that occurred while attempting to update parts\nPart library name\nProcess option to use AVL\nProcess option to use wizard\nProcess option to check confirmed properties\nProcess option to check part numbers\nMatching type\nAVL option to require internal part number\nAVL option to require approved description\nAVL option to require approved manufacturer\nPartsListValidationPropsResponse\nget_parts_list_validation_analysis_props\nPartsListValidationPropsResponse\nPartsListValidationPropsResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props.html#ansys.sherlock.core.analysis.Analysis.get_parts_list_validation_analysis_props",
        "title": "get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props",
        "section": "get_parts_list_validation_analysis_props > get_parts_list_validation_analysis_props",
        "text": "Analysis.get_parts_list_validation_analysis_props(project, cca_name)\n\nGet properties for a Part List Validation analysis.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\nPartsListValidationPropsResponse\n\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nindicates general errors that occurred while attempting to update parts\n\npartLibrary: str\n\nPart library name\n\nprocessUseAVL: bool\n\nProcess option to use AVL\n\nprocessUseWizard: bool\n\nProcess option to use wizard\n\nprocessCheckConfirmedProperties: bool\n\nProcess option to check confirmed properties\n\nprocessCheckPartNumbers: bool\n\nProcess option to check part numbers\n\nmatching: MatchingMode\n\nMatching type\n\navlRequireInternalPartNumber: bool\n\nAVL option to require internal part number\n\navlRequireApprovedDescription: bool\n\nAVL option to require approved description\n\navlRequireApprovedManufacturer: bool\n\nAVL option to require approved manufacturer\n\nReturn type\n\nPartsListValidationPropsResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> analysis_props = sherlock.analysis.get_parts_list_validation_analysis_props(\n    \"Test\", \"Card\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.PCBShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PCBShape.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/00-setup/sg_execution_times",
        "href": "examples/gallery_examples/00-setup/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 1 file from examplesgallery_examples00-setup:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_00-setup_setup.py (setup.py)\n00:00.000\n0.0\nComputation times\nsetup.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod SlotShape.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.schema.html#ansys.sherlock.core.types.layer_types.PottingRegion.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegion.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod DeletePottingRegionRequest.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count.html#get_layer_count",
        "title": "get_layer_count",
        "section": "get_layer_count",
        "text": "Get the number of CCA layers in a stackup.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nThe number of layers of the CCA in the project.\nint\nget_layer_count\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_layer_count.html#ansys.sherlock.core.stackup.Stackup.get_layer_count",
        "title": "get_layer_count > get_layer_count > get_layer_count",
        "section": "get_layer_count > get_layer_count",
        "text": "Stackup.get_layer_count(project, cca_name)\n\nGet the number of CCA layers in a stackup.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\npython:int\n\nThe number of layers of the CCA in the project.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> conductor_layer_count = sherlock.stackup.get_layer_count(\n>>>    project=\"Test\",\n>>>    cca_name=\"Card\")\n>>> print(f\"{conductor_layer_count}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionDeleteData.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.construct.html#ansys.sherlock.core.types.project_types.OutlineFile.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod OutlineFile.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_obj.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod SlotShape.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region.html#copy_potting_region",
        "title": "copy_potting_region",
        "section": "copy_potting_region",
        "text": "Copy one or more potting regions in a specific project.\nAvailable Since: 2025R1\nContains all the information needed to copy one or more potting regions per project.\nReturn codes for each request.\nlist[ReturnCode]\ncopy_potting_region\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_potting_region.html#ansys.sherlock.core.layer.Layer.copy_potting_region",
        "title": "copy_potting_region > copy_potting_region > copy_potting_region",
        "section": "copy_potting_region > copy_potting_region",
        "text": "Layer.copy_potting_region(request)\n\nCopy one or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest: CopyPottingRegionRequest\n\nContains all the information needed to copy one or more potting regions per project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import CopyPottingRegionRequest\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionCopyData\n>>> sherlock = launch_sherlock()\n>>>\n>>> copy_request_example = CopyPottingRegionRequest(\n>>> project=project,\n>>> potting_region_copy_data=[\n>>>     PottingRegionCopyData(\n>>>         cca_name=cca_name,\n>>>         potting_id=potting_id,\n>>>         copy_potting_id=new_id,\n>>>         center_x=center_x,\n>>>         center_y=center_y\n>>>     ),\n>>>     PottingRegionCopyData(\n>>>         cca_name=cca_name,\n>>>         potting_id=new_id,\n>>>         copy_potting_id=new_id+\"1\",\n>>>         center_x=center_x,\n>>>         center_y=center_y\n>>>     )\n>>> ]\n>>> )\n>>> responses_example = sherlock.layer.copy_potting_region(copy_request_example)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.PCBShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PCBShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PolygonalShape.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionCopyData.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.schema_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod RectangularShape.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionDeleteData.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionUpdateData.model_fields = {'potting_region': FieldInfo(annotation=PottingRegion, required=True), 'potting_region_id_to_update': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema_json.html#ansys.sherlock.core.types.project_types.OutlineFile.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod OutlineFile.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_pad_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_pad_properties.html#update_pad_properties",
        "title": "update_pad_properties",
        "section": "update_pad_properties",
        "text": "Update pad properties for one or more parts in a parts list.\nContains all the information needed to update the pad properties for one or more parts\nin a project’s CCA.\nStatus of the pad properties update and any error messages.\nlist[UpdatePadPropertiesResponse]\nupdate_pad_properties\npython:list\nSherlockPartsService_pb2.UpdatePadPropertiesResponse\nlist\nUpdatePadPropertiesResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_pad_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_pad_properties.html#ansys.sherlock.core.parts.Parts.update_pad_properties",
        "title": "update_pad_properties > update_pad_properties > update_pad_properties",
        "section": "update_pad_properties > update_pad_properties",
        "text": "Parts.update_pad_properties(request)\n\nUpdate pad properties for one or more parts in a parts list.\n\nParameters\n\nrequest: UpdatePadPropertiesRequest\n\nContains all the information needed to update the pad properties for one or more parts\nin a project’s CCA.\n\nReturns\n\n:\n\n\n\npython:list[SherlockPartsService_pb2.UpdatePadPropertiesResponse]\n\nStatus of the pad properties update and any error messages.\n\nReturn type\n\nlist[UpdatePadPropertiesResponse]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.parts_types import (\n    UpdatePadPropertiesRequest,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\n    project=\"Assembly Tutorial\",\n    category=\"category\",\n    archive_file=\\\n        \"C:\\\\Program Files\\\\ANSYS Inc\\\\v252\\\\sherlock\\\\tutorial\\\\Assembly Tutorial.zip\",\n)\n>>> request = UpdatePadPropertiesRequest(\n    project=\"Assembly Tutorial\",\n    cca_name=\"Main Board\",\n    reference_designators=[\"U1\", \"R2\", \"C3\"]\n)\n>>> response = sherlock.parts.update_pad_properties(request)\n>>> for res in response:\n        print(f\"Return code: value={res.returnCode.value}, message={res.returnCode.message},\n        reference_designators={res.reference_designators}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_obj.html#ansys.sherlock.core.types.project_types.OutlineFile.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod OutlineFile.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CopyPottingRegionRequest.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count.html#node_count",
        "title": "node_count",
        "section": "node_count",
        "text": "int\nnode count\nnode_count\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.node_count.html#ansys.sherlock.core.types.layer_types.CircularShape.node_count",
        "title": "node_count > node_count > node_count",
        "section": "node_count > node_count",
        "text": "CircularShape.node_count: int\n\nint\n\n!! processed by numpydoc !!\n\nType\n\nnode count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionDeleteData.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.html#ansyssherlockcoremodelmodel",
        "title": "ansys.sherlock.core.model.Model",
        "section": "ansys.sherlock.core.model.Model",
        "text": "Contains all model generation capabilities.\nModel.createExportTraceCopperLayerParams(...)\nCreate a set of parameters to be used to export a single copper layer.\nModel.exportTraceModel(layer_params)\nExport a trace model to a specified output file.\nModel.export_FEA_model(project, cca_name, ...)\nExport a FEA model.\nModel.export_aedb(project_name, cca_name, ...)\nExport an Electronics Desktop model.\nModel.export_trace_reinforcement_model(...)\nExport a trace reinforcement model.\nModel.generate_trace_model(project_name[, ...])\nGenerate one or more trace models for a project.\nansys.sherlock.core.model.Model\nModel.createExportTraceCopperLayerParams\nModel.exportTraceModel\nModel.export_FEA_model\nModel.export_aedb\nModel.export_trace_reinforcement_model\nModel.generate_trace_model"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.html#ansys.sherlock.core.model.Model",
        "title": "ansys.sherlock.core.model.Model > ansys.sherlock.core.model.Model > Model",
        "section": "ansys.sherlock.core.model.Model > Model",
        "text": "class ansys.sherlock.core.model.Model(channel, server_version)\n\nContains all model generation capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nModel.createExportTraceCopperLayerParams(...)\n\nCreate a set of parameters to be used to export a single copper layer.\n\nModel.exportTraceModel(layer_params)\n\nExport a trace model to a specified output file.\n\nModel.export_FEA_model(project, cca_name, ...)\n\nExport a FEA model.\n\nModel.export_aedb(project_name, cca_name, ...)\n\nExport an Electronics Desktop model.\n\nModel.export_trace_reinforcement_model(...)\n\nExport a trace reinforcement model.\n\nModel.generate_trace_model(project_name[, ...])\n\nGenerate one or more trace models for a project.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod DeletePottingRegionRequest.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CopyPottingRegionRequest.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CopyPottingRegionRequest.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_fields.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "RectangularShape.model_fields = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'length': FieldInfo(annotation=float, required=True), 'rotation': FieldInfo(annotation=float, required=True), 'width': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "RectangularShape.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props.html#get_stackup_props",
        "title": "get_stackup_props",
        "section": "get_stackup_props",
        "text": "Get the stackup properties from a CCA.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nObject containing the properties of the stackup.\nStackupProperties\nget_stackup_props\nStackupProperties\nStackupProperties"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_stackup_props.html#ansys.sherlock.core.stackup.Stackup.get_stackup_props",
        "title": "get_stackup_props > get_stackup_props > get_stackup_props",
        "section": "get_stackup_props > get_stackup_props",
        "text": "Stackup.get_stackup_props(project, cca_name)\n\nGet the stackup properties from a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\nStackupProperties\n\nObject containing the properties of the stackup.\n\nReturn type\n\nStackupProperties\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> stackup_props = sherlock.stackup.get_stackup_props(\n       project=\"Tutorial\",\n       cca_name=\"Main Board\"\n    )\n>>> print(f\"{stackup_props}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props.html#update_pcb_modeling_props",
        "title": "update_pcb_modeling_props",
        "section": "update_pcb_modeling_props",
        "text": "Update FEA PCB Modeling properties for one or more CCAs.\nAvailable Since: 2023R2\nName of the Sherlock project.\nNames of the CCAs to be used for the analysis.\nElements consisting of the following properties:\nType of analysis applied.\nThe PCB modeling mesh type.\nIndicates if modeling regions are enabled.\nThe PCB modeling PCB model type.\nThe number of PCB materials for Uniform Elements and Layered Elements PCB model\ntypes. Not applicable if PCB model is Uniform or Layered.\nThe element order for PCB elements.\nThe maximum mesh size for PCB elements.\nThe length units for the maximum mesh size.\nThe maximum vertical mesh size for PCB elements.\nThe length units for the maximum vertical mesh size.\nIndicates that the meshing engine should attempt to generate quad-shaped elements\nwhen creating the mesh.\nStatus code of the response. 0 for success.\nint\nupdate_pcb_modeling_props\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props.html#ansys.sherlock.core.analysis.Analysis.update_pcb_modeling_props",
        "title": "update_pcb_modeling_props > update_pcb_modeling_props > update_pcb_modeling_props",
        "section": "update_pcb_modeling_props > update_pcb_modeling_props",
        "text": "Analysis.update_pcb_modeling_props(project, cca_names, analyses)\n\nUpdate FEA PCB Modeling properties for one or more CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_names: list\n\nNames of the CCAs to be used for the analysis.\n\nanalyses: list[tuple[bool | float | str | UpdatePcbModelingPropsRequestAnalysisType                | UpdatePcbModelingPropsRequestPcbModelType                | UpdatePcbModelingPropsRequestPcbMaterialModel                | ElementOrder, …]]\n\nElements consisting of the following properties:\n\nanalysis_type: UpdatePcbModelingPropsRequestAnalysisType\n\nType of analysis applied.\n\npcb_model_type: UpdatePcbModelingPropsRequestPcbModelType\n\nThe PCB modeling mesh type.\n\nmodeling_region_enabled: bool\n\nIndicates if modeling regions are enabled.\n\npcb_material_model: UpdatePcbModelingPropsRequestPcbMaterialModel\n\nThe PCB modeling PCB model type.\n\npcb_max_materials: Optional[int]\n\nThe number of PCB materials for Uniform Elements and Layered Elements PCB model\ntypes. Not applicable if PCB model is Uniform or Layered.\n\npcb_elem_order: ElementOrder\n\nThe element order for PCB elements.\n\npcb_max_edge_length: float\n\nThe maximum mesh size for PCB elements.\n\npcb_max_edge_length_units: str\n\nThe length units for the maximum mesh size.\n\npcb_max_vertical: float\n\nThe maximum vertical mesh size for PCB elements.\n\npcb_max_vertical_units: str\n\nThe length units for the maximum vertical mesh size.\n\nquads_preferred: bool\n\nIndicates that the meshing engine should attempt to generate quad-shaped elements\nwhen creating the mesh.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> update_request = SherlockAnalysisService_pb2.UpdatePcbModelingPropsRequest\n>>> sherlock.analysis.update_pcb_modeling_props(\n    \"Tutorial Project\",\n    [\"Main Board\"],\n    [\n        (\n            UpdatePcbModelingPropsRequestAnalysisType.HARMONIC_VIBE,\n            UpdatePcbModelingPropsRequestPcbModelType.BONDED,\n            True,\n            UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM,\n            ElementOrder.SOLID_SHELL,\n            6,\n            \"mm\",\n            3,\n            \"mm\",\n            True,\n        )\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CopyPottingRegionRequest.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod DeletePottingRegionRequest.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.html#ansyssherlockcoretypeslayer_typesrectangularshape",
        "title": "ansys.sherlock.core.types.layer_types.RectangularShape",
        "section": "ansys.sherlock.core.types.layer_types.RectangularShape",
        "text": "Contains the properties for a rectangular shape.\nRectangularShape.construct([_fields_set])\n\nRectangularShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nRectangularShape.dict(*[, include, exclude, ...])\n\nRectangularShape.from_orm(obj)\n\nRectangularShape.json(*[, include, exclude, ...])\n\nRectangularShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nRectangularShape.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nRectangularShape.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nRectangularShape.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nRectangularShape.model_json_schema([...])\nGenerates a JSON schema for a model class.\nRectangularShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nRectangularShape.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nRectangularShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nRectangularShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nRectangularShape.model_validate_json(...[, ...])\n!!! abstract \"Usage Documentation\"\nRectangularShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nRectangularShape.parse_file(path, *[, ...])\n\nRectangularShape.parse_obj(obj)\n\nRectangularShape.parse_raw(b, *[, ...])\n\nRectangularShape.schema([by_alias, ref_template])\n\nRectangularShape.schema_json(*[, by_alias, ...])\n\nRectangularShape.update_forward_refs(**localns)\n\nRectangularShape.validate(value)\n\nRectangularShape.model_computed_fields\n\nRectangularShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nRectangularShape.model_extra\nGet extra fields set during validation.\nRectangularShape.model_fields\n\nRectangularShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nRectangularShape.length\nfloat\nRectangularShape.width\nfloat\nRectangularShape.center_x\nfloat\nRectangularShape.center_y\nfloat\nRectangularShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.RectangularShape\nRectangularShape.construct\nRectangularShape.copy\nRectangularShape.dict\nRectangularShape.from_orm\nRectangularShape.json\nRectangularShape.model_construct\nRectangularShape.model_copy\nRectangularShape.model_dump\nRectangularShape.model_dump_json\nRectangularShape.model_json_schema\nRectangularShape.model_parametrized_name\nRectangularShape.model_post_init\nRectangularShape.model_rebuild\nRectangularShape.model_validate\nRectangularShape.model_validate_json\nRectangularShape.model_validate_strings\nRectangularShape.parse_file\nRectangularShape.parse_obj\nRectangularShape.parse_raw\nRectangularShape.schema\nRectangularShape.schema_json\nRectangularShape.update_forward_refs\nRectangularShape.validate\nRectangularShape.model_computed_fields\nRectangularShape.model_config\nRectangularShape.model_extra\nRectangularShape.model_fields\nRectangularShape.model_fields_set\nRectangularShape.length\nRectangularShape.width\nRectangularShape.center_x\nRectangularShape.center_y\nRectangularShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.html#ansys.sherlock.core.types.layer_types.RectangularShape",
        "title": "ansys.sherlock.core.types.layer_types.RectangularShape > ansys.sherlock.core.types.layer_types.RectangularShape > RectangularShape",
        "section": "ansys.sherlock.core.types.layer_types.RectangularShape > RectangularShape",
        "text": "class ansys.sherlock.core.types.layer_types.RectangularShape(**data)\n\nContains the properties for a rectangular shape.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nRectangularShape.construct([_fields_set])\n\n\n\nRectangularShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nRectangularShape.dict(*[, include, exclude, ...])\n\n\n\nRectangularShape.from_orm(obj)\n\n\n\nRectangularShape.json(*[, include, exclude, ...])\n\n\n\nRectangularShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nRectangularShape.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nRectangularShape.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRectangularShape.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRectangularShape.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nRectangularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nRectangularShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nRectangularShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nRectangularShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nRectangularShape.model_validate_json(...[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nRectangularShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nRectangularShape.parse_file(path, *[, ...])\n\n\n\nRectangularShape.parse_obj(obj)\n\n\n\nRectangularShape.parse_raw(b, *[, ...])\n\n\n\nRectangularShape.schema([by_alias, ref_template])\n\n\n\nRectangularShape.schema_json(*[, by_alias, ...])\n\n\n\nRectangularShape.update_forward_refs(**localns)\n\n\n\nRectangularShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nRectangularShape.model_computed_fields\n\n\n\nRectangularShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nRectangularShape.model_extra\n\nGet extra fields set during validation.\n\nRectangularShape.model_fields\n\n\n\nRectangularShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nRectangularShape.length\n\nfloat\n\nRectangularShape.width\n\nfloat\n\nRectangularShape.center_x\n\nfloat\n\nRectangularShape.center_y\n\nfloat\n\nRectangularShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CsvExcelOutlineFile.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.header_row_count.html#header_row_count",
        "title": "header_row_count",
        "section": "header_row_count",
        "text": "Number of rows before the column header in the file\nheader_row_count\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.header_row_count.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.header_row_count",
        "title": "header_row_count > header_row_count > header_row_count",
        "section": "header_row_count > header_row_count",
        "text": "CsvExcelOutlineFile.header_row_count: int\n\nNumber of rows before the column header in the file\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column.html#temperature_column",
        "title": "temperature_column",
        "section": "temperature_column",
        "text": "temperature_column\nstr\ntemperature_column"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column.html#ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_column",
        "title": "temperature_column > temperature_column > temperature_column",
        "section": "temperature_column > temperature_column",
        "text": "CsvExcelFile.temperature_column\n\ntemperature_column\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_copy.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CsvExcelOutlineFile.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_config.html#ansys.sherlock.core.types.project_types.OutlineFile.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "OutlineFile.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PCBShape.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#run-advanced-analysis",
        "title": "Run Advanced Analysis",
        "section": "Run Advanced Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand run various analyses on a project, including part validation, natural frequency,\nthermal derating, and more.\nRun Advanced Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#description",
        "title": "Run Advanced Analysis > Description",
        "section": "Description",
        "text": "Sherlock provides the ability to perform various types of analyses on a project.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project into Sherlock.\n- Run several types of analyses, such as part validation, mechanical shock, harmonic vibration,\nand others.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#connect-to-sherlock",
        "title": "Run Advanced Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#delete-project",
        "title": "Run Advanced Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#import-tutorial-project",
        "title": "Run Advanced Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_analysis",
        "href": "examples/gallery_examples/04-analyses/run_analysis.html#run-multiple-analyses",
        "title": "Run Advanced Analysis > Run Multiple Analyses",
        "section": "Run Multiple Analyses",
        "text": "Run various types of analyses on the “Main Board” in the “Tutorial Project”.\nDownload Jupyter notebook: run_analysis.ipynb\nDownload Python source code: run_analysis.py\nDownload zipped: run_analysis.zip\nRun Multiple Analyses\nDownload Jupyter notebook: run_analysis.ipynb\nDownload Python source code: run_analysis.py\nDownload zipped: run_analysis.zip"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#run-random-vibration-analysis",
        "title": "Run Random Vibration Analysis",
        "section": "Run Random Vibration Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nadd strain maps, and run random vibration analysis.\nRun Random Vibration Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#description",
        "title": "Run Random Vibration Analysis > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform random vibration analysis using strain maps.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Add a strain map file to the project.\n- Configure the properties for random vibration analysis.\n- Execute random vibration analysis based on the configured properties.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#connect-to-sherlock",
        "title": "Run Random Vibration Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#delete-project",
        "title": "Run Random Vibration Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#import-tutorial-project",
        "title": "Run Random Vibration Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#add-strain-map",
        "title": "Run Random Vibration Analysis > Add Strain Map",
        "section": "Add Strain Map",
        "text": "Add a strain map to the project.\nAdd Strain Map"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#update-random-vibration-properties",
        "title": "Run Random Vibration Analysis > Update Random Vibration Properties",
        "section": "Update Random Vibration Properties",
        "text": "Configure properties for random vibration analysis using strain maps.\nUpdate Random Vibration Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_random_vibe_strain_map_analysis.html#run-random-vibration-analysis",
        "title": "Run Random Vibration Analysis",
        "section": "Run Random Vibration Analysis",
        "text": "Run the random vibration analysis, including specified parameters.\nDownload Jupyter notebook: run_random_vibe_strain_map_analysis.ipynb\nDownload Python source code: run_random_vibe_strain_map_analysis.py\nDownload zipped: run_random_vibe_strain_map_analysis.zip\nRun Random Vibration Analysis\nDownload Jupyter notebook: run_random_vibe_strain_map_analysis.ipynb\nDownload Python source code: run_random_vibe_strain_map_analysis.py\nDownload zipped: run_random_vibe_strain_map_analysis.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionDeleteData.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CopyPottingRegionRequest.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info.html#get_sherlock_info",
        "title": "get_sherlock_info",
        "section": "get_sherlock_info",
        "text": "Get server Sherlock version.\nSherlock information containing\nreleaseVersion, defaultProjectDir and isSingleProjectMode flag\nstr\nget_sherlock_info\nSherlockInfoResponse\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_sherlock_info.html#ansys.sherlock.core.common.Common.get_sherlock_info",
        "title": "get_sherlock_info > get_sherlock_info > get_sherlock_info",
        "section": "get_sherlock_info > get_sherlock_info",
        "text": "Common.get_sherlock_info()\n\nGet server Sherlock version.\n\nReturns\n\n:\n\n\n\nSherlockInfoResponse\n\nSherlock information containing\nreleaseVersion, defaultProjectDir and isSingleProjectMode flag\n\nReturn type\n\nstr\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> release_version = sherlock.common.get_sherlock_info().releaseVersion\n>>> default_dir = sherlock.common.get_sherlock_info().defaultProjectDir\n>>> is_single_project = sherlock.common.get_sherlock_info().isSingleProjectMode\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props.html#update_harmonic_vibe_props",
        "title": "update_harmonic_vibe_props",
        "section": "update_harmonic_vibe_props",
        "text": "Update properties for a harmonic vibe analysis.\nAvailable Since: 2024R1\nName of the Sherlock project.\nHarmonic vibe properties for a CCA consisting of these properties:\nName of the CCA.\nModel source. The default is None.\nNumber of harmonic vibe result layers to generate. The default is None.\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nTemperature. The default is None.\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nIndicates if harmonic results outside analysis event range are included.\nThis parameter is not used for NX Nastran analysis.\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\nNatural frequency for strain map analysis.\nStatus code of the response. 0 for success.\nint\nupdate_harmonic_vibe_props\nNone\nNone\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props.html#ansys.sherlock.core.analysis.Analysis.update_harmonic_vibe_props",
        "title": "update_harmonic_vibe_props > update_harmonic_vibe_props > update_harmonic_vibe_props",
        "section": "update_harmonic_vibe_props > update_harmonic_vibe_props",
        "text": "Analysis.update_harmonic_vibe_props(project, harmonic_vibe_properties)\n\nUpdate properties for a harmonic vibe analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nharmonic_vibe_properties: list[dict[str, bool | int | float | str]]\n\nHarmonic vibe properties for a CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource\n\nModel source. The default is None.\n\nharmonic_vibe_count: int\n\nNumber of harmonic vibe result layers to generate. The default is None.\n\nharmonic_vibe_damping: str\n\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nfilter_by_event_frequency: bool\n\nIndicates if harmonic results outside analysis event range are included.\nThis parameter is not used for NX Nastran analysis.\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nreuse_modal_analysis: bool\n\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\n\nstrain_map_natural_freq: double\n\nNatural frequency for strain map analysis.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_harmonic_vibe_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"model_source\": ModelSource.GENERATED,\n        \"harmonic_vibe_count\": 2,\n        \"harmonic_vibe_damping\": \"0.01, 0.05\",\n        \"part_validation_enabled\": False,\n        \"require_material_assignment_enabled\": False,\n        \"analysis_temp\": 20,\n        \"analysis_temp_units\": \"C\",\n        \"force_model_rebuild\": \"AUTO\",\n        \"filter_by_event_frequency\": False,\n        \"natural_freq_min\": 10,\n        \"natural_freq_min_units\": \"Hz\",\n        \"natural_freq_max\": 1000,\n        \"natural_freq_max_units\": \"KHz\",\n        \"reuse_modal_analysis\": True,\n        \"strain_map_natural_freq\": 100.13,\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.check",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.check.html#check",
        "title": "check",
        "section": "check",
        "text": "Perform a health check on the gRPC connection.\nWhether the Sherlock client is connected via gRPC.\nbool\ncheck\nbool"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.check",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.check.html#ansys.sherlock.core.common.Common.check",
        "title": "check > check > check",
        "section": "check > check",
        "text": "Common.check()\n\nPerform a health check on the gRPC connection.\n\nReturns\n\n:\n\n\n\nbool\n\nWhether the Sherlock client is connected via gRPC.\n\nReturn type\n\nbool\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate_non_empty_cca_names",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate_non_empty_cca_names.html#validate_non_empty_cca_names",
        "title": "validate_non_empty_cca_names",
        "section": "validate_non_empty_cca_names",
        "text": "Validate cca_names contains at least one name and none are empty.\nvalidate_non_empty_cca_names"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate_non_empty_cca_names",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate_non_empty_cca_names.html#ansys.sherlock.core.types.project_types.OutlineFile.validate_non_empty_cca_names",
        "title": "validate_non_empty_cca_names > validate_non_empty_cca_names > validate_non_empty_cca_names",
        "section": "validate_non_empty_cca_names > validate_non_empty_cca_names",
        "text": "classmethod OutlineFile.validate_non_empty_cca_names(value, info)\n\nValidate cca_names contains at least one name and none are empty.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionUpdateData.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "DeletePottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegionCopyData.model_fields = {'cca_name': FieldInfo(annotation=str, required=True), 'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'copy_potting_id': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "UpdatePottingRegionRequest.model_fields = {'project': FieldInfo(annotation=str, required=True), 'update_potting_regions': FieldInfo(annotation=list[PottingRegionUpdateData], required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PolygonalShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.list_layers",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.list_layers.html#list_layers",
        "title": "list_layers",
        "section": "list_layers",
        "text": "List all layers as seen in the Layer Viewer for a specific project CCA.\nName of the Sherlock project.\nName of the CCA.\nThe layers as seen in the Layer Viewer for the given project CCA.\nEach dictionary should contain:\n“layer_folder”: str, name of layer_folder enum.\n“layers”: list, list of names of layers under this folder\nlist\nlist_layers\npython:str\npython:list\npython:dict\npython:str\npython:list\nlist"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.list_layers",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.list_layers.html#ansys.sherlock.core.layer.Layer.list_layers",
        "title": "list_layers > list_layers > list_layers",
        "section": "list_layers > list_layers",
        "text": "Layer.list_layers(project, cca_name)\n\nList all layers as seen in the Layer Viewer for a specific project CCA.\n\nParameters\n\nproject\n\npython:str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\nlayer_infos: python:list[python:dict[python:str, python:list]]\n\nThe layers as seen in the Layer Viewer for the given project CCA.\nEach dictionary should contain:\n\n“layer_folder”: str, name of layer_folder enum.\n\n“layers”: list, list of names of layers under this folder\n\nReturn type\n\nlist\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\"\n>>> )\n>>> sherlock.layer.list_layers(\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionUpdateData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionUpdateData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props.html#update_part_list_validation_analysis_props",
        "title": "update_part_list_validation_analysis_props",
        "section": "update_part_list_validation_analysis_props",
        "text": "Update properties for a Part List Validation analysis.\nName of the Sherlock project.\nPart List Validation analysis properties for each CCA consisting of these properties:\nName of the CCA.\nWhether to use AVL.\nWhether to use the wizard.\nWhether to check confirmed properties.\nWhether to check part numbers.\nMatching type.\nWhether to require an internal part number.\nWhether to require an approved description.\nWhether to require an approved manufacturer.\nStatus code of the response. 0 for success.\nint\nupdate_part_list_validation_analysis_props\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props.html#ansys.sherlock.core.analysis.Analysis.update_part_list_validation_analysis_props",
        "title": "update_part_list_validation_analysis_props > update_part_list_validation_analysis_props > update_part_list_validation_analysis_props",
        "section": "update_part_list_validation_analysis_props > update_part_list_validation_analysis_props",
        "text": "Analysis.update_part_list_validation_analysis_props(project, properties_per_cca)\n\nUpdate properties for a Part List Validation analysis.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nproperties_per_cca: list[dict[str, bool | str]]\n\nPart List Validation analysis properties for each CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nprocess_use_avl: bool\n\nWhether to use AVL.\n\nprocess_use_wizard: bool\n\nWhether to use the wizard.\n\nprocess_check_confirmed_properties: bool\n\nWhether to check confirmed properties.\n\nprocess_check_part_numbers: bool\n\nWhether to check part numbers.\n\nmatching_mode: str\n\nMatching type.\n\navl_require_internal_part_number: bool\n\nWhether to require an internal part number.\n\navl_require_approved_description: bool\n\nWhether to require an approved description.\n\navl_require_approved_manufacturer: bool\n\nWhether to require an approved manufacturer.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_part_list_validation_analysis_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"process_use_avl\": True,\n        \"process_use_wizard\": False,\n        \"process_check_confirmed_properties\": True,\n        \"process_check_part_numbers\": True,\n        \"matching_mode\": \"Part\",\n        \"avl_require_internal_part_number\": True,\n        \"avl_require_approved_description\": False,\n        \"avl_require_approved_manufacturer\": True,\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the project containing the potting region(s) to be copied.\nproject\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "CopyPottingRegionRequest.project: str\n\nName of the project containing the potting region(s) to be copied.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_parametrized_name.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod GerberOutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields.html#get_natural_frequency_input_fields",
        "title": "get_natural_frequency_input_fields",
        "section": "get_natural_frequency_input_fields",
        "text": "Get natural frequency property fields based on the user configuration.\nAvailable Since: 2023R2\nMatural frequency property fields based on the user configuration.\nlist[str]\nget_natural_frequency_input_fields\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_natural_frequency_input_fields",
        "title": "get_natural_frequency_input_fields > get_natural_frequency_input_fields > get_natural_frequency_input_fields",
        "section": "get_natural_frequency_input_fields > get_natural_frequency_input_fields",
        "text": "Analysis.get_natural_frequency_input_fields()\n\nGet natural frequency property fields based on the user configuration.\n\nAvailable Since: 2023R2\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nMatural frequency property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n        \"ODB++ Tutorial.tgz\",\n        True,\n        True,\n        True,\n        True,\n        project=\"Test\",\n        cca_name=\"Card\",\n    )\n    >>> sherlock.analysis.get_natural_frequency_input_fields()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.update_forward_refs.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod GerberOutlineFile.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegion.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegion.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_config.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PolygonalShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionCopyData.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_raw.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod SlotShape.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_config.html#ansys.sherlock.core.types.layer_types.PCBShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PCBShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.CircularShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CircularShape.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_raw.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod CircularShape.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod DeletePottingRegionRequest.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#update-laminate-layer-properties",
        "title": "Update Laminate Layer Properties",
        "section": "Update Laminate Layer Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update laminate layer properties.\nUpdate Laminate Layer Properties"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#description",
        "title": "Update Laminate Layer Properties > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating laminate layer\nproperties for printed circuit boards (PCBs).\nThis script demonstrates how to:\nConnect to the Sherlock service.\nImport a project.\nUpdate laminate layer properties.\nThe updated properties can be used for further design validation and optimization.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#connect-to-sherlock",
        "title": "Update Laminate Layer Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#delete-project",
        "title": "Update Laminate Layer Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#import-tutorial-project",
        "title": "Update Laminate Layer Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_laminate_layer",
        "href": "examples/gallery_examples/01-project-configuration/update_laminate_layer.html#update-laminate-layer-properties",
        "title": "Update Laminate Layer Properties",
        "section": "Update Laminate Layer Properties",
        "text": "Update the laminate layer properties for the “Main Board” of the “Test” project.\nDownload Jupyter notebook: update_laminate_layer.ipynb\nDownload Python source code: update_laminate_layer.py\nDownload zipped: update_laminate_layer.zip\nUpdate Laminate Layer Properties\nDownload Jupyter notebook: update_laminate_layer.ipynb\nDownload Python source code: update_laminate_layer.py\nDownload zipped: update_laminate_layer.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionUpdateData.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_computed_fields.html#ansys.sherlock.core.types.project_types.OutlineFile.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "OutlineFile.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/index",
        "href": "api/index.html#api-reference",
        "title": "API reference",
        "section": "API reference",
        "text": "This section describes PySherlock modules and their classes, methods, and functions.\nUse the search feature or click links to view API documentation.\nansys.sherlock.core.analysis\nModule containing all analysis capabilities.\nansys.sherlock.core.types.analysis_types\nModule containing types for the Analysis Service.\nansys.sherlock.core.common\nModule for running the gRPC APIs in the Sherlock Common service.\nansys.sherlock.core.types.common_types\nModule containing types for the Common Service.\nansys.sherlock.core.launcher\nModule for launching Sherlock locally or connecting to a local instance with gRPC.\nansys.sherlock.core.layer\nModule containing all layer management capabilities.\nansys.sherlock.core.types.layer_types\nModule containing types for the Layer Service.\nansys.sherlock.core.lifecycle\nModule containing all life cycle management capabilities.\nansys.sherlock.core.model\nModule containing all model generation capabilities.\nansys.sherlock.core.parts\nModule containing all parts management capabilities.\nansys.sherlock.core.types.parts_types\nModule containing types for the Parts Service.\nansys.sherlock.core.project\nModule containing all project management capabilities.\nansys.sherlock.core.types.project_types\nModule containing types for the Project Service.\nansys.sherlock.core.stackup\nModule containing all stackup management capabilities.\nAPI reference\nansys.sherlock.core.analysis\nansys.sherlock.core.types.analysis_types\nansys.sherlock.core.common\nansys.sherlock.core.types.common_types\nansys.sherlock.core.launcher\nansys.sherlock.core.layer\nansys.sherlock.core.types.layer_types\nansys.sherlock.core.lifecycle\nansys.sherlock.core.model\nansys.sherlock.core.parts\nansys.sherlock.core.types.parts_types\nansys.sherlock.core.project\nansys.sherlock.core.types.project_types\nansys.sherlock.core.stackup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PolygonalShape.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#parts-types",
        "title": "Parts Types",
        "section": "Parts Types",
        "text": "Module containing types for the Parts Service.\nParts Types"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#constants",
        "title": "Parts Types > Constants",
        "section": "Constants",
        "text": "Constants for AVLDescription in the Update Parts List from AVL request.\nAssignApprovedDescription\nDoNotChangeDescription\nConstants for AVLPartNum in the Update Parts List from AVL request.\nAssignInternalPartNum\nAssignVendorAndPartNum\nDoNotChangeVendorOrPartNum\nConstants for Duplication Mode in Update Parts List and Update Parts from AVL request.\nError\nFirst\nIgnore\nDEPRECATED. Constants for Matching Mode in Update Parts List & Update Parts from AVL.\nBoth\nPart\nConstants"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription",
        "title": "Parts Types > Constants > AVLDescription",
        "section": "Constants > AVLDescription",
        "text": "class ansys.sherlock.core.types.parts_types.AVLDescription\n\nConstants for AVLDescription in the Update Parts List from AVL request.\n\n!! processed by numpydoc !!\n\n\n\nASSIGN_APPROVED_DESCRIPTION = 0\n\nAssignApprovedDescription\n\n!! processed by numpydoc !!\n\n\n\nDO_NOT_CHANGE_DESCRIPTION = 1\n\nDoNotChangeDescription\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription.ASSIGN_APPROVED_DESCRIPTION",
        "title": "Parts Types > Constants > ASSIGN_APPROVED_DESCRIPTION",
        "section": "Constants > ASSIGN_APPROVED_DESCRIPTION",
        "text": "ASSIGN_APPROVED_DESCRIPTION = 0\n\nAssignApprovedDescription\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLDescription.DO_NOT_CHANGE_DESCRIPTION",
        "title": "Parts Types > Constants > DO_NOT_CHANGE_DESCRIPTION",
        "section": "Constants > DO_NOT_CHANGE_DESCRIPTION",
        "text": "DO_NOT_CHANGE_DESCRIPTION = 1\n\nDoNotChangeDescription\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum",
        "title": "Parts Types > Constants > AVLPartNum",
        "section": "Constants > AVLPartNum",
        "text": "class ansys.sherlock.core.types.parts_types.AVLPartNum\n\nConstants for AVLPartNum in the Update Parts List from AVL request.\n\n!! processed by numpydoc !!\n\n\n\nASSIGN_INTERNAL_PART_NUM = 0\n\nAssignInternalPartNum\n\n!! processed by numpydoc !!\n\n\n\nASSIGN_VENDOR_AND_PART_NUM = 1\n\nAssignVendorAndPartNum\n\n!! processed by numpydoc !!\n\n\n\nDO_NOT_CHANGE_VENDOR_OR_PART_NUM = 2\n\nDoNotChangeVendorOrPartNum\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.ASSIGN_INTERNAL_PART_NUM",
        "title": "Parts Types > Constants > ASSIGN_INTERNAL_PART_NUM",
        "section": "Constants > ASSIGN_INTERNAL_PART_NUM",
        "text": "ASSIGN_INTERNAL_PART_NUM = 0\n\nAssignInternalPartNum\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.ASSIGN_VENDOR_AND_PART_NUM",
        "title": "Parts Types > Constants > ASSIGN_VENDOR_AND_PART_NUM",
        "section": "Constants > ASSIGN_VENDOR_AND_PART_NUM",
        "text": "ASSIGN_VENDOR_AND_PART_NUM = 1\n\nAssignVendorAndPartNum\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.AVLPartNum.DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "title": "Parts Types > Constants > DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "section": "Constants > DO_NOT_CHANGE_VENDOR_OR_PART_NUM",
        "text": "DO_NOT_CHANGE_VENDOR_OR_PART_NUM = 2\n\nDoNotChangeVendorOrPartNum\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode",
        "title": "Parts Types > Constants > PartsListSearchDuplicationMode",
        "section": "Constants > PartsListSearchDuplicationMode",
        "text": "class ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode\n\nConstants for Duplication Mode in Update Parts List and Update Parts from AVL request.\n\n!! processed by numpydoc !!\n\n\n\nERROR = 1\n\nError\n\n!! processed by numpydoc !!\n\n\n\nFIRST = 0\n\nFirst\n\n!! processed by numpydoc !!\n\n\n\nIGNORE = 2\n\nIgnore\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.ERROR",
        "title": "Parts Types > Constants > ERROR",
        "section": "Constants > ERROR",
        "text": "ERROR = 1\n\nError\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.FIRST",
        "title": "Parts Types > Constants > FIRST",
        "section": "Constants > FIRST",
        "text": "FIRST = 0\n\nFirst\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchDuplicationMode.IGNORE",
        "title": "Parts Types > Constants > IGNORE",
        "section": "Constants > IGNORE",
        "text": "IGNORE = 2\n\nIgnore\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode",
        "title": "Parts Types > Constants > PartsListSearchMatchingMode",
        "section": "Constants > PartsListSearchMatchingMode",
        "text": "class ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode\n\nDEPRECATED. Constants for Matching Mode in Update Parts List & Update Parts from AVL.\n\n!! processed by numpydoc !!\n\n\n\nBOTH = 0\n\nBoth\n\n!! processed by numpydoc !!\n\n\n\nPART = 1\n\nPart\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode.BOTH",
        "title": "Parts Types > Constants > BOTH",
        "section": "Constants > BOTH",
        "text": "BOTH = 0\n\nBoth\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartsListSearchMatchingMode.PART",
        "title": "Parts Types > Constants > PART",
        "section": "Constants > PART",
        "text": "PART = 1\n\nPart\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#classes",
        "title": "Parts Types > Classes",
        "section": "Classes",
        "text": "Part Location property values.\nboard side - \"TOP\" or \"BOTTOM\"\nunits for location coordinates\nmirrored - True or False\nreference designator\nrotation (in degrees)\nx coordinate\ny coordinate\nRequest for getting properties of parts in the parts list of a CCA.\nName of the CCA with the parts.\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nName of the Sherlock project.\nReference designators of the parts to retrieve properties for. Use None to get all parts.\nValidate string fields listed.\nClasses\n\"TOP\"\n\"BOTTOM\"\nTrue\nFalse\nstr\nstr\nOptional\nList\nstr"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation",
        "title": "Parts Types > Classes > PartLocation",
        "section": "Classes > PartLocation",
        "text": "class ansys.sherlock.core.types.parts_types.PartLocation(location)\n\nPart Location property values.\n\n!! processed by numpydoc !!\n\n\n\nboard_side\n\nboard side - \"TOP\" or \"BOTTOM\"\n\n!! processed by numpydoc !!\n\n\n\nlocation_units\n\nunits for location coordinates\n\n!! processed by numpydoc !!\n\n\n\nmirrored\n\nmirrored - True or False\n\n!! processed by numpydoc !!\n\n\n\nref_des\n\nreference designator\n\n!! processed by numpydoc !!\n\n\n\nrotation(in degrees)\n\nrotation (in degrees)\n\n!! processed by numpydoc !!\n\n\n\nx\n\nx coordinate\n\n!! processed by numpydoc !!\n\n\n\ny\n\ny coordinate\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.board_side",
        "title": "Parts Types > Classes > board_side",
        "section": "Classes > board_side",
        "text": "board_side\n\nboard side - \"TOP\" or \"BOTTOM\"\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.location_units",
        "title": "Parts Types > Classes > location_units",
        "section": "Classes > location_units",
        "text": "location_units\n\nunits for location coordinates\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.mirrored",
        "title": "Parts Types > Classes > mirrored",
        "section": "Classes > mirrored",
        "text": "mirrored\n\nmirrored - True or False\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.ref_des",
        "title": "Parts Types > Classes > ref_des",
        "section": "Classes > ref_des",
        "text": "ref_des\n\nreference designator\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.rotation",
        "title": "Parts Types > Classes > rotation",
        "section": "Classes > rotation",
        "text": "rotation(in degrees)\n\nrotation (in degrees)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.x",
        "title": "Parts Types > Classes > x",
        "section": "Classes > x",
        "text": "x\n\nx coordinate\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.PartLocation.y",
        "title": "Parts Types > Classes > y",
        "section": "Classes > y",
        "text": "y\n\ny coordinate\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest",
        "title": "Parts Types > Classes > GetPartsListPropertiesRequest",
        "section": "Classes > GetPartsListPropertiesRequest",
        "text": "class ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest(**data)\n\nRequest for getting properties of parts in the parts list of a CCA.\n\n!! processed by numpydoc !!\n\n\n\ncca_name: str\n\nName of the CCA with the parts.\n\n!! processed by numpydoc !!\n\n\n\nmodel_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!\n\n\n\nproject: str\n\nName of the Sherlock project.\n\n!! processed by numpydoc !!\n\n\n\nreference_designators: Optional[List[str]]\n\nReference designators of the parts to retrieve properties for. Use None to get all parts.\n\n!! processed by numpydoc !!\n\n\n\nclassmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest.cca_name",
        "title": "Parts Types > Classes > cca_name",
        "section": "Classes > cca_name",
        "text": "cca_name: str\n\nName of the CCA with the parts.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest.model_config",
        "title": "Parts Types > Classes > model_config",
        "section": "Classes > model_config",
        "text": "model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest.project",
        "title": "Parts Types > Classes > project",
        "section": "Classes > project",
        "text": "project: str\n\nName of the Sherlock project.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest.reference_designators",
        "title": "Parts Types > Classes > reference_designators",
        "section": "Classes > reference_designators",
        "text": "reference_designators: Optional[List[str]]\n\nReference designators of the parts to retrieve properties for. Use None to get all parts.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts_types",
        "href": "api/parts_types.html#ansys.sherlock.core.types.parts_types.GetPartsListPropertiesRequest.str_validation",
        "title": "Parts Types > Classes > str_validation",
        "section": "Classes > str_validation",
        "text": "classmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.dict.html#ansys.sherlock.core.types.layer_types.PCBShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PCBShape.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.validate.html#ansys.sherlock.core.types.layer_types.RectangularShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod RectangularShape.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#import-parts-list",
        "title": "Import Parts List",
        "section": "Import Parts List",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand import parts lists.\nImport Parts List"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#description",
        "title": "Import Parts List > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as importing ODB++\narchives and parts lists.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Import parts lists with different settings.\nThese functionalities enable users to prepare projects with ECAD data and associated parts lists\nfor further analysis.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#connect-to-sherlock",
        "title": "Import Parts List > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#delete-project",
        "title": "Import Parts List > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#import-tutorial-project",
        "title": "Import Parts List > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_parts_list",
        "href": "examples/gallery_examples/02-importing/import_parts_list.html#import-parts-list",
        "title": "Import Parts List",
        "section": "Import Parts List",
        "text": "Import parts list for the “Test” project and “Card” CCA.\nDownload Jupyter notebook: import_parts_list.ipynb\nDownload Python source code: import_parts_list.py\nDownload zipped: import_parts_list.zip\nImport Parts List\nDownload Jupyter notebook: import_parts_list.ipynb\nDownload Python source code: import_parts_list.py\nDownload zipped: import_parts_list.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_computed_fields.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CsvExcelOutlineFile.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses.html#load_shock_profile_pulses",
        "title": "load_shock_profile_pulses",
        "section": "load_shock_profile_pulses",
        "text": "Load shock profile pulses from a .csv .dat file.\nAvailable Since: 2021R1\nName of the Sherlock project\nName of the lifecycle phase to add this event to.\nName of the random vibe event.\nPath for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_shock_profile_pulses\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses.html#ansys.sherlock.core.lifecycle.Lifecycle.load_shock_profile_pulses",
        "title": "load_shock_profile_pulses > load_shock_profile_pulses > load_shock_profile_pulses",
        "section": "load_shock_profile_pulses > load_shock_profile_pulses",
        "text": "Lifecycle.load_shock_profile_pulses(project, phase_name, event_name, file_path)\n\nLoad shock profile pulses from a .csv .dat file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nphase_name: str\n\nName of the lifecycle phase to add this event to.\n\nevent_name: str\n\nName of the random vibe event.\n\nfile_path: str\n\nPath for thermal profile .dat or .csv file\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.lifecycle.load_shock_profile_pulses(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Shock Event\",\n        file_path=\"Test_Profile.dat\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CopyPottingRegionRequest.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.html#ansyssherlockcoretypesproject_typesicepakfile",
        "title": "ansys.sherlock.core.types.project_types.IcepakFile",
        "section": "ansys.sherlock.core.types.project_types.IcepakFile",
        "text": "Contains the properties for a thermal map Icepak file.\nIcepakFile.temperature_offset\ntemperature_offset\nIcepakFile.temperature_offset_units\ntemperature_offset_units\nansys.sherlock.core.types.project_types.IcepakFile\nIcepakFile.temperature_offset\nIcepakFile.temperature_offset_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.html#ansys.sherlock.core.types.project_types.IcepakFile",
        "title": "ansys.sherlock.core.types.project_types.IcepakFile > ansys.sherlock.core.types.project_types.IcepakFile > IcepakFile",
        "section": "ansys.sherlock.core.types.project_types.IcepakFile > IcepakFile",
        "text": "class ansys.sherlock.core.types.project_types.IcepakFile(temperature_offset, temperature_offset_units)\n\nContains the properties for a thermal map Icepak file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nIcepakFile.temperature_offset\n\ntemperature_offset\n\nIcepakFile.temperature_offset_units\n\ntemperature_offset_units\n\n"
    },
    {
        "objectID": "getting_started/launch_sherlock",
        "href": "getting_started/launch_sherlock.html#launch-sherlock",
        "title": "Launch Sherlock",
        "section": "Launch Sherlock",
        "text": "To launch Sherlock, use the launch_sherlock()\nmethod. This method takes an optional port parameter and automatically searches for the\nlatest version of Sherlock installed locally. It then launches the Sherlock gRPC server on\nthe port specified. If a port is not specified, port 9090 is used.\nThis method also launches a Sherlock client connected to the same port and\nreturns a sherlock gRPC connection object that can be used to invoke the APIs from their\nrespective services.\nThis code starts the Sherlock gRPC server on the default port:\nThis code uses the optional port parameter to start the Sherlock gRPC server on port\n11000:\nYou can use the Common.check()\nmethod to perform a health check on the sherlock gRPC connection object:\nLaunch Sherlock\nlaunch_sherlock()\nport\n9090\nsherlock\nport\n11000\nCommon.check()\nsherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness.html#potting_thickness",
        "title": "potting_thickness",
        "section": "potting_thickness",
        "text": "The potting thickness.\npotting_thickness\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_thickness",
        "title": "potting_thickness > potting_thickness > potting_thickness",
        "section": "potting_thickness > potting_thickness",
        "text": "PottingRegion.potting_thickness: float\n\nThe potting thickness.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields_set.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property CsvExcelOutlineFile.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.html#ansyssherlockcoretypeslayer_typespottingregioncopydata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "text": "Data identifying which potting regions to copy.\nPottingRegionCopyData.construct([_fields_set])\n\nPottingRegionCopyData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionCopyData.dict(*[, include, ...])\n\nPottingRegionCopyData.from_orm(obj)\n\nPottingRegionCopyData.json(*[, include, ...])\n\nPottingRegionCopyData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionCopyData.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionCopyData.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionCopyData.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionCopyData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionCopyData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionCopyData.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionCopyData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionCopyData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionCopyData.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nPottingRegionCopyData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionCopyData.parse_file(path, *[, ...])\n\nPottingRegionCopyData.parse_obj(obj)\n\nPottingRegionCopyData.parse_raw(b, *[, ...])\n\nPottingRegionCopyData.schema([by_alias, ...])\n\nPottingRegionCopyData.schema_json(*[, ...])\n\nPottingRegionCopyData.str_validation(value, info)\nValidate string fields listed.\nPottingRegionCopyData.update_forward_refs(...)\n\nPottingRegionCopyData.validate(value)\n\nPottingRegionCopyData.validate_ids()\nValidate that the potting IDs are not the same between the original and copy.\nPottingRegionCopyData.model_computed_fields\n\nPottingRegionCopyData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionCopyData.model_extra\nGet extra fields set during validation.\nPottingRegionCopyData.model_fields\n\nPottingRegionCopyData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionCopyData.cca_name\nName of the cca.\nPottingRegionCopyData.potting_id\nId to assign to the new potting region.\nPottingRegionCopyData.copy_potting_id\nId of the potting region to copy.\nPottingRegionCopyData.center_x\nX coordinate for the center of the new potting region.\nPottingRegionCopyData.center_y\nY coordinate for the center of the new potting region.\nansys.sherlock.core.types.layer_types.PottingRegionCopyData\nPottingRegionCopyData.construct\nPottingRegionCopyData.copy\nPottingRegionCopyData.dict\nPottingRegionCopyData.from_orm\nPottingRegionCopyData.json\nPottingRegionCopyData.model_construct\nPottingRegionCopyData.model_copy\nPottingRegionCopyData.model_dump\nPottingRegionCopyData.model_dump_json\nPottingRegionCopyData.model_json_schema\nPottingRegionCopyData.model_parametrized_name\nPottingRegionCopyData.model_post_init\nPottingRegionCopyData.model_rebuild\nPottingRegionCopyData.model_validate\nPottingRegionCopyData.model_validate_json\nPottingRegionCopyData.model_validate_strings\nPottingRegionCopyData.parse_file\nPottingRegionCopyData.parse_obj\nPottingRegionCopyData.parse_raw\nPottingRegionCopyData.schema\nPottingRegionCopyData.schema_json\nPottingRegionCopyData.str_validation\nPottingRegionCopyData.update_forward_refs\nPottingRegionCopyData.validate\nPottingRegionCopyData.validate_ids\nPottingRegionCopyData.model_computed_fields\nPottingRegionCopyData.model_config\nPottingRegionCopyData.model_extra\nPottingRegionCopyData.model_fields\nPottingRegionCopyData.model_fields_set\nPottingRegionCopyData.cca_name\nPottingRegionCopyData.potting_id\nPottingRegionCopyData.copy_potting_id\nPottingRegionCopyData.center_x\nPottingRegionCopyData.center_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData > ansys.sherlock.core.types.layer_types.PottingRegionCopyData > PottingRegionCopyData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionCopyData > PottingRegionCopyData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionCopyData(**data)\n\nData identifying which potting regions to copy.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPottingRegionCopyData.construct([_fields_set])\n\n\n\nPottingRegionCopyData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionCopyData.dict(*[, include, ...])\n\n\n\nPottingRegionCopyData.from_orm(obj)\n\n\n\nPottingRegionCopyData.json(*[, include, ...])\n\n\n\nPottingRegionCopyData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionCopyData.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionCopyData.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionCopyData.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionCopyData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionCopyData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionCopyData.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionCopyData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionCopyData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionCopyData.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionCopyData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionCopyData.parse_file(path, *[, ...])\n\n\n\nPottingRegionCopyData.parse_obj(obj)\n\n\n\nPottingRegionCopyData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionCopyData.schema([by_alias, ...])\n\n\n\nPottingRegionCopyData.schema_json(*[, ...])\n\n\n\nPottingRegionCopyData.str_validation(value, info)\n\nValidate string fields listed.\n\nPottingRegionCopyData.update_forward_refs(...)\n\n\n\nPottingRegionCopyData.validate(value)\n\n\n\nPottingRegionCopyData.validate_ids()\n\nValidate that the potting IDs are not the same between the original and copy.\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionCopyData.model_computed_fields\n\n\n\nPottingRegionCopyData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionCopyData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionCopyData.model_fields\n\n\n\nPottingRegionCopyData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionCopyData.cca_name\n\nName of the cca.\n\nPottingRegionCopyData.potting_id\n\nId to assign to the new potting region.\n\nPottingRegionCopyData.copy_potting_id\n\nId of the potting region to copy.\n\nPottingRegionCopyData.center_x\n\nX coordinate for the center of the new potting region.\n\nPottingRegionCopyData.center_y\n\nY coordinate for the center of the new potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_rebuild.html#ansys.sherlock.core.types.project_types.OutlineFile.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod OutlineFile.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.copy.html#ansys.sherlock.core.types.layer_types.RectangularShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "RectangularShape.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#export-aedb",
        "title": "Export AEDB",
        "section": "Export AEDB",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export an AEDB file for a CCA.\nExport AEDB"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#description",
        "title": "Export AEDB > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as exporting an AEDB file for a CCA.\nThis script demonstrates how to:\nConnect to the Sherlock service.\nImport a project.\nExport an AEDB file.\nThe exported AEDB file can be used for further analysis or integration with other software tools.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#connect-to-sherlock",
        "title": "Export AEDB > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#delete-project",
        "title": "Export AEDB > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#import-tutorial-project",
        "title": "Export AEDB > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_aedb",
        "href": "examples/gallery_examples/03-exporting/export_aedb.html#export-aedb-file",
        "title": "Export AEDB > Export AEDB File",
        "section": "Export AEDB File",
        "text": "Export the AEDB file for the “Card” of the “Test” project to the specified path.\nDownload Jupyter notebook: export_aedb.ipynb\nDownload Python source code: export_aedb.py\nDownload zipped: export_aedb.zip\nExport AEDB File\nDownload Jupyter notebook: export_aedb.ipynb\nDownload Python source code: export_aedb.py\nDownload zipped: export_aedb.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "DeletePottingRegionRequest.model_fields = {'potting_region_delete_data': FieldInfo(annotation=list[PottingRegionDeleteData], required=True), 'project': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionCopyData.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids.html#validate_ids",
        "title": "validate_ids",
        "section": "validate_ids",
        "text": "Validate that the potting IDs are not the same between the original and copy.\nSelf\nvalidate_ids\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.validate_ids",
        "title": "validate_ids > validate_ids > validate_ids",
        "section": "validate_ids > validate_ids",
        "text": "PottingRegionCopyData.validate_ids()\n\nValidate that the potting IDs are not the same between the original and copy.\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/sg_execution_times",
        "href": "examples/gallery_examples/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 0 files from examplesgallery_examples:\nExample\nTime\nMem (MB)\nN/A\nN/A\nN/A\nComputation times"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams.html#createexporttracecopperlayerparams",
        "title": "createExportTraceCopperLayerParams",
        "section": "createExportTraceCopperLayerParams",
        "text": "Create a set of parameters to be used to export a single copper layer.\nCreates TraceModelExportParams object that can be added to an export trace model request.\nShould be used in conjunction with exportTraceModel method to export multiple trace layers\nall at once. See example below.\nName of the Sherlock project containing trace layer to export.\nName of the CCA containing the trace layer to export.\nFile path including the file name and extension where the trace layer will be exported.\nValid file extensions: .py, .bdf, .apdl, .cdb, .wbjn, .stp, .step, .tcl, .stl\nNote: relative paths will be relative to sherlock install directory,\nnot the python script.\nName of the copper layer in the given CCA to export.\nDetermines if sherlock should overwrite the output file if it exists.\nDetermines if the output file should automatically display after export.\nDetermines if sherlock should clear the database after export.\nApplicable file extensions: .apdl, and .cdb.\nDetermines if the FEA model id is used or not.\nUnits of the coordinate system. Applicable to .py .wbjn, .stp, .step.\nOptions of difference trace meshing strategies\nDetermines if pre-defined modeling regions will be applied to the exported trace model.\nOptions to select which trace regions to include in the 3D model.\nType of FEA element to be used when modeling each component.\nIndicates the desired element sizes.\nIndicates the units to be used with max_mesh_size.\nMaximum number of holes allowed in a trace before partitioning it into multiple traces.\nDetermines if drill holes will be modeled or not.\nAll drill holes with a diameter < this value will not be modeled.\nUnits associated with drill_hole_min_diameter.\nSpecifies the length of the line segments used to represent round drill holes.\nUnits associated with drill_hole_max_edge_length.\nObject that holds the data for a single export trace request.\nTraceModelExportParams\ncreateExportTraceCopperLayerParams\npython:str\nTraceModelExportParams\nTraceModelExportParams"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams.html#ansys.sherlock.core.model.Model.createExportTraceCopperLayerParams",
        "title": "createExportTraceCopperLayerParams > createExportTraceCopperLayerParams > createExportTraceCopperLayerParams",
        "section": "createExportTraceCopperLayerParams > createExportTraceCopperLayerParams",
        "text": "Model.createExportTraceCopperLayerParams(project_name, cca_name, output_file_path, copper_layer, overwrite=False, display_after=False, clear_FEA_database=False, use_FEA_model_ID=False, coord_units='mm', mesh_type=0, is_modeling_region_enabled=False, trace_output_type=0, element_order=1, max_mesh_size=1.0, max_mesh_size_units='mm', max_holes_per_trace=2, is_drill_hole_modeling_enabled=False, drill_hole_min_diameter=1.0, drill_hole_min_diameter_units='mm', drill_hole_max_edge_length=1.0, drill_hole_max_edge_length_units='mm')\n\nCreate a set of parameters to be used to export a single copper layer.\n\nCreates TraceModelExportParams object that can be added to an export trace model request.\nShould be used in conjunction with exportTraceModel method to export multiple trace layers\nall at once. See example below.\n\nParameters\n\nproject_name: str\n\nName of the Sherlock project containing trace layer to export.\n\ncca_name: str\n\nName of the CCA containing the trace layer to export.\n\noutput_file_path: str\n\nFile path including the file name and extension where the trace layer will be exported.\nValid file extensions: .py, .bdf, .apdl, .cdb, .wbjn, .stp, .step, .tcl, .stl\nNote: relative paths will be relative to sherlock install directory,\nnot the python script.\n\ncopper_layer: str\n\nName of the copper layer in the given CCA to export.\n\noverwrite: bool = False\n\nDetermines if sherlock should overwrite the output file if it exists.\n\ndisplay_after: bool = False\n\nDetermines if the output file should automatically display after export.\n\nclear_FEA_database: bool = False\n\nDetermines if sherlock should clear the database after export.\nApplicable file extensions: .apdl, and .cdb.\n\nuse_FEA_model_ID: bool = False\n\nDetermines if the FEA model id is used or not.\n\ncoord_units: str = “mm”\n\nUnits of the coordinate system. Applicable to .py .wbjn, .stp, .step.\n\nmesh_type: MeshType = MeshType.NONE\n\nOptions of difference trace meshing strategies\n\nis_modeling_region_enabled: bool = False\n\nDetermines if pre-defined modeling regions will be applied to the exported trace model.\n\ntrace_output_type: TraceOutputType = TraceOutputType.ALL_REGIONS\n\nOptions to select which trace regions to include in the 3D model.\n\nelement_order: ElementOrder = ElementOrder.LINEAR\n\nType of FEA element to be used when modeling each component.\n\nmax_mesh_size: float = 1.0\n\nIndicates the desired element sizes.\n\nmax_mesh_size_units: str = “mm”\n\nIndicates the units to be used with max_mesh_size.\n\nmax_holes_per_trace: int = 2\n\nMaximum number of holes allowed in a trace before partitioning it into multiple traces.\n\nis_drill_hole_modeling_enabled: bool = False\n\nDetermines if drill holes will be modeled or not.\n\ndrill_hole_min_diameter: float = 1.0\n\nAll drill holes with a diameter < this value will not be modeled.\n\ndrill_hole_min_diameter_units\n\npython:str = “mm”\n\nUnits associated with drill_hole_min_diameter.\n\ndrill_hole_max_edge_length: float = 1.0\n\nSpecifies the length of the line segments used to represent round drill holes.\n\ndrill_hole_max_edge_length_units: str = “mm”\n\nUnits associated with drill_hole_max_edge_length.\n\nReturns\n\n:\n\n\n\nTraceModelExportParams\n\nObject that holds the data for a single export trace request.\n\nReturn type\n\nTraceModelExportParams\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core.types.analysis_types import ElementOrder\n>>> from ansys.api.sherlock.v0 import SherlockModelService_pb2\n>>> sherlock = launcher.launch_sherlock()\n>>> copper_1_layer = sherlock.model.createExportTraceCopperLayerParams(\n        \"Tutorial Project\",\n        \"Main Board\",\n        \".\\\\outputfile_path.stp\",\n        \"copper-01.odb\",\n        False,\n        False,\n        False,\n        False,\n        \"mm\",\n        SherlockModelService_pb2.MeshType.NONE,\n        False,\n        SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n        ElementOrder.LINEAR,\n        1.0,\n        \"mm\",\n        2,\n        False,\n        1.0,\n        \"mm\",\n        1.0\n    )\n>>> copper_2_layer = sherlock.model.createExportTraceCopperLayerParams(\n        \"Tutorial Project\",\n        \"Main Board\",\n        \".\\\\outputfile_path2.stp\",\n        \"copper-02.odb\",\n        False,\n        False,\n        False,\n        False,\n        \"mm\",\n        SherlockModelService_pb2.MeshType.NONE,\n        False,\n        SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n        ElementOrder.LINEAR,\n        1.0,\n        \"mm\",\n        2,\n        False,\n        1.0,\n        \"mm\",\n        1.0\n    )\n>>> sherlock.model.exportTraceModel([copper_1_layer, copper_2_layer])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegion.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegion.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_trace_model",
        "href": "examples/gallery_examples/03-exporting/export_trace_model.html#sherlock-trace-model-export",
        "title": "Sherlock Trace Model Export",
        "section": "Sherlock Trace Model Export",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\ngenerate export parameters for copper layers, and export a trace model.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including trace model exports.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a tutorial project ZIP archive.\n- Generate copper layer parameters for trace model export.\n- Export a trace model with multiple copper layers.\nSherlock Trace Model Export"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_trace_model",
        "href": "examples/gallery_examples/03-exporting/export_trace_model.html#connect-to-sherlock",
        "title": "Sherlock Trace Model Export > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_trace_model",
        "href": "examples/gallery_examples/03-exporting/export_trace_model.html#delete-project",
        "title": "Sherlock Trace Model Export > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_trace_model",
        "href": "examples/gallery_examples/03-exporting/export_trace_model.html#import-tutorial-project",
        "title": "Sherlock Trace Model Export > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import a sample project ZIP archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_trace_model",
        "href": "examples/gallery_examples/03-exporting/export_trace_model.html#export-trace-model",
        "title": "Sherlock Trace Model Export > Export Trace Model",
        "section": "Export Trace Model",
        "text": "Export a trace model.\nDownload Jupyter notebook: export_trace_model.ipynb\nDownload Python source code: export_trace_model.py\nDownload zipped: export_trace_model.zip\nExport Trace Model\nDownload Jupyter notebook: export_trace_model.ipynb\nDownload Python source code: export_trace_model.py\nDownload zipped: export_trace_model.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CopyPottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod DeletePottingRegionRequest.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials.html#list_solder_materials",
        "title": "list_solder_materials",
        "section": "list_solder_materials",
        "text": "List valid solders.\nAvailable Since: 2024R1\nValid solder names.\nlist[str]\nlist_solder_materials\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_solder_materials.html#ansys.sherlock.core.common.Common.list_solder_materials",
        "title": "list_solder_materials > list_solder_materials > list_solder_materials",
        "section": "list_solder_materials > list_solder_materials",
        "text": "Common.list_solder_materials()\n\nList valid solders.\n\nAvailable Since: 2024R1\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nValid solder names.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.common.list_solder_materials()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.optional_str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.optional_str_validation.html#optional_str_validation",
        "title": "optional_str_validation",
        "section": "optional_str_validation",
        "text": "Allow empty strings for file_comment.\noptional_str_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.optional_str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.optional_str_validation.html#ansys.sherlock.core.types.project_types.OutlineFile.optional_str_validation",
        "title": "optional_str_validation > optional_str_validation > optional_str_validation",
        "section": "optional_str_validation > optional_str_validation",
        "text": "classmethod OutlineFile.optional_str_validation(value, info)\n\nAllow empty strings for file_comment.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#run-strain-map-analysis",
        "title": "Run Strain Map Analysis",
        "section": "Run Strain Map Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nadd strain maps, and run strain map analysis, including harmonic vibration analysis.\nRun Strain Map Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#description",
        "title": "Run Strain Map Analysis > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform strain map analysis, which can be applied in various contexts,\nsuch as harmonic vibration analysis on PCB strain maps.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Add a strain map file to the project.\n- Configure the analysis properties for harmonic vibration.\n- Execute strain map analysis based on the configured properties.\nFor further details, refer to the official documentation on strain map analysis in Sherlock.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#connect-to-sherlock",
        "title": "Run Strain Map Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#delete-project",
        "title": "Run Strain Map Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#import-tutorial-project",
        "title": "Run Strain Map Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#add-strain-map",
        "title": "Run Strain Map Analysis > Add Strain Map",
        "section": "Add Strain Map",
        "text": "Add a strain map to the project.\nAdd Strain Map"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#update-harmonic-vibration-properties",
        "title": "Run Strain Map Analysis > Update Harmonic Vibration Properties",
        "section": "Update Harmonic Vibration Properties",
        "text": "Configure properties for harmonic vibration analysis using strain maps.\nUpdate Harmonic Vibration Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_harmonic_vibe_strain_map_analysis.html#run-strain-map-analysis",
        "title": "Run Strain Map Analysis",
        "section": "Run Strain Map Analysis",
        "text": "Run the strain map analysis, including harmonic vibration and other analysis types.\nDownload Jupyter notebook: run_harmonic_vibe_strain_map_analysis.ipynb\nDownload Python source code: run_harmonic_vibe_strain_map_analysis.py\nDownload zipped: run_harmonic_vibe_strain_map_analysis.zip\nRun Strain Map Analysis\nDownload Jupyter notebook: run_harmonic_vibe_strain_map_analysis.ipynb\nDownload Python source code: run_harmonic_vibe_strain_map_analysis.py\nDownload zipped: run_harmonic_vibe_strain_map_analysis.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.html#ansyssherlockcoretypeslayer_typespottingregionupdatedata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "text": "Contains the properties of a potting region update request.\nPottingRegionUpdateData.construct([_fields_set])\n\nPottingRegionUpdateData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionUpdateData.dict(*[, include, ...])\n\nPottingRegionUpdateData.from_orm(obj)\n\nPottingRegionUpdateData.json(*[, include, ...])\n\nPottingRegionUpdateData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionUpdateData.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionUpdateData.model_dump(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionUpdateData.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionUpdateData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionUpdateData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionUpdateData.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionUpdateData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionUpdateData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionUpdateData.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nPottingRegionUpdateData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionUpdateData.parse_file(path, *)\n\nPottingRegionUpdateData.parse_obj(obj)\n\nPottingRegionUpdateData.parse_raw(b, *[, ...])\n\nPottingRegionUpdateData.schema([by_alias, ...])\n\nPottingRegionUpdateData.schema_json(*[, ...])\n\nPottingRegionUpdateData.str_validation(...)\nValidate string fields listed.\nPottingRegionUpdateData.update_forward_refs(...)\n\nPottingRegionUpdateData.validate(value)\n\nPottingRegionUpdateData.model_computed_fields\n\nPottingRegionUpdateData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionUpdateData.model_extra\nGet extra fields set during validation.\nPottingRegionUpdateData.model_fields\n\nPottingRegionUpdateData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionUpdateData.potting_region_id_to_update\nId of the potting region to update.\nPottingRegionUpdateData.potting_region\nPotting region data used to update the potting region.\nansys.sherlock.core.types.layer_types.PottingRegionUpdateData\nPottingRegionUpdateData.construct\nPottingRegionUpdateData.copy\nPottingRegionUpdateData.dict\nPottingRegionUpdateData.from_orm\nPottingRegionUpdateData.json\nPottingRegionUpdateData.model_construct\nPottingRegionUpdateData.model_copy\nPottingRegionUpdateData.model_dump\nPottingRegionUpdateData.model_dump_json\nPottingRegionUpdateData.model_json_schema\nPottingRegionUpdateData.model_parametrized_name\nPottingRegionUpdateData.model_post_init\nPottingRegionUpdateData.model_rebuild\nPottingRegionUpdateData.model_validate\nPottingRegionUpdateData.model_validate_json\nPottingRegionUpdateData.model_validate_strings\nPottingRegionUpdateData.parse_file\nPottingRegionUpdateData.parse_obj\nPottingRegionUpdateData.parse_raw\nPottingRegionUpdateData.schema\nPottingRegionUpdateData.schema_json\nPottingRegionUpdateData.str_validation\nPottingRegionUpdateData.update_forward_refs\nPottingRegionUpdateData.validate\nPottingRegionUpdateData.model_computed_fields\nPottingRegionUpdateData.model_config\nPottingRegionUpdateData.model_extra\nPottingRegionUpdateData.model_fields\nPottingRegionUpdateData.model_fields_set\nPottingRegionUpdateData.potting_region_id_to_update\nPottingRegionUpdateData.potting_region"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > PottingRegionUpdateData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionUpdateData > PottingRegionUpdateData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionUpdateData(**data)\n\nContains the properties of a potting region update request.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPottingRegionUpdateData.construct([_fields_set])\n\n\n\nPottingRegionUpdateData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionUpdateData.dict(*[, include, ...])\n\n\n\nPottingRegionUpdateData.from_orm(obj)\n\n\n\nPottingRegionUpdateData.json(*[, include, ...])\n\n\n\nPottingRegionUpdateData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionUpdateData.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionUpdateData.model_dump(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionUpdateData.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionUpdateData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionUpdateData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionUpdateData.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionUpdateData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionUpdateData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionUpdateData.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionUpdateData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionUpdateData.parse_file(path, *)\n\n\n\nPottingRegionUpdateData.parse_obj(obj)\n\n\n\nPottingRegionUpdateData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionUpdateData.schema([by_alias, ...])\n\n\n\nPottingRegionUpdateData.schema_json(*[, ...])\n\n\n\nPottingRegionUpdateData.str_validation(...)\n\nValidate string fields listed.\n\nPottingRegionUpdateData.update_forward_refs(...)\n\n\n\nPottingRegionUpdateData.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionUpdateData.model_computed_fields\n\n\n\nPottingRegionUpdateData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionUpdateData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionUpdateData.model_fields\n\n\n\nPottingRegionUpdateData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionUpdateData.potting_region_id_to_update\n\nId of the potting region to update.\n\nPottingRegionUpdateData.potting_region\n\nPotting region data used to update the potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields.html#ansys.sherlock.core.types.layer_types.SlotShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "SlotShape.model_fields = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'length': FieldInfo(annotation=float, required=True), 'node_count': FieldInfo(annotation=int, required=True), 'rotation': FieldInfo(annotation=float, required=True), 'width': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_solder_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_solder_info.html#get_solder_info",
        "title": "get_solder_info",
        "section": "get_solder_info",
        "text": "Get solder data from Sherlock.\nAll solder information stored in Sherlock for each solder.\nSolderInfoResponse\nget_solder_info\nSolderInfoResponse\nSolderInfoResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.get_solder_info",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.get_solder_info.html#ansys.sherlock.core.common.Common.get_solder_info",
        "title": "get_solder_info > get_solder_info > get_solder_info",
        "section": "get_solder_info > get_solder_info",
        "text": "Common.get_solder_info()\n\nGet solder data from Sherlock.\n\nReturns\n\n:\n\n\n\nSolderInfoResponse\n\nAll solder information stored in Sherlock for each solder.\n\nReturn type\n\nSolderInfoResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> solder_data = sherlock.get_solder_info()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionDeleteData.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.from_orm.html#ansys.sherlock.core.types.layer_types.CircularShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod CircularShape.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "sg_execution_times",
        "href": "sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 43 files from all galleries:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_00-setup_setup.py (..\\..\\examples\\00-setup\\setup.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_cca.py (..\\..\\examples\\01-project-configuration\\add_cca.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_event.py (..\\..\\examples\\01-project-configuration\\add_harmonic_event.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_profile.py (..\\..\\examples\\01-project-configuration\\add_harmonic_profile.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_modeling_region.py (..\\..\\examples\\01-project-configuration\\add_modeling_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_potting_region.py (..\\..\\examples\\01-project-configuration\\add_potting_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_laminate_layer.py (..\\..\\examples\\01-project-configuration\\update_laminate_layer.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_mount_points_by_file.py (..\\..\\examples\\01-project-configuration\\update_mount_points_by_file.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location.py (..\\..\\examples\\01-project-configuration\\update_part_location.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location_by_file.py (..\\..\\examples\\01-project-configuration\\update_part_location_by_file.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_modeling_properties.py (..\\..\\examples\\01-project-configuration\\update_part_modeling_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list.py (..\\..\\examples\\01-project-configuration\\update_parts_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list_properties.py (..\\..\\examples\\01-project-configuration\\update_parts_list_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_potting_region.py (..\\..\\examples\\01-project-configuration\\update_potting_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_thermal_maps.py (..\\..\\examples\\01-project-configuration\\update_thermal_maps.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_ipc_2581_archive.py (..\\..\\examples\\02-importing\\import_ipc_2581_archive.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_odb_archive.py (..\\..\\examples\\02-importing\\import_odb_archive.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_parts_list.py (..\\..\\examples\\02-importing\\import_parts_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_archive_single_mode.py (..\\..\\examples\\02-importing\\import_project_zip_archive_single_mode.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_file.py (..\\..\\examples\\02-importing\\import_project_zip_file.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_aedb.py (..\\..\\examples\\03-exporting\\export_aedb.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_mount_points.py (..\\..\\examples\\03-exporting\\export_all_mount_points.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_fixtures.py (..\\..\\examples\\03-exporting\\export_all_test_fixtures.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_points.py (..\\..\\examples\\03-exporting\\export_all_test_points.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_fea_model.py (..\\..\\examples\\03-exporting\\export_fea_model.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_net_list.py (..\\..\\examples\\03-exporting\\export_net_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_part_list.py (..\\..\\examples\\03-exporting\\export_part_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_project.py (..\\..\\examples\\03-exporting\\export_project.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_trace_model.py (..\\..\\examples\\03-exporting\\export_trace_model.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_get_parts_list_analysis_props.py (..\\..\\examples\\04-analyses\\get_parts_list_analysis_props.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_get_random_vibe_inputs_fields.py (..\\..\\examples\\04-analyses\\get_random_vibe_inputs_fields.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_analysis.py (..\\..\\examples\\04-analyses\\run_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_harmonic_vibe_strain_map_analysis.py (..\\..\\examples\\04-analyses\\run_harmonic_vibe_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_mechanical_shock_strain_map_analysis.py (..\\..\\examples\\04-analyses\\run_mechanical_shock_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_random_vibe_strain_map_analysis.py (..\\..\\examples\\04-analyses\\run_random_vibe_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_harmonic_vibe_properties.py (..\\..\\examples\\04-analyses\\update_harmonic_vibe_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_ict_properties.py (..\\..\\examples\\04-analyses\\update_ict_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_mechanical_shock_properties.py (..\\..\\examples\\04-analyses\\update_mechanical_shock_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_part_validation_properties.py (..\\..\\examples\\04-analyses\\update_part_validation_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_pcb_modeling_properties.py (..\\..\\examples\\04-analyses\\update_pcb_modeling_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_random_vibe_properties.py (..\\..\\examples\\04-analyses\\update_random_vibe_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_solder_fatigue_properties.py (..\\..\\examples\\04-analyses\\update_solder_fatigue_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_99-teardown_teardown.py (..\\..\\examples\\99-teardown\\teardown.py)\n00:00.000\n0.0\nComputation times\n..\\..\\examples\\00-setup\\setup.py\n..\\..\\examples\\01-project-configuration\\add_cca.py\n..\\..\\examples\\01-project-configuration\\add_harmonic_event.py\n..\\..\\examples\\01-project-configuration\\add_harmonic_profile.py\n..\\..\\examples\\01-project-configuration\\add_modeling_region.py\n..\\..\\examples\\01-project-configuration\\add_potting_region.py\n..\\..\\examples\\01-project-configuration\\update_laminate_layer.py\n..\\..\\examples\\01-project-configuration\\update_mount_points_by_file.py\n..\\..\\examples\\01-project-configuration\\update_part_location.py\n..\\..\\examples\\01-project-configuration\\update_part_location_by_file.py\n..\\..\\examples\\01-project-configuration\\update_part_modeling_properties.py\n..\\..\\examples\\01-project-configuration\\update_parts_list.py\n..\\..\\examples\\01-project-configuration\\update_parts_list_properties.py\n..\\..\\examples\\01-project-configuration\\update_potting_region.py\n..\\..\\examples\\01-project-configuration\\update_thermal_maps.py\n..\\..\\examples\\02-importing\\import_ipc_2581_archive.py\n..\\..\\examples\\02-importing\\import_odb_archive.py\n..\\..\\examples\\02-importing\\import_parts_list.py\n..\\..\\examples\\02-importing\\import_project_zip_archive_single_mode.py\n..\\..\\examples\\02-importing\\import_project_zip_file.py\n..\\..\\examples\\03-exporting\\export_aedb.py\n..\\..\\examples\\03-exporting\\export_all_mount_points.py\n..\\..\\examples\\03-exporting\\export_all_test_fixtures.py\n..\\..\\examples\\03-exporting\\export_all_test_points.py\n..\\..\\examples\\03-exporting\\export_fea_model.py\n..\\..\\examples\\03-exporting\\export_net_list.py\n..\\..\\examples\\03-exporting\\export_part_list.py\n..\\..\\examples\\03-exporting\\export_project.py\n..\\..\\examples\\03-exporting\\export_trace_model.py\n..\\..\\examples\\04-analyses\\get_parts_list_analysis_props.py\n..\\..\\examples\\04-analyses\\get_random_vibe_inputs_fields.py\n..\\..\\examples\\04-analyses\\run_analysis.py\n..\\..\\examples\\04-analyses\\run_harmonic_vibe_strain_map_analysis.py\n..\\..\\examples\\04-analyses\\run_mechanical_shock_strain_map_analysis.py\n..\\..\\examples\\04-analyses\\run_random_vibe_strain_map_analysis.py\n..\\..\\examples\\04-analyses\\update_harmonic_vibe_properties.py\n..\\..\\examples\\04-analyses\\update_ict_properties.py\n..\\..\\examples\\04-analyses\\update_mechanical_shock_properties.py\n..\\..\\examples\\04-analyses\\update_part_validation_properties.py\n..\\..\\examples\\04-analyses\\update_pcb_modeling_properties.py\n..\\..\\examples\\04-analyses\\update_random_vibe_properties.py\n..\\..\\examples\\04-analyses\\update_solder_fatigue_properties.py\n..\\..\\examples\\99-teardown\\teardown.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.CircularShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CircularShape.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PottingRegion.model_fields = {'cca_name': FieldInfo(annotation=str, required=True), 'potting_id': FieldInfo(annotation=str, required=True), 'potting_material': FieldInfo(annotation=str, required=True), 'potting_side': FieldInfo(annotation=str, required=True), 'potting_standoff': FieldInfo(annotation=float, required=True), 'potting_thickness': FieldInfo(annotation=float, required=True), 'potting_units': FieldInfo(annotation=str, required=True), 'shape': FieldInfo(annotation=Union[CircularShape, PCBShape, PolygonalShape, RectangularShape, SlotShape], required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "DeletePottingRegionRequest.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_raw.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod GerberOutlineFile.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_comment",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_comment.html#file_comment",
        "title": "file_comment",
        "section": "file_comment",
        "text": "The comment for the outline file.\nfile_comment\nOptional\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_comment",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_comment.html#ansys.sherlock.core.types.project_types.OutlineFile.file_comment",
        "title": "file_comment > file_comment > file_comment",
        "section": "file_comment > file_comment",
        "text": "OutlineFile.file_comment: Optional[str]\n\nThe comment for the outline file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/sg_execution_times",
        "href": "examples/gallery_examples/04-analyses/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 13 files from examplesgallery_examples04-analyses:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_04-analyses_get_parts_list_analysis_props.py (get_parts_list_analysis_props.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_get_random_vibe_inputs_fields.py (get_random_vibe_inputs_fields.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_analysis.py (run_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_harmonic_vibe_strain_map_analysis.py (run_harmonic_vibe_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_mechanical_shock_strain_map_analysis.py (run_mechanical_shock_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_run_random_vibe_strain_map_analysis.py (run_random_vibe_strain_map_analysis.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_harmonic_vibe_properties.py (update_harmonic_vibe_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_ict_properties.py (update_ict_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_mechanical_shock_properties.py (update_mechanical_shock_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_part_validation_properties.py (update_part_validation_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_pcb_modeling_properties.py (update_pcb_modeling_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_random_vibe_properties.py (update_random_vibe_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_04-analyses_update_solder_fatigue_properties.py (update_solder_fatigue_properties.py)\n00:00.000\n0.0\nComputation times\nget_parts_list_analysis_props.py\nget_random_vibe_inputs_fields.py\nrun_analysis.py\nrun_harmonic_vibe_strain_map_analysis.py\nrun_mechanical_shock_strain_map_analysis.py\nrun_random_vibe_strain_map_analysis.py\nupdate_harmonic_vibe_properties.py\nupdate_ict_properties.py\nupdate_mechanical_shock_properties.py\nupdate_part_validation_properties.py\nupdate_pcb_modeling_properties.py\nupdate_random_vibe_properties.py\nupdate_solder_fatigue_properties.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionDeleteData.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.x_location_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.x_location_column.html#x_location_column",
        "title": "x_location_column",
        "section": "x_location_column",
        "text": "X location column name\nx_location_column\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.x_location_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.x_location_column.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.x_location_column",
        "title": "x_location_column > x_location_column > x_location_column",
        "section": "x_location_column > x_location_column",
        "text": "CsvExcelOutlineFile.x_location_column: str\n\nX location column name\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_computed_fields.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "GerberOutlineFile.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/sg_execution_times",
        "href": "examples/gallery_examples/01-project-configuration/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 14 files from examplesgallery_examples01-project-configuration:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_01-project-configuration_add_cca.py (add_cca.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_event.py (add_harmonic_event.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_profile.py (add_harmonic_profile.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_modeling_region.py (add_modeling_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_add_potting_region.py (add_potting_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_laminate_layer.py (update_laminate_layer.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_mount_points_by_file.py (update_mount_points_by_file.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location.py (update_part_location.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location_by_file.py (update_part_location_by_file.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_modeling_properties.py (update_part_modeling_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list.py (update_parts_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list_properties.py (update_parts_list_properties.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_potting_region.py (update_potting_region.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_01-project-configuration_update_thermal_maps.py (update_thermal_maps.py)\n00:00.000\n0.0\nComputation times\nadd_cca.py\nadd_harmonic_event.py\nadd_harmonic_profile.py\nadd_modeling_region.py\nadd_potting_region.py\nupdate_laminate_layer.py\nupdate_mount_points_by_file.py\nupdate_part_location.py\nupdate_part_location_by_file.py\nupdate_part_modeling_properties.py\nupdate_parts_list.py\nupdate_parts_list_properties.py\nupdate_potting_region.py\nupdate_thermal_maps.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PolygonalShape.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_units",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_units.html#list_units",
        "title": "list_units",
        "section": "list_units",
        "text": "List units for a unit type.\nAvailable Since: 2023R2\nUnit type.\nUnits for the unit type.\nstr\nlist_units\nListUnitsRequestUnitType\npython:str\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.list_units",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.list_units.html#ansys.sherlock.core.common.Common.list_units",
        "title": "list_units > list_units > list_units",
        "section": "list_units > list_units",
        "text": "Common.list_units(unit_type)\n\nList units for a unit type.\n\nAvailable Since: 2023R2\n\nParameters\n\nunit_type\n\nListUnitsRequestUnitType\n\nUnit type.\n\nReturns\n\n:\n\n\n\npython:str\n\nUnits for the unit type.\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionDeleteData.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_post_init.html#ansys.sherlock.core.types.layer_types.PCBShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PCBShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points.html#export_all_mount_points",
        "title": "export_all_mount_points",
        "section": "export_all_mount_points",
        "text": "Export the mount point properties for a CCA.\nName of the Sherlock project.\nName of the CCA.\nFull path for the CSV file to export the mount points list to.\nUnits to use when exporting the mount points.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_mount_points\nDEFAULT\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_mount_points.html#ansys.sherlock.core.layer.Layer.export_all_mount_points",
        "title": "export_all_mount_points > export_all_mount_points > export_all_mount_points",
        "section": "export_all_mount_points > export_all_mount_points",
        "text": "Layer.export_all_mount_points(project, cca_name, export_file, units='DEFAULT')\n\nExport the mount point properties for a CCA.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nexport_file: str\n\nFull path for the CSV file to export the mount points list to.\n\nunits: str, optional\n\nUnits to use when exporting the mount points.\nThe default is DEFAULT.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.export_all_mount_points(\n>>>     \"Tutorial Project\",\n>>>     \"Card\",\n>>>     \"MountPointsExport.csv\",\n>>>     \"DEFAULT\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod SlotShape.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.from_orm.html#ansys.sherlock.core.types.layer_types.RectangularShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod RectangularShape.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod UpdatePottingRegionRequest.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegion.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#export-all-mount-points",
        "title": "Export All Mount Points",
        "section": "Export All Mount Points",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export all mount points for a CCA.\nExport All Mount Points"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#description",
        "title": "Export All Mount Points > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate various workflows, including exporting all\nmount points for a PCB.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a tutorial project.\n- Export all mount points to a CSV file.\nThe exported mount points can be used for further analysis or design purposes.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#connect-to-sherlock",
        "title": "Export All Mount Points > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#delete-project",
        "title": "Export All Mount Points > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#import-tutorial-project",
        "title": "Export All Mount Points > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_mount_points",
        "href": "examples/gallery_examples/03-exporting/export_all_mount_points.html#export-all-mount-points",
        "title": "Export All Mount Points",
        "section": "Export All Mount Points",
        "text": "Export all mount points for the “Main Board” to a CSV file.\nDownload Jupyter notebook: export_all_mount_points.ipynb\nDownload Python source code: export_all_mount_points.py\nDownload zipped: export_all_mount_points.zip\nExport All Mount Points\nDownload Jupyter notebook: export_all_mount_points.ipynb\nDownload Python source code: export_all_mount_points.py\nDownload zipped: export_all_mount_points.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model.html#export_trace_reinforcement_model",
        "title": "export_trace_reinforcement_model",
        "section": "export_trace_reinforcement_model",
        "text": "Export a trace reinforcement model.\nAvailable Since: 2023R1\nName of the Sherlock project to generate the trace reinforcement model for.\nName of the CCA to generate the trace reinforcement model from.\nPath for saving exported files to. The file extension must be .wbjn.\nWhether to overwrite an existing file having the same file name.\nThe default is True.\nWhether to launch and display the exported model in Ansys Workbench\nMechanical once the export finishes. The default is False.\nWhether to generate and export trace models for not only the generated trace\nreinforcement layers but also all other layers. The default is False, in\nwhich case only trace reinforcement layers are generated and exported.\nUnits of the model coordinates to use when exporting a model.\nThe default is \"mm\".\nThreshold value that determines whether a hole is modeled with shell\nreinforcement elements or beam elements. The default is 2, with the\ndefault units being \"mm\" as specified by the next parameter. Holes with\ndiameters equal to or greater than this threshold value are modeled with shell\nreinforcement elements. Holes with diameters less than this threshold value\nare modeled with beam elements. Holes buried inside the board are always modeled\nwith beam elements.\nUnits associated with the threshold value for the trace parameter diameter.\nThe default is \"mm\".\nMinimum trace parameter diameter for determining whether a via is exported.\nThe default is 0.25, with the default units being \"mm\" as specified\nby the next parameter. Vias with diameters smaller than this diameter\nare not exported. Setting the value to 0 exports all vias.\nUnits associated with the value for the minimum trace parameter diameter.\nThe default is \"mm\".\nWhether to enable or disable the modeling of trace drill holes. Options are\n\"ENABLED\" and \"DISABLED\". The default is \"DISABLED\", in which\ncase the trace_drill_hole_min_diameter and trace_drill_hole_max_edge\nparameters are not used.\nMinimimun diameter value for determining whether a trace drill hole is\nexported. The default is 2, with the default units being \"mm\"\nas specified by the next parameter. Trace drill holes with diameters smaller\nthan this diameter are not exported. Setting the value to 0 exports all\ntrace drill holes.\nUnits associated with the value for the minimum trace drill hole diameter.\nThe default is \"mm\".\nMaximum segment size for representing round drill holes by a polygon.\nThe default is 1, with the default units being \"mm\" as specified\nby the next parameter.\nUnits associated with the maximum segment for representing round drill holes\nby a polygon. The default is \"mm\".\nStatus code of the response. 0 for success.\nint\nexport_trace_reinforcement_model\n.wbjn\nTrue\nFalse\nFalse\n\"mm\"\n2\n\"mm\"\n\"mm\"\n0.25\n\"mm\"\n0\n\"mm\"\n\"ENABLED\"\n\"DISABLED\"\n\"DISABLED\"\ntrace_drill_hole_min_diameter\ntrace_drill_hole_max_edge\n2\n\"mm\"\n0\n\"mm\"\n1\n\"mm\"\n\"mm\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_trace_reinforcement_model.html#ansys.sherlock.core.model.Model.export_trace_reinforcement_model",
        "title": "export_trace_reinforcement_model > export_trace_reinforcement_model > export_trace_reinforcement_model",
        "section": "export_trace_reinforcement_model > export_trace_reinforcement_model",
        "text": "Model.export_trace_reinforcement_model(project_name, cca_name, export_file, overwrite=True, display_model=False, generate_models_for_all_layers=False, coordinate_units='mm', trace_param_diameter_threshold_val=2, trace_param_diameter_threshold_unit='mm', trace_param_min_hole_diameter_val=0.25, trace_param_min_hole_diameter_unit='mm', trace_drill_hole_modeling='DISABLED', trace_drill_hole_min_diameter_val=2, trace_drill_hole_min_diameter_unit='mm', trace_drill_hole_max_edge_val=1, trace_drill_hole_max_edge_unit='mm')\n\nExport a trace reinforcement model.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject_name: str\n\nName of the Sherlock project to generate the trace reinforcement model for.\n\ncca_name: str\n\nName of the CCA to generate the trace reinforcement model from.\n\nexport_file: str\n\nPath for saving exported files to. The file extension must be .wbjn.\n\noverwrite: bool, optional\n\nWhether to overwrite an existing file having the same file name.\nThe default is True.\n\ndisplay_model: bool, optional\n\nWhether to launch and display the exported model in Ansys Workbench\nMechanical once the export finishes. The default is False.\n\ngenerate_models_for_all_layers:  bool, optional\n\nWhether to generate and export trace models for not only the generated trace\nreinforcement layers but also all other layers. The default is False, in\nwhich case only trace reinforcement layers are generated and exported.\n\ncoordinate_units: str, optional\n\nUnits of the model coordinates to use when exporting a model.\nThe default is \"mm\".\n\ntrace_param_diameter_threshold_val: float, optional\n\nThreshold value that determines whether a hole is modeled with shell\nreinforcement elements or beam elements. The default is 2, with the\ndefault units being \"mm\" as specified by the next parameter. Holes with\ndiameters equal to or greater than this threshold value are modeled with shell\nreinforcement elements. Holes with diameters less than this threshold value\nare modeled with beam elements. Holes buried inside the board are always modeled\nwith beam elements.\n\ntrace_param_diameter_threshold_unit: str, optional\n\nUnits associated with the threshold value for the trace parameter diameter.\nThe default is \"mm\".\n\ntrace_param_min_hole_diameter_val: float, optional\n\nMinimum trace parameter diameter for determining whether a via is exported.\nThe default is 0.25, with the default units being \"mm\" as specified\nby the next parameter. Vias with diameters smaller than this diameter\nare not exported. Setting the value to 0 exports all vias.\n\ntrace_param_min_hole_diameter_unit: str, optional\n\nUnits associated with the value for the minimum trace parameter diameter.\nThe default is \"mm\".\n\ntrace_drill_hole_modeling: str, optional\n\nWhether to enable or disable the modeling of trace drill holes. Options are\n\"ENABLED\" and \"DISABLED\". The default is \"DISABLED\", in which\ncase the trace_drill_hole_min_diameter and trace_drill_hole_max_edge\nparameters are not used.\n\ntrace_drill_hole_min_diameter_val: float, optional\n\nMinimimun diameter value for determining whether a trace drill hole is\nexported. The default is 2, with the default units being \"mm\"\nas specified by the next parameter. Trace drill holes with diameters smaller\nthan this diameter are not exported. Setting the value to 0 exports all\ntrace drill holes.\n\ntrace_drill_hole_min_diameter_unit: str, optional\n\nUnits associated with the value for the minimum trace drill hole diameter.\nThe default is \"mm\".\n\ntrace_drill_hole_max_edge_val: float, optional\n\nMaximum segment size for representing round drill holes by a polygon.\nThe default is 1, with the default units being \"mm\" as specified\nby the next parameter.\n\ntrace_drill_hole_max_edge_unit: str, optional\n\nUnits associated with the maximum segment for representing round drill holes\nby a polygon. The default is \"mm\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_trace_reinforcement_model(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.wbjn',\n    True, False, False)\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_trace_reinforcement_model(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.wbjn',\n    True, False, False, \"mm\", 1.5, \"mm\", 0, \"mm\", \"ENABLED\", 1.5, \"mm\", 1, \"mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CopyPottingRegionRequest.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionDeleteData.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width.html#width",
        "title": "width",
        "section": "width",
        "text": "width of the image\nfloat\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.width.html#ansys.sherlock.core.types.project_types.ImageBounds.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "ImageBounds.width\n\nwidth of the image\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature.html#max_temperature",
        "title": "max_temperature",
        "section": "max_temperature",
        "text": "max_temperature\nfloat\nmax_temperature"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature.html#ansys.sherlock.core.types.project_types.ImageFile.max_temperature",
        "title": "max_temperature > max_temperature > max_temperature",
        "section": "max_temperature > max_temperature",
        "text": "ImageFile.max_temperature\n\nmax_temperature\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase.html#create_life_phase",
        "title": "create_life_phase",
        "section": "create_life_phase",
        "text": "Create a life phase.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the life phase.\nEvent duration length.\nUnits for the event duration length. Options are \"ms\",\n\"sec\", and \"min\".\nNumber of cycles for the life phase.\nCycle type. Options include \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\nDescription of the life phase. The default is \"\".\nStatus code of the response. 0 for success.\ncreate_life_phase\n\"ms\"\n\"sec\"\n\"min\"\n\"COUNT\"\n\"DUTY CYCLE\"\n\"PER YEAR\"\n\"PER HOUR\"\n\"\"\npython:int"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase.html#ansys.sherlock.core.lifecycle.Lifecycle.create_life_phase",
        "title": "create_life_phase > create_life_phase > create_life_phase",
        "section": "create_life_phase > create_life_phase",
        "text": "Lifecycle.create_life_phase(project, phase_name, duration, duration_units, num_of_cycles, cycle_type, description='')\n\nCreate a life phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nphase_name: str\n\nName of the life phase.\n\nduration: float\n\nEvent duration length.\n\nduration_units: str\n\nUnits for the event duration length. Options are \"ms\",\n\"sec\", and \"min\".\n\nnum_of_cycles: float\n\nNumber of cycles for the life phase.\n\ncycle_type: str\n\nCycle type. Options include \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\n\ndescription: str, optional\n\nDescription of the life phase. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer.html#update_laminate_layer",
        "title": "update_laminate_layer",
        "section": "update_laminate_layer",
        "text": "Update a laminate layer with given properties.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the CCA.\nLayer ID associated with the laminate layer.\nManufacturer of the material for the laminate layer.\nThe default is \"\". To update the material, the\nmanufacturer, grade, and material parameters\nmust be specified. When the manufacturer is specified,\nthere are checks to ensure that the corresponding parameters\nare provided.\nMaterial grade. The default is \"\".\nMaterial name. The default is \"\".\nLaminate thickness. The default is 0.\nUnits for the laminate thickness. The default is \"\".\nConstruction style. The default is \"\".\nList representing a glass construction. This list consists\nof objects with these properties:\nStyle of the glass construction.\nResin percentage.\nThickness.\nUnits for the thickness.\nFiber material. The default is \"\". This parameter is only\nupdated for a glass construction.\nConductor material. The default is \"\".\nConductor percentage. The default is \"\".\nStatus code of the response. 0 for success.\nint\nupdate_laminate_layer\npython:str\npython:str\npython:str\npython:str\noptional\n\"\"\nmanufacturer\ngrade\nmaterial\nmanufacturer\npython:str\noptional\n\"\"\npython:str\noptional\n\"\"\npython:float\noptional\n0\npython:str\noptional\n\"\"\npython:str\noptional\n\"\"\npython:list\npython:tuple\npython:str\npython:float\npython:float\npython:str\noptional\npython:str\noptional\n\"\"\npython:str\noptional\n\"\"\npython:str\noptional\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_laminate_layer.html#ansys.sherlock.core.stackup.Stackup.update_laminate_layer",
        "title": "update_laminate_layer > update_laminate_layer > update_laminate_layer",
        "section": "update_laminate_layer > update_laminate_layer",
        "text": "Stackup.update_laminate_layer(project, cca_name, layer, manufacturer='', grade='', material='', thickness=0, thickness_unit='', construction_style='', glass_construction=None, fiber_material='', conductor_material='', conductor_percent='')\n\nUpdate a laminate layer with given properties.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject\n\npython:str\n\nName of the Sherlock project.\n\ncca_name\n\npython:str\n\nName of the CCA.\n\nlayer\n\npython:str\n\nLayer ID associated with the laminate layer.\n\nmanufacturer\n\npython:str, optional\n\nManufacturer of the material for the laminate layer.\nThe default is \"\". To update the material, the\nmanufacturer, grade, and material parameters\nmust be specified. When the manufacturer is specified,\nthere are checks to ensure that the corresponding parameters\nare provided.\n\ngrade\n\npython:str, optional\n\nMaterial grade. The default is \"\".\n\nmaterial\n\npython:str, optional\n\nMaterial name. The default is \"\".\n\nthickness\n\npython:float, optional\n\nLaminate thickness. The default is 0.\n\nthickness_unit\n\npython:str, optional\n\nUnits for the laminate thickness. The default is \"\".\n\nconstruction_style\n\npython:str, optional\n\nConstruction style. The default is \"\".\n\nglass_construction\n\npython:list[python:tuple[python:str, python:float, python:float, python:str]], optional\n\nList representing a glass construction. This list consists\nof objects with these properties:\n\nstyle\n\nstr\n\nStyle of the glass construction.\n\nresinPercentage\n\nfloat\n\nResin percentage.\n\nthickness: float\n\nThickness.\n\nthicknessUnit: str\n\nUnits for the thickness.\n\nfiber_material\n\npython:str, optional\n\nFiber material. The default is \"\". This parameter is only\nupdated for a glass construction.\n\nconductor_material\n\npython:str, optional\n\nConductor material. The default is \"\".\n\nconductor_percent\n\npython:str, optional\n\nConductor percentage. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.update_laminate_layer(\n    \"Test\",\n    \"Card\",\n    \"2\",\n    \"Generic\",\n    \"FR-4\",\n    \"Generic FR-4\",\n    0.015,\n    \"in\",\n    \"106\",\n    [\n        (\"106\", 68.0, 0.015, \"in\")\n    ],\n    \"E-GLASS\",\n    \"COPPER\",\n    \"0.0\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape.html#shape",
        "title": "shape",
        "section": "shape",
        "text": "The shape of the potting region.\nshape\nUnion\nCircularShape\nPCBShape\nPolygonalShape\nRectangularShape\nSlotShape"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.shape.html#ansys.sherlock.core.types.layer_types.PottingRegion.shape",
        "title": "shape > shape > shape",
        "section": "shape > shape",
        "text": "PottingRegion.shape: Union[CircularShape, PCBShape, PolygonalShape, RectangularShape, SlotShape]\n\nThe shape of the potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_strings.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod GerberOutlineFile.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionUpdateData.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_raw.html#ansys.sherlock.core.types.project_types.OutlineFile.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod OutlineFile.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units.html#coordinate_units",
        "title": "coordinate_units",
        "section": "coordinate_units",
        "text": "coordinate_units\nstr\ncoordinate_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.coordinate_units.html#ansys.sherlock.core.types.project_types.ImageFile.coordinate_units",
        "title": "coordinate_units > coordinate_units > coordinate_units",
        "section": "coordinate_units > coordinate_units",
        "text": "ImageFile.coordinate_units\n\ncoordinate_units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "DeletePottingRegionRequest.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#examples",
        "title": "Examples",
        "section": "Examples",
        "text": "Here are examples using Sherlock with the ansys-sherlock-core library.\nExamples on how to configure a project using PySherlock.\nExamples on how to import projects and files using PySherlock.\nExamples on how to import projects and files using PySherlock.\nExamples on how to run analyses using PySherlock.\nExamples\nansys-sherlock-core"
    },
    {
        "objectID": "examples/index",
        "href": "examples/index.html#download-example-files",
        "title": "Examples > Download example files",
        "section": "Download example files",
        "text": "Each example should contain all the necessary resources to run the example.\nHowever in some cases, external files are needed. A link to those files is\navailable at each example page.\nThese links refers to the following GitHub repository where you can find all of them:\nGitHub Example Data Repository\nIf you find a missing or broken link, open an issue in\nGitHub (PySherlock Issues).\nDownload example files"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionUpdateData.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column.html#reference_id_column",
        "title": "reference_id_column",
        "section": "reference_id_column",
        "text": "reference_id_column\nstr\nreference_id_column"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column.html#ansys.sherlock.core.types.project_types.CsvExcelFile.reference_id_column",
        "title": "reference_id_column > reference_id_column > reference_id_column",
        "section": "reference_id_column > reference_id_column",
        "text": "CsvExcelFile.reference_id_column\n\nreference_id_column\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_parametrized_name.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CsvExcelOutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.html#ansyssherlockcoretypeslayer_typespottingregion",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegion",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegion",
        "text": "Contains the properties of a Potting Region add or update request.\nPottingRegion.construct([_fields_set])\n\nPottingRegion.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nPottingRegion.dict(*[, include, exclude, ...])\n\nPottingRegion.from_orm(obj)\n\nPottingRegion.json(*[, include, exclude, ...])\n\nPottingRegion.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPottingRegion.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nPottingRegion.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegion.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegion.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPottingRegion.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegion.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegion.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegion.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nPottingRegion.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nPottingRegion.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegion.parse_file(path, *[, ...])\n\nPottingRegion.parse_obj(obj)\n\nPottingRegion.parse_raw(b, *[, ...])\n\nPottingRegion.schema([by_alias, ref_template])\n\nPottingRegion.schema_json(*[, by_alias, ...])\n\nPottingRegion.str_validation(value, info)\nValidate string fields listed.\nPottingRegion.update_forward_refs(**localns)\n\nPottingRegion.validate(value)\n\nPottingRegion.model_computed_fields\n\nPottingRegion.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegion.model_extra\nGet extra fields set during validation.\nPottingRegion.model_fields\n\nPottingRegion.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegion.cca_name\nThe name of the CCA.\nPottingRegion.potting_id\nThe potting ID.\nPottingRegion.potting_side\nThe potting side, options are \"TOP\", \"BOT\", or \"BOTTOM\".\nPottingRegion.potting_material\nThe potting material.\nPottingRegion.potting_units\nThe units to use for the potting region.\nPottingRegion.potting_thickness\nThe potting thickness.\nPottingRegion.potting_standoff\nThe potting standoff.\nPottingRegion.shape\nThe shape of the potting region.\nansys.sherlock.core.types.layer_types.PottingRegion\nPottingRegion.construct\nPottingRegion.copy\nPottingRegion.dict\nPottingRegion.from_orm\nPottingRegion.json\nPottingRegion.model_construct\nPottingRegion.model_copy\nPottingRegion.model_dump\nPottingRegion.model_dump_json\nPottingRegion.model_json_schema\nPottingRegion.model_parametrized_name\nPottingRegion.model_post_init\nPottingRegion.model_rebuild\nPottingRegion.model_validate\nPottingRegion.model_validate_json\nPottingRegion.model_validate_strings\nPottingRegion.parse_file\nPottingRegion.parse_obj\nPottingRegion.parse_raw\nPottingRegion.schema\nPottingRegion.schema_json\nPottingRegion.str_validation\nPottingRegion.update_forward_refs\nPottingRegion.validate\nPottingRegion.model_computed_fields\nPottingRegion.model_config\nPottingRegion.model_extra\nPottingRegion.model_fields\nPottingRegion.model_fields_set\nPottingRegion.cca_name\nPottingRegion.potting_id\nPottingRegion.potting_side\nPottingRegion.potting_material\nPottingRegion.potting_units\nPottingRegion.potting_thickness\nPottingRegion.potting_standoff\nPottingRegion.shape"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.html#ansys.sherlock.core.types.layer_types.PottingRegion",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegion > ansys.sherlock.core.types.layer_types.PottingRegion > PottingRegion",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegion > PottingRegion",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegion(**data)\n\nContains the properties of a Potting Region add or update request.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPottingRegion.construct([_fields_set])\n\n\n\nPottingRegion.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nPottingRegion.dict(*[, include, exclude, ...])\n\n\n\nPottingRegion.from_orm(obj)\n\n\n\nPottingRegion.json(*[, include, exclude, ...])\n\n\n\nPottingRegion.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegion.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegion.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegion.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegion.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegion.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegion.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegion.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegion.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nPottingRegion.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegion.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegion.parse_file(path, *[, ...])\n\n\n\nPottingRegion.parse_obj(obj)\n\n\n\nPottingRegion.parse_raw(b, *[, ...])\n\n\n\nPottingRegion.schema([by_alias, ref_template])\n\n\n\nPottingRegion.schema_json(*[, by_alias, ...])\n\n\n\nPottingRegion.str_validation(value, info)\n\nValidate string fields listed.\n\nPottingRegion.update_forward_refs(**localns)\n\n\n\nPottingRegion.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegion.model_computed_fields\n\n\n\nPottingRegion.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegion.model_extra\n\nGet extra fields set during validation.\n\nPottingRegion.model_fields\n\n\n\nPottingRegion.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegion.cca_name\n\nThe name of the CCA.\n\nPottingRegion.potting_id\n\nThe potting ID.\n\nPottingRegion.potting_side\n\nThe potting side, options are \"TOP\", \"BOT\", or \"BOTTOM\".\n\nPottingRegion.potting_material\n\nThe potting material.\n\nPottingRegion.potting_units\n\nThe units to use for the potting region.\n\nPottingRegion.potting_thickness\n\nThe potting thickness.\n\nPottingRegion.potting_standoff\n\nThe potting standoff.\n\nPottingRegion.shape\n\nThe shape of the potting region.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.CircularShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "CircularShape.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#export-all-test-points",
        "title": "Export All Test Points",
        "section": "Export All Test Points",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export all test points for a CCA.\nExport All Test Points"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#description",
        "title": "Export All Test Points > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API enables users to automate various workflows, including exporting all\ntest points for a CCA.\nThis script demonstrates how to:\nConnect to the Sherlock service.\nImport a tutorial project.\nExport all test points to a CSV file.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#connect-to-sherlock",
        "title": "Export All Test Points > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#delete-project",
        "title": "Export All Test Points > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#import-tutorial-project",
        "title": "Export All Test Points > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_points",
        "href": "examples/gallery_examples/03-exporting/export_all_test_points.html#export-all-test-points",
        "title": "Export All Test Points",
        "section": "Export All Test Points",
        "text": "Export all test points for the “Main Board” to a CSV file.\nDownload Jupyter notebook: export_all_test_points.ipynb\nDownload Python source code: export_all_test_points.py\nDownload zipped: export_all_test_points.zip\nExport All Test Points\nDownload Jupyter notebook: export_all_test_points.ipynb\nDownload Python source code: export_all_test_points.py\nDownload zipped: export_all_test_points.zip"
    },
    {
        "objectID": "api/layer",
        "href": "api/layer.html#layer",
        "title": "Layer",
        "section": "Layer",
        "text": "Module containing all layer management capabilities.\nLayer(channel, server_version)\nModule containing all the layer management capabilities.\nLayer\nLayer"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.json.html#ansys.sherlock.core.types.layer_types.CircularShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CircularShape.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionUpdateData.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PolygonalShape.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.non_negative_int_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.non_negative_int_validation.html#non_negative_int_validation",
        "title": "non_negative_int_validation",
        "section": "non_negative_int_validation",
        "text": "Validate integer fields listed contain non-negative values.\nnon_negative_int_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.non_negative_int_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.non_negative_int_validation.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.non_negative_int_validation",
        "title": "non_negative_int_validation > non_negative_int_validation > non_negative_int_validation",
        "section": "non_negative_int_validation > non_negative_int_validation",
        "text": "classmethod CsvExcelOutlineFile.non_negative_int_validation(value, info)\n\nValidate integer fields listed contain non-negative values.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#import-ipc-2581-archive",
        "title": "Import IPC-2581 Archive",
        "section": "Import IPC-2581 Archive",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service and import an\nIPC-2581 project,\nImport IPC-2581 Archive"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#description",
        "title": "Import IPC-2581 Archive > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as importing IPC-2581 archives.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import an IPC-2581 archive without specifying a project or CCA name.\nThis functionality is useful for initializing projects with IPC-2581 data for further\nanalysis and workflows.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#connect-to-sherlock",
        "title": "Import IPC-2581 Archive > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#delete-project",
        "title": "Import IPC-2581 Archive > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#import-tutorial-project",
        "title": "Import IPC-2581 Archive > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import a sample project ZIP archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_ipc_2581_archive",
        "href": "examples/gallery_examples/02-importing/import_ipc_2581_archive.html#import-ipc-2581-archive",
        "title": "Import IPC-2581 Archive",
        "section": "Import IPC-2581 Archive",
        "text": "Import an IPC-2581 archive without specifying a project or CCA name.\nDownload Jupyter notebook: import_ipc_2581_archive.ipynb\nDownload Python source code: import_ipc_2581_archive.py\nDownload zipped: import_ipc_2581_archive.zip\nImport IPC-2581 Archive\nDownload Jupyter notebook: import_ipc_2581_archive.ipynb\nDownload Python source code: import_ipc_2581_archive.py\nDownload zipped: import_ipc_2581_archive.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update.html#potting_region_id_to_update",
        "title": "potting_region_id_to_update",
        "section": "potting_region_id_to_update",
        "text": "Id of the potting region to update.\npotting_region_id_to_update\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region_id_to_update",
        "title": "potting_region_id_to_update > potting_region_id_to_update > potting_region_id_to_update",
        "section": "potting_region_id_to_update > potting_region_id_to_update",
        "text": "PottingRegionUpdateData.potting_region_id_to_update: str\n\nId of the potting region to update.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event.html#add_harmonic_event",
        "title": "add_harmonic_event",
        "section": "add_harmonic_event",
        "text": "Add a harmonic event to a life cycle phase.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the life cycle phase to add the harmonic event to.\nName of the harmonic event.\nEvent duration length.\nEvent duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\nNumber of cycles for the harmonic event.\nCycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\nSweep rate for the harmonic event.\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nProfile type of the harmonic load. Options are \"Uniaxial\" and \"Triaxial\".\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\nDescription of the harmonic event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_harmonic_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY_CYCLE\"\n\"PER_YEAR\"\n\"PER_DAY\"\n\"PER_HOUR\"\n\"PER_MIN\"\n\"PER_SEC\"\n\"azimuth, elevation\"\n\"30,15\"\n\"Uniaxial\"\n\"Triaxial\"\n\"x,y,z\"\n\"0,0,1\"\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_harmonic_event",
        "title": "add_harmonic_event > add_harmonic_event > add_harmonic_event",
        "section": "add_harmonic_event > add_harmonic_event",
        "text": "Lifecycle.add_harmonic_event(project, phase_name, event_name, duration, duration_units, num_of_cycles, cycle_type, sweep_rate, orientation, profile_type, load_direction, description='')\n\nAdd a harmonic event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nphase_name: str\n\nName of the life cycle phase to add the harmonic event to.\n\nevent_name: str\n\nName of the harmonic event.\n\nduration: float\n\nEvent duration length.\n\nduration_units: str\n\nEvent duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\n\nnum_of_cycles: float\n\nNumber of cycles for the harmonic event.\n\ncycle_type: str\n\nCycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\n\nsweep_rate: float\n\nSweep rate for the harmonic event.\n\norientation: str\n\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nprofile_type: str\n\nProfile type of the harmonic load. Options are \"Uniaxial\" and \"Triaxial\".\n\nload_direction: str\n\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription: str, optional\n\nDescription of the harmonic event. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\"\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_harmonic_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    5,\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.center_y.html#ansys.sherlock.core.types.layer_types.RectangularShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "RectangularShape.center_y: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionDeleteData.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionDeleteData.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_validate.html#ansys.sherlock.core.types.layer_types.PCBShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PCBShape.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.outline_file_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.outline_file_data.html#outline_file_data",
        "title": "outline_file_data",
        "section": "outline_file_data",
        "text": "Specific outline file type properties\noutline_file_data\nUnion\nCsvExcelOutlineFile\nGerberOutlineFile\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.outline_file_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.outline_file_data.html#ansys.sherlock.core.types.project_types.OutlineFile.outline_file_data",
        "title": "outline_file_data > outline_file_data > outline_file_data",
        "section": "outline_file_data > outline_file_data",
        "text": "OutlineFile.outline_file_data: Union[CsvExcelOutlineFile, GerberOutlineFile, None]\n\nSpecific outline file type properties\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_copy.html#ansys.sherlock.core.types.layer_types.SlotShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "SlotShape.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.rotation.html#ansys.sherlock.core.types.layer_types.PolygonalShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "PolygonalShape.rotation: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps.html#list_strain_maps",
        "title": "list_strain_maps",
        "section": "list_strain_maps",
        "text": "List the strain maps assigned to each CCA or given CCAs.\nAvailable Since: 2023R2\nName of the Sherlock project.\nCCA names to provide strain maps for. The default is None,\nin which case all CCAs in the project are returned.\nAll strain maps or strain maps for the specified CCAs.\nlist[CcaStrainMap]\nlist_strain_maps\nNone\npython:list\nSherlockProjectService_pb2.ListStrainMapsResponse.CcaStrainMap\nlist\nCcaStrainMap"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.list_strain_maps.html#ansys.sherlock.core.project.Project.list_strain_maps",
        "title": "list_strain_maps > list_strain_maps > list_strain_maps",
        "section": "list_strain_maps > list_strain_maps",
        "text": "Project.list_strain_maps(project, cca_names=None)\n\nList the strain maps assigned to each CCA or given CCAs.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_names: list[str], optional\n\nCCA names to provide strain maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\n:\n\n\n\npython:list[SherlockProjectService_pb2.ListStrainMapsResponse.CcaStrainMap]\n\nAll strain maps or strain maps for the specified CCAs.\n\nReturn type\n\nlist[CcaStrainMap]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> strain_maps = sherlock.project.list_strain_maps(\n    \"AssemblyTutorial\",\n    [\"Main Board\",\"Power Module\"]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#update-pcb-modeling-properties",
        "title": "Update PCB Modeling Properties",
        "section": "Update PCB Modeling Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand configure PCB modeling properties for various analysis types.\nUpdate PCB Modeling Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#description",
        "title": "Update PCB Modeling Properties > Description",
        "section": "Description",
        "text": "Sherlock allows you to configure PCB modeling properties for multiple analysis types.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Configure PCB modeling properties for several analysis types.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#connect-to-sherlock",
        "title": "Update PCB Modeling Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#delete-project",
        "title": "Update PCB Modeling Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#import-tutorial-project",
        "title": "Update PCB Modeling Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties",
        "href": "examples/gallery_examples/04-analyses/update_pcb_modeling_properties.html#update-pcb-modeling-properties",
        "title": "Update PCB Modeling Properties",
        "section": "Update PCB Modeling Properties",
        "text": "Configure PCB modeling properties for various analysis types.\nDownload Jupyter notebook: update_pcb_modeling_properties.ipynb\nDownload Python source code: update_pcb_modeling_properties.py\nDownload zipped: update_pcb_modeling_properties.zip\nUpdate PCB Modeling Properties\nDownload Jupyter notebook: update_pcb_modeling_properties.ipynb\nDownload Python source code: update_pcb_modeling_properties.py\nDownload zipped: update_pcb_modeling_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file.html#update_test_fixtures_by_file",
        "title": "update_test_fixtures_by_file",
        "section": "update_test_fixtures_by_file",
        "text": "Update test fixture properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nPath for the CSV file with the test fixture properties.\nStatus code of the response. 0 for success.\nint\nupdate_test_fixtures_by_file\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file.html#ansys.sherlock.core.layer.Layer.update_test_fixtures_by_file",
        "title": "update_test_fixtures_by_file > update_test_fixtures_by_file > update_test_fixtures_by_file",
        "section": "update_test_fixtures_by_file > update_test_fixtures_by_file",
        "text": "Layer.update_test_fixtures_by_file(project, cca_name, file_path)\n\nUpdate test fixture properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nfile_path: str\n\nPath for the CSV file with the test fixture properties.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_test_fixtures_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"TestFixturesImport.csv\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location.html#get_part_location",
        "title": "get_part_location",
        "section": "get_part_location",
        "text": "Return the location properties for one or more part.\nAvailable Since: 2022R1\nName of the Sherlock project.\nName of the CCA.\nComma separated list of reference designators of parts to retrieve locations for.\nValid units for a part’s location.\nPartLocation for each part that corresponds to the reference designators.\nlist[PartLocation]\nget_part_location\npython:list\nPartLocation\nlist\nPartLocation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_part_location.html#ansys.sherlock.core.parts.Parts.get_part_location",
        "title": "get_part_location > get_part_location > get_part_location",
        "section": "get_part_location > get_part_location",
        "text": "Parts.get_part_location(project, cca_name, ref_des, location_units)\n\nReturn the location properties for one or more part.\n\nAvailable Since: 2022R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nref_des: str\n\nComma separated list of reference designators of parts to retrieve locations for.\n\nlocation_units: str\n\nValid units for a part’s location.\n\nReturns\n\n:\n\n\n\npython:list[PartLocation]\n\nPartLocation for each part that corresponds to the reference designators.\n\nReturn type\n\nlist[PartLocation]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> part_locations = sherlock.parts.get_part_location(\n    project=\"Test\",\n    cca_name=\"Card\",\n    ref_des=\"C1,C2\",\n    location_units=\"in\",\n)\n>>> print(f\"{part_locations}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod DeletePottingRegionRequest.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units.html#min_temperature_units",
        "title": "min_temperature_units",
        "section": "min_temperature_units",
        "text": "min_temperature_units\nstr\nmin_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units.html#ansys.sherlock.core.types.project_types.ImageFile.min_temperature_units",
        "title": "min_temperature_units > min_temperature_units > min_temperature_units",
        "section": "min_temperature_units > min_temperature_units",
        "text": "ImageFile.min_temperature_units\n\nmin_temperature_units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "RectangularShape.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.html#ansyssherlockcoretypeslayer_typespcbshape",
        "title": "ansys.sherlock.core.types.layer_types.PCBShape",
        "section": "ansys.sherlock.core.types.layer_types.PCBShape",
        "text": "Contains the properties for a PCB shape.\nPCBShape.construct([_fields_set])\n\nPCBShape.copy(*[, include, exclude, update, ...])\nReturns a copy of the model.\nPCBShape.dict(*[, include, exclude, ...])\n\nPCBShape.from_orm(obj)\n\nPCBShape.json(*[, include, exclude, ...])\n\nPCBShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPCBShape.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nPCBShape.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nPCBShape.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nPCBShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPCBShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPCBShape.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPCBShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPCBShape.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nPCBShape.model_validate_json(json_data, *[, ...])\n!!! abstract \"Usage Documentation\"\nPCBShape.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nPCBShape.parse_file(path, *[, content_type, ...])\n\nPCBShape.parse_obj(obj)\n\nPCBShape.parse_raw(b, *[, content_type, ...])\n\nPCBShape.schema([by_alias, ref_template])\n\nPCBShape.schema_json(*[, by_alias, ref_template])\n\nPCBShape.update_forward_refs(**localns)\n\nPCBShape.validate(value)\n\nPCBShape.model_computed_fields\n\nPCBShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPCBShape.model_extra\nGet extra fields set during validation.\nPCBShape.model_fields\n\nPCBShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nansys.sherlock.core.types.layer_types.PCBShape\nPCBShape.construct\nPCBShape.copy\nPCBShape.dict\nPCBShape.from_orm\nPCBShape.json\nPCBShape.model_construct\nPCBShape.model_copy\nPCBShape.model_dump\nPCBShape.model_dump_json\nPCBShape.model_json_schema\nPCBShape.model_parametrized_name\nPCBShape.model_post_init\nPCBShape.model_rebuild\nPCBShape.model_validate\nPCBShape.model_validate_json\nPCBShape.model_validate_strings\nPCBShape.parse_file\nPCBShape.parse_obj\nPCBShape.parse_raw\nPCBShape.schema\nPCBShape.schema_json\nPCBShape.update_forward_refs\nPCBShape.validate\nPCBShape.model_computed_fields\nPCBShape.model_config\nPCBShape.model_extra\nPCBShape.model_fields\nPCBShape.model_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.html#ansys.sherlock.core.types.layer_types.PCBShape",
        "title": "ansys.sherlock.core.types.layer_types.PCBShape > ansys.sherlock.core.types.layer_types.PCBShape > PCBShape",
        "section": "ansys.sherlock.core.types.layer_types.PCBShape > PCBShape",
        "text": "class ansys.sherlock.core.types.layer_types.PCBShape(**data)\n\nContains the properties for a PCB shape.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPCBShape.construct([_fields_set])\n\n\n\nPCBShape.copy(*[, include, exclude, update, ...])\n\nReturns a copy of the model.\n\nPCBShape.dict(*[, include, exclude, ...])\n\n\n\nPCBShape.from_orm(obj)\n\n\n\nPCBShape.json(*[, include, exclude, ...])\n\n\n\nPCBShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPCBShape.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nPCBShape.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPCBShape.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPCBShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPCBShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPCBShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPCBShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPCBShape.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nPCBShape.model_validate_json(json_data, *[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPCBShape.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nPCBShape.parse_file(path, *[, content_type, ...])\n\n\n\nPCBShape.parse_obj(obj)\n\n\n\nPCBShape.parse_raw(b, *[, content_type, ...])\n\n\n\nPCBShape.schema([by_alias, ref_template])\n\n\n\nPCBShape.schema_json(*[, by_alias, ref_template])\n\n\n\nPCBShape.update_forward_refs(**localns)\n\n\n\nPCBShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPCBShape.model_computed_fields\n\n\n\nPCBShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPCBShape.model_extra\n\nGet extra fields set during validation.\n\nPCBShape.model_fields\n\n\n\nPCBShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\n"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#update-solder-fatigue-properties",
        "title": "Update Solder Fatigue Properties",
        "section": "Update Solder Fatigue Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update solder fatigue properties.\nUpdate Solder Fatigue Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#description",
        "title": "Update Solder Fatigue Properties > Description",
        "section": "Description",
        "text": "This script shows how to configure solder fatigue properties for a PCB assembly.\nIt performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Update solder fatigue properties.\nFor further details, refer to the official documentation on solder fatigue properties in Sherlock.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#connect-to-sherlock",
        "title": "Update Solder Fatigue Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#delete-project",
        "title": "Update Solder Fatigue Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#import-tutorial-project",
        "title": "Update Solder Fatigue Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties",
        "href": "examples/gallery_examples/04-analyses/update_solder_fatigue_properties.html#update-solder-fatigue-properties",
        "title": "Update Solder Fatigue Properties",
        "section": "Update Solder Fatigue Properties",
        "text": "Configure solder fatigue properties for the PCB assembly.\nDownload Jupyter notebook: update_solder_fatigue_properties.ipynb\nDownload Python source code: update_solder_fatigue_properties.py\nDownload zipped: update_solder_fatigue_properties.zip\nUpdate Solder Fatigue Properties\nDownload Jupyter notebook: update_solder_fatigue_properties.ipynb\nDownload Python source code: update_solder_fatigue_properties.py\nDownload zipped: update_solder_fatigue_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points.html#delete_all_mount_points",
        "title": "delete_all_mount_points",
        "section": "delete_all_mount_points",
        "text": "Delete all mount points for a CCA.\nAvailable Since: 2022R2\nName of the Sherlock project.\nName of the CCA.\nStatus code of the response. 0 for success.\nint\ndelete_all_mount_points\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_all_mount_points.html#ansys.sherlock.core.layer.Layer.delete_all_mount_points",
        "title": "delete_all_mount_points > delete_all_mount_points > delete_all_mount_points",
        "section": "delete_all_mount_points > delete_all_mount_points",
        "text": "Layer.delete_all_mount_points(project, cca_name)\n\nDelete all mount points for a CCA.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_mount_points_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"MountPointImport.csv\",\n>>> )\n>>> sherlock.layer.delete_all_mount_points(\"Test\", \"Card\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.html#ansyssherlockcoretypeslayer_typesupdatepottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "text": "Contains the properties of a potting region update per project.\nUpdatePottingRegionRequest.construct([...])\n\nUpdatePottingRegionRequest.copy(*[, ...])\nReturns a copy of the model.\nUpdatePottingRegionRequest.dict(*[, ...])\n\nUpdatePottingRegionRequest.from_orm(obj)\n\nUpdatePottingRegionRequest.json(*[, ...])\n\nUpdatePottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nUpdatePottingRegionRequest.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nUpdatePottingRegionRequest.model_dump(*[, ...])\n!!! abstract \"Usage Documentation\"\nUpdatePottingRegionRequest.model_dump_json(*)\n!!! abstract \"Usage Documentation\"\nUpdatePottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nUpdatePottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nUpdatePottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nUpdatePottingRegionRequest.model_rebuild(*)\nTry to rebuild the pydantic-core schema for the model.\nUpdatePottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nUpdatePottingRegionRequest.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nUpdatePottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nUpdatePottingRegionRequest.parse_file(path, *)\n\nUpdatePottingRegionRequest.parse_obj(obj)\n\nUpdatePottingRegionRequest.parse_raw(b, *[, ...])\n\nUpdatePottingRegionRequest.schema([...])\n\nUpdatePottingRegionRequest.schema_json(*[, ...])\n\nUpdatePottingRegionRequest.str_validation(...)\nValidate string fields listed.\nUpdatePottingRegionRequest.update_forward_refs(...)\n\nUpdatePottingRegionRequest.validate(value)\n\nUpdatePottingRegionRequest.model_computed_fields\n\nUpdatePottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nUpdatePottingRegionRequest.model_extra\nGet extra fields set during validation.\nUpdatePottingRegionRequest.model_fields\n\nUpdatePottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nUpdatePottingRegionRequest.project\nName of the Sherlock project.\nUpdatePottingRegionRequest.update_potting_regions\nList of potting region data to update.\nansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest\nUpdatePottingRegionRequest.construct\nUpdatePottingRegionRequest.copy\nUpdatePottingRegionRequest.dict\nUpdatePottingRegionRequest.from_orm\nUpdatePottingRegionRequest.json\nUpdatePottingRegionRequest.model_construct\nUpdatePottingRegionRequest.model_copy\nUpdatePottingRegionRequest.model_dump\nUpdatePottingRegionRequest.model_dump_json\nUpdatePottingRegionRequest.model_json_schema\nUpdatePottingRegionRequest.model_parametrized_name\nUpdatePottingRegionRequest.model_post_init\nUpdatePottingRegionRequest.model_rebuild\nUpdatePottingRegionRequest.model_validate\nUpdatePottingRegionRequest.model_validate_json\nUpdatePottingRegionRequest.model_validate_strings\nUpdatePottingRegionRequest.parse_file\nUpdatePottingRegionRequest.parse_obj\nUpdatePottingRegionRequest.parse_raw\nUpdatePottingRegionRequest.schema\nUpdatePottingRegionRequest.schema_json\nUpdatePottingRegionRequest.str_validation\nUpdatePottingRegionRequest.update_forward_refs\nUpdatePottingRegionRequest.validate\nUpdatePottingRegionRequest.model_computed_fields\nUpdatePottingRegionRequest.model_config\nUpdatePottingRegionRequest.model_extra\nUpdatePottingRegionRequest.model_fields\nUpdatePottingRegionRequest.model_fields_set\nUpdatePottingRegionRequest.project\nUpdatePottingRegionRequest.update_potting_regions"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > UpdatePottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest > UpdatePottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest(**data)\n\nContains the properties of a potting region update per project.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nUpdatePottingRegionRequest.construct([...])\n\n\n\nUpdatePottingRegionRequest.copy(*[, ...])\n\nReturns a copy of the model.\n\nUpdatePottingRegionRequest.dict(*[, ...])\n\n\n\nUpdatePottingRegionRequest.from_orm(obj)\n\n\n\nUpdatePottingRegionRequest.json(*[, ...])\n\n\n\nUpdatePottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nUpdatePottingRegionRequest.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nUpdatePottingRegionRequest.model_dump(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nUpdatePottingRegionRequest.model_dump_json(*)\n\n!!! abstract \"Usage Documentation\"\n\nUpdatePottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nUpdatePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nUpdatePottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nUpdatePottingRegionRequest.model_rebuild(*)\n\nTry to rebuild the pydantic-core schema for the model.\n\nUpdatePottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nUpdatePottingRegionRequest.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nUpdatePottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nUpdatePottingRegionRequest.parse_file(path, *)\n\n\n\nUpdatePottingRegionRequest.parse_obj(obj)\n\n\n\nUpdatePottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nUpdatePottingRegionRequest.schema([...])\n\n\n\nUpdatePottingRegionRequest.schema_json(*[, ...])\n\n\n\nUpdatePottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nUpdatePottingRegionRequest.update_forward_refs(...)\n\n\n\nUpdatePottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nUpdatePottingRegionRequest.model_computed_fields\n\n\n\nUpdatePottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nUpdatePottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nUpdatePottingRegionRequest.model_fields\n\n\n\nUpdatePottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nUpdatePottingRegionRequest.project\n\nName of the Sherlock project.\n\nUpdatePottingRegionRequest.update_potting_regions\n\nList of potting region data to update.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod DeletePottingRegionRequest.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_dump.html#ansys.sherlock.core.types.project_types.OutlineFile.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "OutlineFile.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_dump.html#ansys.sherlock.core.types.layer_types.PCBShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PCBShape.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness.html#get_total_conductor_thickness",
        "title": "get_total_conductor_thickness",
        "section": "get_total_conductor_thickness",
        "text": "Return the total conductor thickness.\nAvailable Since: 2021R2\nSherlock project name.\nThe CCA name.\nUnits for laminate thickness.\nThe conductor thickness of the CCA in the specified units.\nfloat\nget_total_conductor_thickness\npython:float\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness.html#ansys.sherlock.core.stackup.Stackup.get_total_conductor_thickness",
        "title": "get_total_conductor_thickness > get_total_conductor_thickness > get_total_conductor_thickness",
        "section": "get_total_conductor_thickness > get_total_conductor_thickness",
        "text": "Stackup.get_total_conductor_thickness(project, cca_name, thickness_unit)\n\nReturn the total conductor thickness.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nSherlock project name.\n\ncca_name: str\n\nThe CCA name.\n\nthickness_unit: str, optional\n\nUnits for laminate thickness.\n\nReturns\n\n:\n\n\n\npython:float\n\nThe conductor thickness of the CCA in the specified units.\n\nReturn type\n\nfloat\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> total_thickness = sherlock.stackup.get_total_conductor_thickness(project=\"Tutorial\",\n                                                         cca_name=\"Main Board\",\n                                                         thickness_unit=\"oz\")\n>>>print(f\"{total_thickness}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.copy.html#ansys.sherlock.core.types.layer_types.PCBShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PCBShape.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "The name of the CCA.\ncca_name\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegion.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegion.cca_name: str\n\nThe name of the CCA.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump_json.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "GerberOutlineFile.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegion.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#add-harmonic-vibration-profiles",
        "title": "Add Harmonic Vibration Profiles",
        "section": "Add Harmonic Vibration Profiles",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\ncreate a lifecycle phase, add a harmonic event to the phase, and add harmonic\nvibration profiles.\nAdd Harmonic Vibration Profiles"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#description",
        "title": "Add Harmonic Vibration Profiles > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as adding harmonic vibration profiles\nto lifecycle phases.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Create a lifecycle phase.\n- Add a harmonic event to the lifecycle phase.\n- Add vibration profiles to the harmonic event.\nThe harmonic vibration profiles simulate the effects of vibration conditions on the board.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#connect-to-sherlock",
        "title": "Add Harmonic Vibration Profiles > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#delete-project",
        "title": "Add Harmonic Vibration Profiles > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#import-tutorial-project",
        "title": "Add Harmonic Vibration Profiles > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_profile",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_profile.html#create-lifecycle-phase-and-add-harmonic-event",
        "title": "Add Harmonic Vibration Profiles > Create Lifecycle Phase and Add Harmonic Event",
        "section": "Create Lifecycle Phase and Add Harmonic Event",
        "text": "Create a new lifecycle phase and add a harmonic event to it.\nDownload Jupyter notebook: add_harmonic_profile.ipynb\nDownload Python source code: add_harmonic_profile.py\nDownload zipped: add_harmonic_profile.zip\nCreate Lifecycle Phase and Add Harmonic Event\nDownload Jupyter notebook: add_harmonic_profile.ipynb\nDownload Python source code: add_harmonic_profile.py\nDownload zipped: add_harmonic_profile.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.html#ansyssherlockcoretypeslayer_typesslotshape",
        "title": "ansys.sherlock.core.types.layer_types.SlotShape",
        "section": "ansys.sherlock.core.types.layer_types.SlotShape",
        "text": "Contains the properties for a slot shape.\nSlotShape.construct([_fields_set])\n\nSlotShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nSlotShape.dict(*[, include, exclude, ...])\n\nSlotShape.from_orm(obj)\n\nSlotShape.json(*[, include, exclude, ...])\n\nSlotShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nSlotShape.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nSlotShape.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nSlotShape.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nSlotShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nSlotShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nSlotShape.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nSlotShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nSlotShape.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nSlotShape.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nSlotShape.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nSlotShape.parse_file(path, *[, ...])\n\nSlotShape.parse_obj(obj)\n\nSlotShape.parse_raw(b, *[, content_type, ...])\n\nSlotShape.schema([by_alias, ref_template])\n\nSlotShape.schema_json(*[, by_alias, ...])\n\nSlotShape.update_forward_refs(**localns)\n\nSlotShape.validate(value)\n\nSlotShape.model_computed_fields\n\nSlotShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nSlotShape.model_extra\nGet extra fields set during validation.\nSlotShape.model_fields\n\nSlotShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nSlotShape.length\nfloat\nSlotShape.width\nfloat\nSlotShape.node_count\nint\nSlotShape.center_x\nfloat\nSlotShape.center_y\nfloat\nSlotShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.SlotShape\nSlotShape.construct\nSlotShape.copy\nSlotShape.dict\nSlotShape.from_orm\nSlotShape.json\nSlotShape.model_construct\nSlotShape.model_copy\nSlotShape.model_dump\nSlotShape.model_dump_json\nSlotShape.model_json_schema\nSlotShape.model_parametrized_name\nSlotShape.model_post_init\nSlotShape.model_rebuild\nSlotShape.model_validate\nSlotShape.model_validate_json\nSlotShape.model_validate_strings\nSlotShape.parse_file\nSlotShape.parse_obj\nSlotShape.parse_raw\nSlotShape.schema\nSlotShape.schema_json\nSlotShape.update_forward_refs\nSlotShape.validate\nSlotShape.model_computed_fields\nSlotShape.model_config\nSlotShape.model_extra\nSlotShape.model_fields\nSlotShape.model_fields_set\nSlotShape.length\nSlotShape.width\nSlotShape.node_count\nSlotShape.center_x\nSlotShape.center_y\nSlotShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.html#ansys.sherlock.core.types.layer_types.SlotShape",
        "title": "ansys.sherlock.core.types.layer_types.SlotShape > ansys.sherlock.core.types.layer_types.SlotShape > SlotShape",
        "section": "ansys.sherlock.core.types.layer_types.SlotShape > SlotShape",
        "text": "class ansys.sherlock.core.types.layer_types.SlotShape(**data)\n\nContains the properties for a slot shape.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nSlotShape.construct([_fields_set])\n\n\n\nSlotShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nSlotShape.dict(*[, include, exclude, ...])\n\n\n\nSlotShape.from_orm(obj)\n\n\n\nSlotShape.json(*[, include, exclude, ...])\n\n\n\nSlotShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nSlotShape.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nSlotShape.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nSlotShape.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nSlotShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nSlotShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nSlotShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nSlotShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nSlotShape.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nSlotShape.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nSlotShape.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nSlotShape.parse_file(path, *[, ...])\n\n\n\nSlotShape.parse_obj(obj)\n\n\n\nSlotShape.parse_raw(b, *[, content_type, ...])\n\n\n\nSlotShape.schema([by_alias, ref_template])\n\n\n\nSlotShape.schema_json(*[, by_alias, ...])\n\n\n\nSlotShape.update_forward_refs(**localns)\n\n\n\nSlotShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nSlotShape.model_computed_fields\n\n\n\nSlotShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nSlotShape.model_extra\n\nGet extra fields set during validation.\n\nSlotShape.model_fields\n\n\n\nSlotShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nSlotShape.length\n\nfloat\n\nSlotShape.width\n\nfloat\n\nSlotShape.node_count\n\nint\n\nSlotShape.center_x\n\nfloat\n\nSlotShape.center_y\n\nfloat\n\nSlotShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.html#ansyssherlockcoretypeslayer_typespottingregiondeletedata",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "text": "Data specifying potting regions to delete.\nPottingRegionDeleteData.construct([_fields_set])\n\nPottingRegionDeleteData.copy(*[, include, ...])\nReturns a copy of the model.\nPottingRegionDeleteData.dict(*[, include, ...])\n\nPottingRegionDeleteData.from_orm(obj)\n\nPottingRegionDeleteData.json(*[, include, ...])\n\nPottingRegionDeleteData.model_construct([...])\nCreates a new instance of the Model class with validated data.\nPottingRegionDeleteData.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionDeleteData.model_dump(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionDeleteData.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nPottingRegionDeleteData.model_json_schema([...])\nGenerates a JSON schema for a model class.\nPottingRegionDeleteData.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPottingRegionDeleteData.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPottingRegionDeleteData.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nPottingRegionDeleteData.model_validate(obj, *)\nValidate a pydantic model instance.\nPottingRegionDeleteData.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nPottingRegionDeleteData.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPottingRegionDeleteData.parse_file(path, *)\n\nPottingRegionDeleteData.parse_obj(obj)\n\nPottingRegionDeleteData.parse_raw(b, *[, ...])\n\nPottingRegionDeleteData.schema([by_alias, ...])\n\nPottingRegionDeleteData.schema_json(*[, ...])\n\nPottingRegionDeleteData.str_validation(...)\nValidate string fields listed.\nPottingRegionDeleteData.update_forward_refs(...)\n\nPottingRegionDeleteData.validate(value)\n\nPottingRegionDeleteData.model_computed_fields\n\nPottingRegionDeleteData.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPottingRegionDeleteData.model_extra\nGet extra fields set during validation.\nPottingRegionDeleteData.model_fields\n\nPottingRegionDeleteData.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPottingRegionDeleteData.cca_name\nName of the CCA containing the potting region(s) to delete.\nPottingRegionDeleteData.potting_id\nId of the potting region(s) to delete.\nansys.sherlock.core.types.layer_types.PottingRegionDeleteData\nPottingRegionDeleteData.construct\nPottingRegionDeleteData.copy\nPottingRegionDeleteData.dict\nPottingRegionDeleteData.from_orm\nPottingRegionDeleteData.json\nPottingRegionDeleteData.model_construct\nPottingRegionDeleteData.model_copy\nPottingRegionDeleteData.model_dump\nPottingRegionDeleteData.model_dump_json\nPottingRegionDeleteData.model_json_schema\nPottingRegionDeleteData.model_parametrized_name\nPottingRegionDeleteData.model_post_init\nPottingRegionDeleteData.model_rebuild\nPottingRegionDeleteData.model_validate\nPottingRegionDeleteData.model_validate_json\nPottingRegionDeleteData.model_validate_strings\nPottingRegionDeleteData.parse_file\nPottingRegionDeleteData.parse_obj\nPottingRegionDeleteData.parse_raw\nPottingRegionDeleteData.schema\nPottingRegionDeleteData.schema_json\nPottingRegionDeleteData.str_validation\nPottingRegionDeleteData.update_forward_refs\nPottingRegionDeleteData.validate\nPottingRegionDeleteData.model_computed_fields\nPottingRegionDeleteData.model_config\nPottingRegionDeleteData.model_extra\nPottingRegionDeleteData.model_fields\nPottingRegionDeleteData.model_fields_set\nPottingRegionDeleteData.cca_name\nPottingRegionDeleteData.potting_id"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData",
        "title": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > PottingRegionDeleteData",
        "section": "ansys.sherlock.core.types.layer_types.PottingRegionDeleteData > PottingRegionDeleteData",
        "text": "class ansys.sherlock.core.types.layer_types.PottingRegionDeleteData(**data)\n\nData specifying potting regions to delete.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPottingRegionDeleteData.construct([_fields_set])\n\n\n\nPottingRegionDeleteData.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nPottingRegionDeleteData.dict(*[, include, ...])\n\n\n\nPottingRegionDeleteData.from_orm(obj)\n\n\n\nPottingRegionDeleteData.json(*[, include, ...])\n\n\n\nPottingRegionDeleteData.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nPottingRegionDeleteData.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionDeleteData.model_dump(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionDeleteData.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionDeleteData.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nPottingRegionDeleteData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPottingRegionDeleteData.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPottingRegionDeleteData.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPottingRegionDeleteData.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nPottingRegionDeleteData.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nPottingRegionDeleteData.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPottingRegionDeleteData.parse_file(path, *)\n\n\n\nPottingRegionDeleteData.parse_obj(obj)\n\n\n\nPottingRegionDeleteData.parse_raw(b, *[, ...])\n\n\n\nPottingRegionDeleteData.schema([by_alias, ...])\n\n\n\nPottingRegionDeleteData.schema_json(*[, ...])\n\n\n\nPottingRegionDeleteData.str_validation(...)\n\nValidate string fields listed.\n\nPottingRegionDeleteData.update_forward_refs(...)\n\n\n\nPottingRegionDeleteData.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPottingRegionDeleteData.model_computed_fields\n\n\n\nPottingRegionDeleteData.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPottingRegionDeleteData.model_extra\n\nGet extra fields set during validation.\n\nPottingRegionDeleteData.model_fields\n\n\n\nPottingRegionDeleteData.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPottingRegionDeleteData.cca_name\n\nName of the CCA containing the potting region(s) to delete.\n\nPottingRegionDeleteData.potting_id\n\nId of the potting region(s) to delete.\n\n"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/index",
        "href": "examples/gallery_examples/01-project-configuration/index.html#project-configuration",
        "title": "Project Configuration",
        "section": "Project Configuration",
        "text": "Examples on how to configure a project using PySherlock.\nsphx_glr_examples_gallery_examples_01-project-configuration_add_cca.py\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_event.py\nsphx_glr_examples_gallery_examples_01-project-configuration_add_harmonic_profile.py\nsphx_glr_examples_gallery_examples_01-project-configuration_add_modeling_region.py\nsphx_glr_examples_gallery_examples_01-project-configuration_add_potting_region.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_laminate_layer.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_mount_points_by_file.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_location_by_file.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_part_modeling_properties.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_parts_list_properties.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_potting_region.py\nsphx_glr_examples_gallery_examples_01-project-configuration_update_thermal_maps.py\nProject Configuration"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps.html#add_thermal_maps",
        "title": "add_thermal_maps",
        "section": "add_thermal_maps",
        "text": "Add thermal map files to a Sherlock project.\nAvailable Since: 2024R2\nName of the Sherlock project to add thermal maps to.\nList of thermal map files consisting of these properties:\nFull path to the thermal map file to add.\nList of thermal map properties consisting of these properties:\nName of the thermal file to update.\nThermal maps file type.\nComment to associate with the file.\nThermal board side.\nThe properties of the thermal map file to update.\nList of thermal profiles.\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nStatus code of the response. 0 for success.\nint\nadd_thermal_maps\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_thermal_maps.html#ansys.sherlock.core.project.Project.add_thermal_maps",
        "title": "add_thermal_maps > add_thermal_maps > add_thermal_maps",
        "section": "add_thermal_maps > add_thermal_maps",
        "text": "Project.add_thermal_maps(project, add_thermal_map_files)\n\nAdd thermal map files to a Sherlock project.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project to add thermal maps to.\n\nadd_thermal_map_files: list[dict[str, list[dict[str, str | ThermalMapsFileType                | ThermalBoardSide | CsvExcelFile | IcepakFile | ImageFile | list[str]]] | str]]\n\nList of thermal map files consisting of these properties:\n\nthermal_map_file: str\n\nFull path to the thermal map file to add.\n\nthermal_map_file_properties: list\n\nList of thermal map properties consisting of these properties:\n\nfile_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile | IcepakFile | ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    ThermalBoardSide,\n    ThermalMapsFileType,\n)\n>>> sherlock = launch_sherlock()\n>>> thermal_map_properties = ImageFile(board_bounds=BoardBounds([\n    (1.0, 2.0),\n    (3.0, 4.0),\n    (1.0, 2.0),\n    (1.0, 2.0)]),\n    coordinate_units=\"in\",\n    image_bounds=ImageBounds(0.0, 0.0, 10.0, 8.0),\n    legend_bounds=LegendBounds(1.0, 2.0, 4.0, 2.0),\n    legend_orientation=LegendOrientation.VERTICAL,\n    min_temperature=20.0,\n    min_temperature_units=\"C\",\n    max_temperature=50.0,\n    max_temperature_units=\"C\"\n)\n>>> files = [\n    {\n        \"thermal_map_file\": \"Thermal Image.jpg\",\n        \"thermal_map_file_properties\": [\n            {\n                \"file_name\": \"Thermal Image.jpg\",\n                \"file_type\": ThermalMapsFileType.IMAGE,\n                \"file_comment\": \"Update thermal map\",\n                \"thermal_board_side\": ThermalBoardSide.TOP,\n                \"file_data\": thermal_map_properties,\n                \"thermal_profiles\": [\"Environmental/1 - Temp Cycle - Min\"],\n                \"cca_names\": [\"CCA1\", \"CCA2\"]\n            },\n        ]\n    }\n]\n>>> sherlock.project.add_thermal_maps(\"Tutorial Project\", files)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod DeletePottingRegionRequest.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.construct.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod GerberOutlineFile.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionDeleteData.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#user-guide",
        "title": "User guide",
        "section": "User guide",
        "text": "This section provides an overview of PySherlock and explains how to use it.\nUser guide"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#prerequisites",
        "title": "User guide > Prerequisites",
        "section": "Prerequisites",
        "text": "For installation instructions and information on launching Sherlock and the gRPC server,\nsee ref_getting_started. The Sherlock gRPC server must be running to use PySherlock.\nPrerequisites"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#pysherlock-services",
        "title": "User guide > PySherlock services",
        "section": "PySherlock services",
        "text": "PySherlock methods are divided into modules that correspond to major Sherlock functional areas.\nFor descriptions of each module’s classes, methods, and functions, see ref_api_ref.\nPySherlock services"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#using-pysherlock",
        "title": "User guide > Using PySherlock",
        "section": "Using PySherlock",
        "text": "After the Sherlock gRPC server is started, you can use PySherlock to perform Sherlock\nclient operations.\nSubsequent topics describe how to use PySherlock to automate the process depicted in this diagram:\nUsing PySherlock"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#launch-sherlock",
        "title": "User guide > Launch Sherlock",
        "section": "Launch Sherlock",
        "text": "Use the launch_sherlock()\nmethod to launch Sherlock and start the gRPC server on the default port:\nThis method returns the sherlock gRPC connection object, which is used to invoke\nthe APIs from their respective services.\nLaunch Sherlock\nlaunch_sherlock()\nsherlock"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#import-odb-archive-file",
        "title": "User guide > Import ODB++ archive file",
        "section": "Import ODB++ archive file",
        "text": "Use the import_odb_archive()\nmethod to import the ODB++ archive file (ODB++ Tutorial.tgz).\nThis code imports the archive file and creates a project named Tutorial with a CCA\nnamed Main Board:\nFor information on the project module and its methods, see ref_project_module.\nImport ODB++ archive file\nimport_odb_archive()\nODB++ Tutorial.tgz\nTutorial\nMain Board\nproject"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#update-parts-list",
        "title": "User guide > Update parts list",
        "section": "Update parts list",
        "text": "Use the update_parts_list() method\nto update the parts list for the previously created CCA Main Board.\nThis code uses the Sherlock Part Library to update the parts list:\nFor information on the parts module and its methods, see ref_parts_module.\nUpdate parts list\nupdate_parts_list()\nMain Board\nparts"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#add-random-vibe-event",
        "title": "User guide > Add random vibe event",
        "section": "Add random vibe event",
        "text": "Use the add_random_vibe_event()\nmethod to add a random vibe event:\nFor information on the lifecycle module and its methods, see ref_lifecycle_module.\nAdd random vibe event\nadd_random_vibe_event()\nlifecycle"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#add-random-vibe-profile",
        "title": "User guide > Add random vibe profile",
        "section": "Add random vibe profile",
        "text": "Use the add_random_vibe_profiles()\nmethod to add a random vibe profile:\nFor information on the lifecycle module and its methods, see ref_lifecycle_module.\nAdd random vibe profile\nadd_random_vibe_profiles()\nlifecycle"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#run-analysis",
        "title": "User guide > Run analysis",
        "section": "Run analysis",
        "text": "Use the run_analysis() method\nto run a random vibe analysis:\nFor information on the analysis module and its methods, see ref_analysis_module.\nRun analysis\nrun_analysis()\nanalysis"
    },
    {
        "objectID": "user_guide/index",
        "href": "user_guide/index.html#generate-sherlock-report",
        "title": "User guide > Generate Sherlock report",
        "section": "Generate Sherlock report",
        "text": "Use the generate_project_report()\nmethod to generate a Sherlock report for the project Tutorial and save it to a PDF file\nin C:\\Temp\\tutorial_project_report.pdf:\nFor information on the project module and its methods, see ref_project_module.\nGenerate Sherlock report\ngenerate_project_report()\nTutorial\nC:\\Temp\\tutorial_project_report.pdf\nproject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm.html#ansys.sherlock.core.types.layer_types.PolygonalShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PolygonalShape.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod CopyPottingRegionRequest.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_validate.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod RectangularShape.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegionDeleteData.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.delete_parts_from_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.delete_parts_from_parts_list.html#delete_parts_from_parts_list",
        "title": "delete_parts_from_parts_list",
        "section": "delete_parts_from_parts_list",
        "text": "Delete parts from the parts list for a given project’s CCA.\nContains all the information needed to delete parts from the\nparts list in a project’s CCA.\nStatus of the delete operation and any error messages.\nlist[DeletePartsFromPartsListResponse]\ndelete_parts_from_parts_list\npython:list\nSherlockPartsService_pb2.DeletePartsFromPartsListResponse\nlist\nDeletePartsFromPartsListResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.delete_parts_from_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.delete_parts_from_parts_list.html#ansys.sherlock.core.parts.Parts.delete_parts_from_parts_list",
        "title": "delete_parts_from_parts_list > delete_parts_from_parts_list > delete_parts_from_parts_list",
        "section": "delete_parts_from_parts_list > delete_parts_from_parts_list",
        "text": "Parts.delete_parts_from_parts_list(request)\n\nDelete parts from the parts list for a given project’s CCA.\n\nParameters\n\nrequest: DeletePartsFromPartsListRequest\n\nContains all the information needed to delete parts from the\nparts list in a project’s CCA.\n\nReturns\n\n:\n\n\n\npython:list[SherlockPartsService_pb2.DeletePartsFromPartsListResponse]\n\nStatus of the delete operation and any error messages.\n\nReturn type\n\nlist[DeletePartsFromPartsListResponse]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.parts_types import (\n        DeletePartsFromPartsListRequest,\n    )\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\n        project=\"Assembly Tutorial\",\n        category=\"category\",\n        archive_file=\\\n            \"C:\\\\Program Files\\\\ANSYS Inc\\\\v252\\\\sherlock\\\\tutorial\\\\Assembly Tutorial.zip\",\n    )\n>>> request = DeletePartsFromPartsListRequest(\n        project=\"Assembly Tutorial\",\n        cca_name=\"Main Board\",\n        reference_designators=[\"U1\", \"R2\", \"C3\"],\n    )\n>>> response = sherlock.parts.delete_parts_from_parts_list(request)\n>>> for res in response:\n        print(f\"Return code: value={res.returnCode.value},\n        message={res.returnCode.message}, \"\n            f\"reference designator={res.reference_designators}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionCopyData.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields",
        "href": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields.html#get-random-vibration-analysis-inputs",
        "title": "Get Random Vibration Analysis inputs",
        "section": "Get Random Vibration Analysis inputs",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand retrieve the analysis input fields.\nGet Random Vibration Analysis inputs"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields",
        "href": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields.html#description",
        "title": "Get Random Vibration Analysis inputs > Description",
        "section": "Description",
        "text": "Sherlock provides the ability to run a random vibration analysis using its gRPC interface.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Retrieve the input fields required for random vibration analysis.\nThis example assumes you have already set up Sherlock and the necessary environment.\nFor more details on vibration analysis in Sherlock, refer to the official documentation.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields",
        "href": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields.html#connect-to-sherlock",
        "title": "Get Random Vibration Analysis inputs > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields",
        "href": "examples/gallery_examples/04-analyses/get_random_vibe_inputs_fields.html#get-random-vibration-input-fields",
        "title": "Get Random Vibration Analysis inputs > Get Random Vibration Input Fields",
        "section": "Get Random Vibration Input Fields",
        "text": "Retrieve the list of input fields for the random vibration analysis.\nDownload Jupyter notebook: get_random_vibe_inputs_fields.ipynb\nDownload Python source code: get_random_vibe_inputs_fields.py\nDownload zipped: get_random_vibe_inputs_fields.zip\nGet Random Vibration Input Fields\nDownload Jupyter notebook: get_random_vibe_inputs_fields.ipynb\nDownload Python source code: get_random_vibe_inputs_fields.py\nDownload zipped: get_random_vibe_inputs_fields.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod PottingRegionUpdateData.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points.html#export_all_test_points",
        "title": "export_all_test_points",
        "section": "export_all_test_points",
        "text": "Export the test point properties for a CCA.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nFull path for the CSV file to export the test points list to.\nLength units to use when exporting the test points.\nThe default is DEFAULT.\nDisplacement units to use when exporting the test points.\nThe default is DEFAULT.\nForce units to use when exporting the test points.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_test_points\nDEFAULT\nDEFAULT\nDEFAULT\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_points.html#ansys.sherlock.core.layer.Layer.export_all_test_points",
        "title": "export_all_test_points > export_all_test_points > export_all_test_points",
        "section": "export_all_test_points > export_all_test_points",
        "text": "Layer.export_all_test_points(project, cca_name, export_file, length_units='DEFAULT', displacement_units='DEFAULT', force_units='DEFAULT')\n\nExport the test point properties for a CCA.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nexport_file: str\n\nFull path for the CSV file to export the test points list to.\n\nlength_units: str, optional\n\nLength units to use when exporting the test points.\nThe default is DEFAULT.\n\ndisplacement_units: str, optional\n\nDisplacement units to use when exporting the test points.\nThe default is DEFAULT.\n\nforce_units: str, optional\n\nForce units to use when exporting the test points.\nThe default is DEFAULT.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.export_all_test_points(\n>>>     \"Tutorial Project\",\n>>>     \"Card\",\n>>>     \"TestPointsExport.csv\",\n>>>     \"DEFAULT\",\n>>>     \"DEFAULT\",\n>>>     \"DEFAULT\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_copy.html#ansys.sherlock.core.types.project_types.OutlineFile.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "OutlineFile.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#add-circuit-card-assembly",
        "title": "Add Circuit Card Assembly",
        "section": "Add Circuit Card Assembly",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand add a CCA (Circuit Card Assembly) to a project.\nAdd Circuit Card Assembly"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#description",
        "title": "Add Circuit Card Assembly > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as adding CCAs to a project\nand importing ODB++ archives.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Add CCAs to the project.\nThe added CCAs allow for proper circuit analysis and component tracking within the project.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#connect-to-sherlock",
        "title": "Add Circuit Card Assembly > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#delete-project",
        "title": "Add Circuit Card Assembly > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#import-tutorial-project",
        "title": "Add Circuit Card Assembly > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_cca",
        "href": "examples/gallery_examples/01-project-configuration/add_cca.html#add-cca-to-project",
        "title": "Add Circuit Card Assembly > Add CCA to Project",
        "section": "Add CCA to Project",
        "text": "Add a CCA to a project.\nDownload Jupyter notebook: add_cca.ipynb\nDownload Python source code: add_cca.py\nDownload zipped: add_cca.zip\nAdd CCA to Project\nDownload Jupyter notebook: add_cca.ipynb\nDownload Python source code: add_cca.py\nDownload zipped: add_cca.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region.html#add_potting_region",
        "title": "add_potting_region",
        "section": "add_potting_region",
        "text": "Add one or more potting regions to a given project.\nAvailable Since: 2024R1\nName of the Sherlock project.\nPotting region properties consisting of these properties:\nName of the CCA.\nPotting ID. The default is None.\nThe side to add the potting region to. The default is None.\nOptions are \"TOP\", \"BOTTOM\", and \"BOT\".\nThe potting material. The default is None.\nThe potting region units. The default is None.\nThe potting thickness. The default is None.\nThe potting standoff. The default is None.\nThe shape of the potting region.\nStatus code of the response. 0 for success.\nint\nadd_potting_region\nNone\nNone\n\"TOP\"\n\"BOTTOM\"\n\"BOT\"\nNone\nNone\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_potting_region.html#ansys.sherlock.core.layer.Layer.add_potting_region",
        "title": "add_potting_region > add_potting_region > add_potting_region",
        "section": "add_potting_region > add_potting_region",
        "text": "Layer.add_potting_region(project, potting_regions)\n\nAdd one or more potting regions to a given project.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\npotting_regions: list[dict[str, float | str | PolygonalShape | RectangularShape | SlotShape | CircularShape | PCBShape]]\n\nPotting region properties consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\npotting_id: str\n\nPotting ID. The default is None.\n\nside: str\n\nThe side to add the potting region to. The default is None.\nOptions are \"TOP\", \"BOTTOM\", and \"BOT\".\n\nmaterial: str\n\nThe potting material. The default is None.\n\npotting_units: str\n\nThe potting region units. The default is None.\n\nthickness: float\n\nThe potting thickness. The default is None.\n\nstandoff: float\n\nThe potting standoff. The default is None.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the potting region.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import PolygonalShape\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> polygonal_shape = PolygonalShape(points=[\n>>>     (0, 0),\n>>>     (0, 6.35),\n>>>     (9.77, 0)\n>>> ], rotation=87.8)\n>>> sherlock.layer.add_potting_region(\n>>> \"Test\",\n>>> [{\n>>>     'cca_name': 'Card',\n>>>     'potting_id': 'Test Region',\n>>>     'side': 'TOP',\n>>>     'material': 'epoxyencapsulant',\n>>>     'potting_units': 'in',\n>>>     'thickness': 0.1,\n>>>     'standoff': 0.2,\n>>>     'shape': polygonal_shape\n>>> },\n>>> ])\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.exit",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.exit.html#exit",
        "title": "exit",
        "section": "exit",
        "text": "Close the gRPC connection.\nAvailable Since: 2023R1\nWhether to close the Sherlock client when the gRPC connection is closed. The default\nis False, in which case the Sherlock client remains open when the gRPC connection\nis closed.\nexit\noptional\nFalse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common.exit",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.exit.html#ansys.sherlock.core.common.Common.exit",
        "title": "exit > exit > exit",
        "section": "exit > exit",
        "text": "Common.exit(close_sherlock_client=False)\n\nClose the gRPC connection.\n\nAvailable Since: 2023R1\n\nParameters\n\nclose_sherlock_client\n\nbool, optional\n\nWhether to close the Sherlock client when the gRPC connection is closed. The default\nis False, in which case the Sherlock client remains open when the gRPC connection\nis closed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region.html#create_cca_from_modeling_region",
        "title": "create_cca_from_modeling_region",
        "section": "create_cca_from_modeling_region",
        "text": "Create one or more CCAs from modeling regions in a given project.\nName of the Sherlock project.\nCCAs to be created from modeling regions consisting of these properties:\nName of the CCA.\nName of the modeling region.\nDescription of the CCA.\nThe default solder type. The default is None.\nThe default stencil thickness. The default is None.\nUnits for default stencil thickness. The default is None.\nDefault part temp rise. The default is None.\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nWhether to enable guess part properties. The default is None.\nWhether to generate image layers or not.  The default is None.\nStatus code of the response. 0 for success.\nint\ncreate_cca_from_modeling_region\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.create_cca_from_modeling_region.html#ansys.sherlock.core.project.Project.create_cca_from_modeling_region",
        "title": "create_cca_from_modeling_region > create_cca_from_modeling_region > create_cca_from_modeling_region",
        "section": "create_cca_from_modeling_region > create_cca_from_modeling_region",
        "text": "Project.create_cca_from_modeling_region(project, cca_from_mr_properties)\n\nCreate one or more CCAs from modeling regions in a given project.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_from_mr_properties: list[dict[str, bool | float | str]]\n\nCCAs to be created from modeling regions consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nmodeling_region_id: str\n\nName of the modeling region.\n\ndescription: str\n\nDescription of the CCA.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties: bool\n\nWhether to enable guess part properties. The default is None.\n\ngenerate_image_layers: bool\n\nWhether to generate image layers or not.  The default is None.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.project.create_cca_from_modeling_region(\n    \"Test\",\n    [{\n        'cca_name': 'Card',\n        'modeling_region_id': 'MR1'\n        'description': 'Test',\n        'default_solder_type': 'SAC305',\n        'default_stencil_thickness': 10,\n        'default_stencil_thickness_units': 'mm',\n        'default_part_temp_rise': 20,\n        'default_part_temp_rise_units': 'C',\n        'guess_part_properties': False,\n        'generate_image_layers': False,\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#run-mechanical-shock-analysis",
        "title": "Run Mechanical Shock Analysis",
        "section": "Run Mechanical Shock Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand configure mechanical shock analysis properties.\nRun Mechanical Shock Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#description",
        "title": "Run Mechanical Shock Analysis > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform mechanical shock analysis.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Configure the properties for mechanical shock analysis.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#connect-to-sherlock",
        "title": "Run Mechanical Shock Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#delete-project",
        "title": "Run Mechanical Shock Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#import-tutorial-project",
        "title": "Run Mechanical Shock Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties",
        "href": "examples/gallery_examples/04-analyses/update_mechanical_shock_properties.html#update-mechanical-shock-properties",
        "title": "Run Mechanical Shock Analysis > Update Mechanical Shock Properties",
        "section": "Update Mechanical Shock Properties",
        "text": "Configure properties for mechanical shock analysis.\nDownload Jupyter notebook: update_mechanical_shock_properties.ipynb\nDownload Python source code: update_mechanical_shock_properties.py\nDownload zipped: update_mechanical_shock_properties.zip\nUpdate Mechanical Shock Properties\nDownload Jupyter notebook: update_mechanical_shock_properties.ipynb\nDownload Python source code: update_mechanical_shock_properties.py\nDownload zipped: update_mechanical_shock_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionUpdateData.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.json.html#ansys.sherlock.core.types.layer_types.PCBShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PCBShape.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod UpdatePottingRegionRequest.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_project",
        "href": "examples/gallery_examples/03-exporting/export_project.html#sherlock-project-export",
        "title": "Sherlock Project Export",
        "section": "Sherlock Project Export",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export the project in multiple configurations.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including project export.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a tutorial project ZIP archive.\n- Export a project with different configurations.\nSherlock Project Export"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_project",
        "href": "examples/gallery_examples/03-exporting/export_project.html#connect-to-sherlock",
        "title": "Sherlock Project Export > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_project",
        "href": "examples/gallery_examples/03-exporting/export_project.html#delete-project",
        "title": "Sherlock Project Export > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_project",
        "href": "examples/gallery_examples/03-exporting/export_project.html#import-tutorial-project",
        "title": "Sherlock Project Export > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import a sample project ZIP archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_project",
        "href": "examples/gallery_examples/03-exporting/export_project.html#export-project",
        "title": "Sherlock Project Export > Export Project",
        "section": "Export Project",
        "text": "Export the imported project with different configurations.\nDownload Jupyter notebook: export_project.ipynb\nDownload Python source code: export_project.py\nDownload zipped: export_project.zip\nExport Project\nDownload Jupyter notebook: export_project.ipynb\nDownload Python source code: export_project.py\nDownload zipped: export_project.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props.html#update_solder_fatigue_props",
        "title": "update_solder_fatigue_props",
        "section": "update_solder_fatigue_props",
        "text": "Update properties for a solder fatigue analysis.\nAvailable Since: 2024R1\nName of the Sherlock project.\nMechanical shock properties for a CCA consisting of these properties:\nName of the CCA.\nSolder material. The default is None.\nPart temperature. The default is None.\nPart temperature units. The default is None.\nwhether to apply min temp rise. The default is None.\nWhether to enable part validation. The default is None.\nStatus code of the response. 0 for success.\nint\nupdate_solder_fatigue_props\nNone\nNone\nNone\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props.html#ansys.sherlock.core.analysis.Analysis.update_solder_fatigue_props",
        "title": "update_solder_fatigue_props > update_solder_fatigue_props > update_solder_fatigue_props",
        "section": "update_solder_fatigue_props > update_solder_fatigue_props",
        "text": "Analysis.update_solder_fatigue_props(project, solder_fatigue_properties)\n\nUpdate properties for a solder fatigue analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nsolder_fatigue_properties: list[dict[str, bool | float | str]]\n\nMechanical shock properties for a CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nsolder_material: str\n\nSolder material. The default is None.\n\npart_temp: float\n\nPart temperature. The default is None.\n\npart_temp_units: str\n\nPart temperature units. The default is None.\n\nuse_part_temp_rise_min: bool\n\nwhether to apply min temp rise. The default is None.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_solder_fatigue_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"solder_material\": \"TIN-LEAD (63SN37PB)\",\n        \"part_temp\": 70,\n        \"part_temp_units\": \"F\",\n        \"use_part_temp_rise_min\": True,\n        \"part_validation_enabled\": True\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_outline_file",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_outline_file.html#add_outline_file",
        "title": "add_outline_file",
        "section": "add_outline_file",
        "text": "Add outline files to a Sherlock project.\nAvailable Since: 2025R2\nContains the information needed to add an outline file to a Sherlock project.\nReturn codes for each request.\nlist[ReturnCode]\nadd_outline_file\nAddOutlineFileRequest\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_outline_file",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_outline_file.html#ansys.sherlock.core.project.Project.add_outline_file",
        "title": "add_outline_file > add_outline_file > add_outline_file",
        "section": "add_outline_file > add_outline_file",
        "text": "Project.add_outline_file(request)\n\nAdd outline files to a Sherlock project.\n\nAvailable Since: 2025R2\n\nParameters\n\nrequest\n\nAddOutlineFileRequest\n\nContains the information needed to add an outline file to a Sherlock project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.types.project_types import AddOutlineFileRequest\n>>> from ansys.sherlock.core.types.project_types import CsvExcelOutlineFile\n>>> from ansys.sherlock.core.types.project_types import OutlineFile\n>>> from ansys.sherlock.core.types.project_types import OutlineFileType\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> responses = sherlock.project.add_outline_file(\n>>>     AddOutlineFileRequest(\n>>>         project=\"TestProject\",\n>>>         outline_files = [\n>>>             OutlineFile(\n>>>                 cca_names=[\"TestCCA\"],\n>>>                 file_name=\"path/to/outline.csv\",\n>>>                 file_type=OutlineFileType.CSV_EXCEL,\n>>>                 outline_file_data=CsvExcelOutlineFile(\n>>>                     header_row_count=0,\n>>>                     location_units=\"mm\",\n>>>                     x_location_column=\"X\",\n>>>                     y_location_column=\"Y\",\n>>>                 )\n>>>             )\n>>>         ]\n>>>     )\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units.html#temperature_units",
        "title": "temperature_units",
        "section": "temperature_units",
        "text": "temperature_units\nstr\ntemperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units.html#ansys.sherlock.core.types.project_types.CsvExcelFile.temperature_units",
        "title": "temperature_units > temperature_units > temperature_units",
        "section": "temperature_units > temperature_units",
        "text": "CsvExcelFile.temperature_units\n\ntemperature_units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.rotation.html#ansys.sherlock.core.types.layer_types.CircularShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "CircularShape.rotation: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.copy.html#ansys.sherlock.core.types.layer_types.PottingRegion.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegion.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_copy.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "RectangularShape.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file.html#update_parts_locations_by_file",
        "title": "update_parts_locations_by_file",
        "section": "update_parts_locations_by_file",
        "text": "Update one or more part locations using a CSV file.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nFull path to the file with the components and location properties.\nNumeric format for the file, which indicates whether commas or points\nare used as decimal markers. The default is \"\", in which case\n\"English (United States)\" is the numeric format. This\nindicates that points are used as decimal markers.\nStatus code of the response. 0 for success.\nint\nupdate_parts_locations_by_file\n\"\"\n\"English (United States)\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations_by_file.html#ansys.sherlock.core.parts.Parts.update_parts_locations_by_file",
        "title": "update_parts_locations_by_file > update_parts_locations_by_file > update_parts_locations_by_file",
        "section": "update_parts_locations_by_file > update_parts_locations_by_file",
        "text": "Parts.update_parts_locations_by_file(project, cca_name, file_path, numeric_format='')\n\nUpdate one or more part locations using a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nfile_path: str\n\nFull path to the file with the components and location properties.\n\nnumeric_format: str, optional\n\nNumeric format for the file, which indicates whether commas or points\nare used as decimal markers. The default is \"\", in which case\n\"English (United States)\" is the numeric format. This\nindicates that points are used as decimal markers.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_locations_by_file(\n    \"Test\",\n    \"Card\",\n    \"Parts Locations.csv\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_x.html#ansys.sherlock.core.types.layer_types.SlotShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "SlotShape.center_x: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump_json.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "CsvExcelOutlineFile.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height.html#height",
        "title": "height",
        "section": "height",
        "text": "height of the image\nfloat\nheight"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.height.html#ansys.sherlock.core.types.project_types.ImageBounds.height",
        "title": "height > height > height",
        "section": "height > height",
        "text": "ImageBounds.height\n\nheight of the image\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties.html#update_parts_list_properties",
        "title": "update_parts_list_properties",
        "section": "update_parts_list_properties",
        "text": "Update one or more properties of one or more parts in a parts list.\nAvailable Since: 2024R2\nName of the Sherlock project.\nName of the CCA.\nPart properties consisting of these properties:\nReference designator for each part to be updated. If not included,\nupdate properties for all parts in the CCA.\nPart properties consisting of these properties:\nName of property to be updated.\nValue to be applied to the chosen part property.\nStatus code of the response. 0 for success.\nint\nupdate_parts_list_properties\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list_properties.html#ansys.sherlock.core.parts.Parts.update_parts_list_properties",
        "title": "update_parts_list_properties > update_parts_list_properties > update_parts_list_properties",
        "section": "update_parts_list_properties > update_parts_list_properties",
        "text": "Parts.update_parts_list_properties(project, cca_name, part_properties)\n\nUpdate one or more properties of one or more parts in a parts list.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\npart_properties: list[dict[str, list[str] | list[dict[str, str]]]]\n\nPart properties consisting of these properties:\n\nreference_designators: list[str], optional\n\nReference designator for each part to be updated. If not included,\nupdate properties for all parts in the CCA.\n\nproperties: list[dict[str, str]]\n\nPart properties consisting of these properties:\n\nname: str\n\nName of property to be updated.\n\nvalue: str\n\nValue to be applied to the chosen part property.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.parts.update_parts_list_properties(\n        \"Test\",\n        \"Card\",\n        [\n            {\n                \"reference_designators\": [\"C1\"],\n                \"properties\": [\n                    {\"name\": \"partType\", \"value\": \"RESISTOR\"}\n                ]\n            },\n            {\n                \"reference_designators\": [\"C2\"],\n                \"properties\": [\n                    {\"name\": \"locX\", \"value\": \"1\"}\n                ]\n            }\n        ]\n    )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_parts_list_properties.html#get_parts_list_properties",
        "title": "get_parts_list_properties",
        "section": "get_parts_list_properties",
        "text": "Return the properties for one or more parts in the parts list for the CCA.\nAvailable Since: 2025R2\nContains the information needed to retrieve the properties of parts in the parts list.\nProperties for each part that corresponds to the reference designators.\nlist[GetPartsListPropertiesResponse]\nget_parts_list_properties\npython:list\nSherlockPartsService_pb2.GetPartsListPropertiesResponse\nlist\nGetPartsListPropertiesResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_parts_list_properties",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.get_parts_list_properties.html#ansys.sherlock.core.parts.Parts.get_parts_list_properties",
        "title": "get_parts_list_properties > get_parts_list_properties > get_parts_list_properties",
        "section": "get_parts_list_properties > get_parts_list_properties",
        "text": "Parts.get_parts_list_properties(request)\n\nReturn the properties for one or more parts in the parts list for the CCA.\n\nAvailable Since: 2025R2\n\nParameters\n\nrequest: GetPartsListPropertiesRequest\n\nContains the information needed to retrieve the properties of parts in the parts list.\n\nReturns\n\n:\n\n\n\npython:list[SherlockPartsService_pb2.GetPartsListPropertiesResponse]\n\nProperties for each part that corresponds to the reference designators.\n\nReturn type\n\nlist[GetPartsListPropertiesResponse]\n\nExamples\n\n>>> from ansys.sherlock.core.types.parts_types import (GetPartsListPropertiesRequest)\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>    \"ODB++ Tutorial.tgz\",\n>>>    True,\n>>>    True,\n>>>    True,\n>>>    True,\n>>>    project=\"Test\",\n>>>    cca_name=\"Card\",\n>>> )\n>>> part_properties = sherlock.parts.get_parts_list_properties(\n>>>     GetPartsListPropertiesRequest(\n>>>         project=\"Test\",\n>>>         cca_name=\"Card\",\n>>>         reference_designators=[\"C1\",\"U9\"]\n>>>     )\n>>> )\n>>> print(f\"{part_properties}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#update-part-list-validation-analysis",
        "title": "Update Part List Validation Analysis",
        "section": "Update Part List Validation Analysis",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nupdate part list validation analysis properties, and retrieve those properties.\nUpdate Part List Validation Analysis"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#description",
        "title": "Update Part List Validation Analysis > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as validating and updating part list\nanalysis properties for CCAs.\nThis script shows how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Retrieve and print the updated part list validation analysis properties.\nThe retrieved analysis properties can be used for further validation or integration\nwith other software tools.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#connect-to-sherlock",
        "title": "Update Part List Validation Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#delete-project",
        "title": "Update Part List Validation Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#import-tutorial-project",
        "title": "Update Part List Validation Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props",
        "href": "examples/gallery_examples/04-analyses/get_parts_list_analysis_props.html#get-part-list-validation-analysis-properties",
        "title": "Update Part List Validation Analysis > Get Part List Validation Analysis Properties",
        "section": "Get Part List Validation Analysis Properties",
        "text": "Retrieve the updated part list validation analysis properties.\nDownload Jupyter notebook: get_parts_list_analysis_props.ipynb\nDownload Python source code: get_parts_list_analysis_props.py\nDownload zipped: get_parts_list_analysis_props.zip\nGet Part List Validation Analysis Properties\nDownload Jupyter notebook: get_parts_list_analysis_props.ipynb\nDownload Python source code: get_parts_list_analysis_props.py\nDownload zipped: get_parts_list_analysis_props.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod DeletePottingRegionRequest.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionDeleteData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points.html#points",
        "title": "points",
        "section": "points",
        "text": "list[tuple[float, float]]\npoints (length two tuples of the form (x, y))\npoints\nlist\ntuple\nfloat\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.points.html#ansys.sherlock.core.types.layer_types.PolygonalShape.points",
        "title": "points > points > points",
        "section": "points > points",
        "text": "PolygonalShape.points: list[tuple[float, float]]\n\nlist[tuple[float, float]]\n\n!! processed by numpydoc !!\n\nType\n\npoints (length two tuples of the form (x, y))"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.schema.html#ansys.sherlock.core.types.layer_types.SlotShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod SlotShape.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material.html#potting_material",
        "title": "potting_material",
        "section": "potting_material",
        "text": "The potting material.\npotting_material\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_material.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_material",
        "title": "potting_material > potting_material > potting_material",
        "section": "potting_material > potting_material",
        "text": "PottingRegion.potting_material: str\n\nThe potting material.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.html#ansyssherlockcoretypesproject_typescsvexceloutlinefile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelOutlineFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelOutlineFile",
        "text": "Contains the properties for a CSV or Excel outline file.\nCsvExcelOutlineFile.construct([_fields_set])\n\nCsvExcelOutlineFile.copy(*[, include, ...])\nReturns a copy of the model.\nCsvExcelOutlineFile.dict(*[, include, ...])\n\nCsvExcelOutlineFile.from_orm(obj)\n\nCsvExcelOutlineFile.json(*[, include, ...])\n\nCsvExcelOutlineFile.model_construct([...])\nCreates a new instance of the Model class with validated data.\nCsvExcelOutlineFile.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nCsvExcelOutlineFile.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nCsvExcelOutlineFile.model_dump_json(*[, ...])\n!!! abstract \"Usage Documentation\"\nCsvExcelOutlineFile.model_json_schema([...])\nGenerates a JSON schema for a model class.\nCsvExcelOutlineFile.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCsvExcelOutlineFile.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCsvExcelOutlineFile.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nCsvExcelOutlineFile.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nCsvExcelOutlineFile.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nCsvExcelOutlineFile.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCsvExcelOutlineFile.non_negative_int_validation(...)\nValidate integer fields listed contain non-negative values.\nCsvExcelOutlineFile.parse_file(path, *[, ...])\n\nCsvExcelOutlineFile.parse_obj(obj)\n\nCsvExcelOutlineFile.parse_raw(b, *[, ...])\n\nCsvExcelOutlineFile.schema([by_alias, ...])\n\nCsvExcelOutlineFile.schema_json(*[, ...])\n\nCsvExcelOutlineFile.str_validation(value, info)\nValidate string fields listed.\nCsvExcelOutlineFile.update_forward_refs(...)\n\nCsvExcelOutlineFile.validate(value)\n\nCsvExcelOutlineFile.model_computed_fields\n\nCsvExcelOutlineFile.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCsvExcelOutlineFile.model_extra\nGet extra fields set during validation.\nCsvExcelOutlineFile.model_fields\n\nCsvExcelOutlineFile.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nCsvExcelOutlineFile.header_row_count\nNumber of rows before the column header in the file\nCsvExcelOutlineFile.x_location_column\nX location column name\nCsvExcelOutlineFile.y_location_column\nY location column name\nCsvExcelOutlineFile.location_units\nUnits for location values\nansys.sherlock.core.types.project_types.CsvExcelOutlineFile\nCsvExcelOutlineFile.construct\nCsvExcelOutlineFile.copy\nCsvExcelOutlineFile.dict\nCsvExcelOutlineFile.from_orm\nCsvExcelOutlineFile.json\nCsvExcelOutlineFile.model_construct\nCsvExcelOutlineFile.model_copy\nCsvExcelOutlineFile.model_dump\nCsvExcelOutlineFile.model_dump_json\nCsvExcelOutlineFile.model_json_schema\nCsvExcelOutlineFile.model_parametrized_name\nCsvExcelOutlineFile.model_post_init\nCsvExcelOutlineFile.model_rebuild\nCsvExcelOutlineFile.model_validate\nCsvExcelOutlineFile.model_validate_json\nCsvExcelOutlineFile.model_validate_strings\nCsvExcelOutlineFile.non_negative_int_validation\nCsvExcelOutlineFile.parse_file\nCsvExcelOutlineFile.parse_obj\nCsvExcelOutlineFile.parse_raw\nCsvExcelOutlineFile.schema\nCsvExcelOutlineFile.schema_json\nCsvExcelOutlineFile.str_validation\nCsvExcelOutlineFile.update_forward_refs\nCsvExcelOutlineFile.validate\nCsvExcelOutlineFile.model_computed_fields\nCsvExcelOutlineFile.model_config\nCsvExcelOutlineFile.model_extra\nCsvExcelOutlineFile.model_fields\nCsvExcelOutlineFile.model_fields_set\nCsvExcelOutlineFile.header_row_count\nCsvExcelOutlineFile.x_location_column\nCsvExcelOutlineFile.y_location_column\nCsvExcelOutlineFile.location_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile",
        "title": "ansys.sherlock.core.types.project_types.CsvExcelOutlineFile > ansys.sherlock.core.types.project_types.CsvExcelOutlineFile > CsvExcelOutlineFile",
        "section": "ansys.sherlock.core.types.project_types.CsvExcelOutlineFile > CsvExcelOutlineFile",
        "text": "class ansys.sherlock.core.types.project_types.CsvExcelOutlineFile(**data)\n\nContains the properties for a CSV or Excel outline file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCsvExcelOutlineFile.construct([_fields_set])\n\n\n\nCsvExcelOutlineFile.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nCsvExcelOutlineFile.dict(*[, include, ...])\n\n\n\nCsvExcelOutlineFile.from_orm(obj)\n\n\n\nCsvExcelOutlineFile.json(*[, include, ...])\n\n\n\nCsvExcelOutlineFile.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nCsvExcelOutlineFile.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nCsvExcelOutlineFile.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCsvExcelOutlineFile.model_dump_json(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCsvExcelOutlineFile.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nCsvExcelOutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCsvExcelOutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCsvExcelOutlineFile.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCsvExcelOutlineFile.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nCsvExcelOutlineFile.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nCsvExcelOutlineFile.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCsvExcelOutlineFile.non_negative_int_validation(...)\n\nValidate integer fields listed contain non-negative values.\n\nCsvExcelOutlineFile.parse_file(path, *[, ...])\n\n\n\nCsvExcelOutlineFile.parse_obj(obj)\n\n\n\nCsvExcelOutlineFile.parse_raw(b, *[, ...])\n\n\n\nCsvExcelOutlineFile.schema([by_alias, ...])\n\n\n\nCsvExcelOutlineFile.schema_json(*[, ...])\n\n\n\nCsvExcelOutlineFile.str_validation(value, info)\n\nValidate string fields listed.\n\nCsvExcelOutlineFile.update_forward_refs(...)\n\n\n\nCsvExcelOutlineFile.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCsvExcelOutlineFile.model_computed_fields\n\n\n\nCsvExcelOutlineFile.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCsvExcelOutlineFile.model_extra\n\nGet extra fields set during validation.\n\nCsvExcelOutlineFile.model_fields\n\n\n\nCsvExcelOutlineFile.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nCsvExcelOutlineFile.header_row_count\n\nNumber of rows before the column header in the file\n\nCsvExcelOutlineFile.x_location_column\n\nX location column name\n\nCsvExcelOutlineFile.y_location_column\n\nY location column name\n\nCsvExcelOutlineFile.location_units\n\nUnits for location values\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format.html#numeric_format",
        "title": "numeric_format",
        "section": "numeric_format",
        "text": "numeric_format\nstr\nnumeric_format"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format.html#ansys.sherlock.core.types.project_types.CsvExcelFile.numeric_format",
        "title": "numeric_format > numeric_format > numeric_format",
        "section": "numeric_format > numeric_format",
        "text": "CsvExcelFile.numeric_format\n\nnumeric_format\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region.html#delete_potting_region",
        "title": "delete_potting_region",
        "section": "delete_potting_region",
        "text": "Delete on or more potting regions in a specific project.\nAvailable Since: 2025R1\nContains all the information needed to delete one or more potting regions per project.\nReturn codes for each request.\nlist[ReturnCode]\ndelete_potting_region\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_potting_region.html#ansys.sherlock.core.layer.Layer.delete_potting_region",
        "title": "delete_potting_region > delete_potting_region > delete_potting_region",
        "section": "delete_potting_region > delete_potting_region",
        "text": "Layer.delete_potting_region(request)\n\nDelete on or more potting regions in a specific project.\n\nAvailable Since: 2025R1\n\nParameters\n\nrequest: DeletePottingRegionRequest\n\nContains all the information needed to delete one or more potting regions per project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.layer_types import DeletePottingRegionRequest\n>>> from ansys.sherlock.core.types.layer_types import PottingRegionDeleteData\n>>> sherlock = launch_sherlock()\n>>>\n>>> delete_request_example = DeletePottingRegionRequest(\n>>> project=project,\n>>> potting_region_delete_data=[\n>>>     PottingRegionDeleteData(\n>>>         cca_name=cca_name,\n>>>         potting_id=potting_id\n>>>     )\n>>> ]\n>>> )\n>>> responses_example = sherlock.layer.delete_potting_region(delete_request_example)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id.html#copy_potting_id",
        "title": "copy_potting_id",
        "section": "copy_potting_id",
        "text": "Id of the potting region to copy.\ncopy_potting_id\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy_potting_id",
        "title": "copy_potting_id > copy_potting_id > copy_potting_id",
        "section": "copy_potting_id > copy_potting_id",
        "text": "PottingRegionCopyData.copy_potting_id: str\n\nId of the potting region to copy.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.copy.html#ansys.sherlock.core.types.project_types.OutlineFile.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "OutlineFile.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#update-part-modeling-properties",
        "title": "Update Part Modeling Properties",
        "section": "Update Part Modeling Properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update part modeling properties.\nUpdate Part Modeling Properties"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#description",
        "title": "Update Part Modeling Properties > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating part\nmodeling properties for printed circuit boards (PCBs).\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Update part modeling properties.\nThe updated properties ensure accurate simulation results for mechanical and thermal analyses.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#connect-to-sherlock",
        "title": "Update Part Modeling Properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#delete-project",
        "title": "Update Part Modeling Properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#import-tutorial-project",
        "title": "Update Part Modeling Properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties",
        "href": "examples/gallery_examples/01-project-configuration/update_part_modeling_properties.html#update-part-modeling-properties",
        "title": "Update Part Modeling Properties",
        "section": "Update Part Modeling Properties",
        "text": "Update the part modeling properties for the “Card” of the “Test” project.\nDownload Jupyter notebook: update_part_modeling_properties.ipynb\nDownload Python source code: update_part_modeling_properties.py\nDownload zipped: update_part_modeling_properties.zip\nUpdate Part Modeling Properties\nDownload Jupyter notebook: update_part_modeling_properties.ipynb\nDownload Python source code: update_part_modeling_properties.py\nDownload zipped: update_part_modeling_properties.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CopyPottingRegionRequest.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y.html#legend_y",
        "title": "legend_y",
        "section": "legend_y",
        "text": "y coordinate of the upper left corner\nfloat\nlegend_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.legend_y.html#ansys.sherlock.core.types.project_types.LegendBounds.legend_y",
        "title": "legend_y > legend_y > legend_y",
        "section": "legend_y > legend_y",
        "text": "LegendBounds.legend_y\n\ny coordinate of the upper left corner\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "GerberOutlineFile.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PottingRegionUpdateData.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "examples/gallery_examples/00-setup/index",
        "href": "examples/gallery_examples/00-setup/index.html#setup",
        "title": "Setup",
        "section": "Setup",
        "text": "Scripts to run before the examples to prepare the tests.\nsphx_glr_examples_gallery_examples_00-setup_setup.py\nSetup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.parse_file.html#ansys.sherlock.core.types.project_types.OutlineFile.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod OutlineFile.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.html#ansyssherlockcoretypeslayer_typescircularshape",
        "title": "ansys.sherlock.core.types.layer_types.CircularShape",
        "section": "ansys.sherlock.core.types.layer_types.CircularShape",
        "text": "Contains the properties for a circular shape.\nCircularShape.construct([_fields_set])\n\nCircularShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nCircularShape.dict(*[, include, exclude, ...])\n\nCircularShape.from_orm(obj)\n\nCircularShape.json(*[, include, exclude, ...])\n\nCircularShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nCircularShape.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nCircularShape.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nCircularShape.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nCircularShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nCircularShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCircularShape.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCircularShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nCircularShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nCircularShape.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nCircularShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCircularShape.parse_file(path, *[, ...])\n\nCircularShape.parse_obj(obj)\n\nCircularShape.parse_raw(b, *[, ...])\n\nCircularShape.schema([by_alias, ref_template])\n\nCircularShape.schema_json(*[, by_alias, ...])\n\nCircularShape.update_forward_refs(**localns)\n\nCircularShape.validate(value)\n\nCircularShape.model_computed_fields\n\nCircularShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCircularShape.model_extra\nGet extra fields set during validation.\nCircularShape.model_fields\n\nCircularShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nCircularShape.diameter\nfloat\nCircularShape.node_count\nint\nCircularShape.center_x\nfloat\nCircularShape.center_y\nfloat\nCircularShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.CircularShape\nCircularShape.construct\nCircularShape.copy\nCircularShape.dict\nCircularShape.from_orm\nCircularShape.json\nCircularShape.model_construct\nCircularShape.model_copy\nCircularShape.model_dump\nCircularShape.model_dump_json\nCircularShape.model_json_schema\nCircularShape.model_parametrized_name\nCircularShape.model_post_init\nCircularShape.model_rebuild\nCircularShape.model_validate\nCircularShape.model_validate_json\nCircularShape.model_validate_strings\nCircularShape.parse_file\nCircularShape.parse_obj\nCircularShape.parse_raw\nCircularShape.schema\nCircularShape.schema_json\nCircularShape.update_forward_refs\nCircularShape.validate\nCircularShape.model_computed_fields\nCircularShape.model_config\nCircularShape.model_extra\nCircularShape.model_fields\nCircularShape.model_fields_set\nCircularShape.diameter\nCircularShape.node_count\nCircularShape.center_x\nCircularShape.center_y\nCircularShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.html#ansys.sherlock.core.types.layer_types.CircularShape",
        "title": "ansys.sherlock.core.types.layer_types.CircularShape > ansys.sherlock.core.types.layer_types.CircularShape > CircularShape",
        "section": "ansys.sherlock.core.types.layer_types.CircularShape > CircularShape",
        "text": "class ansys.sherlock.core.types.layer_types.CircularShape(**data)\n\nContains the properties for a circular shape.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCircularShape.construct([_fields_set])\n\n\n\nCircularShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nCircularShape.dict(*[, include, exclude, ...])\n\n\n\nCircularShape.from_orm(obj)\n\n\n\nCircularShape.json(*[, include, exclude, ...])\n\n\n\nCircularShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nCircularShape.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nCircularShape.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCircularShape.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCircularShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nCircularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCircularShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCircularShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCircularShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nCircularShape.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nCircularShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCircularShape.parse_file(path, *[, ...])\n\n\n\nCircularShape.parse_obj(obj)\n\n\n\nCircularShape.parse_raw(b, *[, ...])\n\n\n\nCircularShape.schema([by_alias, ref_template])\n\n\n\nCircularShape.schema_json(*[, by_alias, ...])\n\n\n\nCircularShape.update_forward_refs(**localns)\n\n\n\nCircularShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCircularShape.model_computed_fields\n\n\n\nCircularShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCircularShape.model_extra\n\nGet extra fields set during validation.\n\nCircularShape.model_fields\n\n\n\nCircularShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nCircularShape.diameter\n\nfloat\n\nCircularShape.node_count\n\nint\n\nCircularShape.center_x\n\nfloat\n\nCircularShape.center_y\n\nfloat\n\nCircularShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel.html#exporttracemodel",
        "title": "exportTraceModel",
        "section": "exportTraceModel",
        "text": "Export a trace model to a specified output file.\nAvailable Since: 2024R2\nlist of parameters for export a trace model of a single copper layer.\nStatus code of the response. 0 for success.\nint\nexportTraceModel\npython:list\npython:int\npython:float\npython:str\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.exportTraceModel.html#ansys.sherlock.core.model.Model.exportTraceModel",
        "title": "exportTraceModel > exportTraceModel > exportTraceModel",
        "section": "exportTraceModel > exportTraceModel",
        "text": "Model.exportTraceModel(layer_params)\n\nExport a trace model to a specified output file.\n\nAvailable Since: 2024R2\n\nParameters\n\nlayer_params\n\npython:list[bool | python:int | python:float | python:str]\n\nlist of parameters for export a trace model of a single copper layer.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.types.analysis_types import ElementOrder\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.api.sherlock.v0 import SherlockModelService_pb2\n>>> sherlock, ansys_install_path = launcher.launch_and_connect()\n>>> list_of_params_for_layers = []\n>>> list_of_params_for_layers.append(\n>>>     sherlock.model.createExportTraceCopperLayerParams(\n>>>         project_name=\"Tutorial Project\",\n>>>         cca_name=\"Main Board\",\n>>>         output_file_path=\".\\\\outputfile_path.stp\",\n>>>         copper_layer=\"copper-01.odb\",\n>>>         overwrite=True,\n>>>         display_after=False,\n>>>         clear_FEA_database=False,\n>>>         use_FEA_model_ID=False,\n>>>         coord_units=\"mm\",\n>>>         mesh_type=SherlockModelService_pb2.MeshType.NONE,\n>>>         is_modeling_region_enabled=False,\n>>>         trace_output_type=SherlockModelService_pb2.TraceOutputType.ALL_REGIONS,\n>>>         element_order=ElementOrder.LINEAR,\n>>>         max_mesh_size=1.0,\n>>>         max_mesh_size_units=\"mm\",\n>>>         max_holes_per_trace=2,\n>>>         is_drill_hole_modeling_enabled=False,\n>>>         drill_hole_min_diameter=1.0,\n>>>         drill_hole_min_diameter_units=\"mm\",\n>>>         drill_hole_max_edge_length=1.0,\n>>>         drill_hole_max_edge_length_units=\"mm\",\n>>>     )\n>>> )\n>>> sherlock.model.exportTraceModel(list_of_params_for_layers)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode",
        "href": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode.html#sherlock-project-import-in-single-mode",
        "title": "Sherlock Project Import in Single Mode",
        "section": "Sherlock Project Import in Single Mode",
        "text": "This example demonstrates how to launch the Sherlock gRPC service in single-project mode,\nimport a project, and handle common exceptions during the import process.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including project management.\nThis script demonstrates how to:\n- Connect to the Sherlock service in single-project mode.\n- Import a sample project archive.\n- Handle import errors gracefully.\nSherlock Project Import in Single Mode"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode",
        "href": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode.html#launch-pysherlock-service-in-single-project-mode",
        "title": "Sherlock Project Import in Single Mode > Launch PySherlock service in single-project mode",
        "section": "Launch PySherlock service in single-project mode",
        "text": "Launch the Sherlock service using the specified project path and wait for initialization.\nLaunch PySherlock service in single-project mode"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode",
        "href": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode.html#import-sherlock-project-in-single-mode",
        "title": "Sherlock Project Import in Single Mode > Import Sherlock Project in Single Mode",
        "section": "Import Sherlock Project in Single Mode",
        "text": "Import a tutorial project ZIP archive provided with the Sherlock installation.\nImport Sherlock Project in Single Mode"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode",
        "href": "examples/gallery_examples/02-importing/import_project_zip_archive_single_mode.html#exit-sherlock",
        "title": "Sherlock Project Import in Single Mode > Exit Sherlock",
        "section": "Exit Sherlock",
        "text": "Exit the gRPC connection and shut down Sherlock.\nDownload Jupyter notebook: import_project_zip_archive_single_mode.ipynb\nDownload Python source code: import_project_zip_archive_single_mode.py\nDownload zipped: import_project_zip_archive_single_mode.zip\nExit Sherlock\nDownload Jupyter notebook: import_project_zip_archive_single_mode.ipynb\nDownload Python source code: import_project_zip_archive_single_mode.py\nDownload zipped: import_project_zip_archive_single_mode.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionCopyData.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y.html#image_y",
        "title": "image_y",
        "section": "image_y",
        "text": "y coordinate of the upper left corner\nfloat\nimage_y"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_y.html#ansys.sherlock.core.types.project_types.ImageBounds.image_y",
        "title": "image_y > image_y > image_y",
        "section": "image_y > image_y",
        "text": "ImageBounds.image_y\n\ny coordinate of the upper left corner\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_dump.html#ansys.sherlock.core.types.layer_types.CircularShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CircularShape.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.SlotShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property SlotShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_post_init.html#ansys.sherlock.core.types.layer_types.SlotShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "SlotShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_construct.html#ansys.sherlock.core.types.project_types.OutlineFile.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod OutlineFile.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.schema.html#ansys.sherlock.core.types.layer_types.CircularShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod CircularShape.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "UpdatePottingRegionRequest.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/sg_execution_times",
        "href": "examples/gallery_examples/03-exporting/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 9 files from examplesgallery_examples03-exporting:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_03-exporting_export_aedb.py (export_aedb.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_mount_points.py (export_all_mount_points.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_fixtures.py (export_all_test_fixtures.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_points.py (export_all_test_points.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_fea_model.py (export_fea_model.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_net_list.py (export_net_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_part_list.py (export_part_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_project.py (export_project.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_03-exporting_export_trace_model.py (export_trace_model.py)\n00:00.000\n0.0\nComputation times\nexport_aedb.py\nexport_all_mount_points.py\nexport_all_test_fixtures.py\nexport_all_test_points.py\nexport_fea_model.py\nexport_net_list.py\nexport_part_list.py\nexport_project.py\nexport_trace_model.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_component_failure_mechanism_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_component_failure_mechanism_analysis_props.html#update_component_failure_mechanism_analysis_props",
        "title": "update_component_failure_mechanism_analysis_props",
        "section": "update_component_failure_mechanism_analysis_props",
        "text": "Update properties for one or more Component Failure Mechanism analysis.\nContains all the information needed to update the properties for one or more component\nfailure mechanism analyses per project.\nReturn codes for each request.\nlist[ReturnCode]\nupdate_component_failure_mechanism_analysis_props\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_component_failure_mechanism_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_component_failure_mechanism_analysis_props.html#ansys.sherlock.core.analysis.Analysis.update_component_failure_mechanism_analysis_props",
        "title": "update_component_failure_mechanism_analysis_props > update_component_failure_mechanism_analysis_props > update_component_failure_mechanism_analysis_props",
        "section": "update_component_failure_mechanism_analysis_props > update_component_failure_mechanism_analysis_props",
        "text": "Analysis.update_component_failure_mechanism_analysis_props(request)\n\nUpdate properties for one or more Component Failure Mechanism analysis.\n\nParameters\n\nrequest: UpdateComponentFailureMechanismPropsRequest\n\nContains all the information needed to update the properties for one or more component\nfailure mechanism analyses per project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.analysis_types import (\n    ComponentFailureMechanism,\n    UpdateComponentFailureMechanismPropsRequest,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\n    project=\"Assembly Tutorial\",\n    category=\"category\",\n    archive_file=\\\n        \"C:\\\\Program Files\\\\ANSYS Inc\\\\v252\\\\sherlock\\\\tutorial\\\\Assembly Tutorial.zip\",\n)\n>>> update_request1 = ComponentFailureMechanism(\n    cca_name=\"Main Board\",\n    default_part_temp_rise=1.5,\n    default_part_temp_rise_units=\"K\",\n    part_temp_rise_min_enabled=True,\n    part_validation_enabled=False,\n)\n>>> update_request2 = ComponentFailureMechanism(\n    cca_name=\"Memory Card 1\",\n    default_part_temp_rise=-3.25,\n    default_part_temp_rise_units=\"F\",\n    part_temp_rise_min_enabled=False,\n    part_validation_enabled=True,\n)\n>>> request = UpdateComponentFailureMechanismPropsRequest(\n    project=\"Test\",\n    component_failure_mechanism_properties_per_cca=[\n        update_request1,\n        update_request2\n    ]\n)\n>>> return_codes = sherlock.analysis.\\\n        update_component_failure_mechanism_analysis_props(request)\n>>> for return_code in return_codes:\n        print(f\"Return code: value={return_code.value}, message={return_code.message}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionUpdateData.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PolygonalShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PolygonalShape.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props.html#update_random_vibe_props",
        "title": "update_random_vibe_props",
        "section": "update_random_vibe_props",
        "text": "Update properties for a random vibe analysis.\nAvailable Since: 2024R1\nName of the Sherlock project.\nName of the CCA.\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nTemperature. The default is None.\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nWhether to enable part validation. The default is None.\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\nWhether to perform a frequency range check. The default is None.\nThis parameter is for NX Nastran analysis only.\nWhether to require material assignment. The default is None.\nModel source. The default is None.\nThis parameter is required for strain map analysis.\nComma-separated list of natural frequencies. The default is None.\nThis parameter is required for strain map analysis.\nStatus code of the response. 0 for success.\nint\nupdate_random_vibe_props\nNone\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\nNone\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_random_vibe_props.html#ansys.sherlock.core.analysis.Analysis.update_random_vibe_props",
        "title": "update_random_vibe_props > update_random_vibe_props > update_random_vibe_props",
        "section": "update_random_vibe_props > update_random_vibe_props",
        "text": "Analysis.update_random_vibe_props(project, cca_name, random_vibe_damping=None, natural_freq_min=None, natural_freq_min_units=None, natural_freq_max=None, natural_freq_max_units=None, analysis_temp=None, analysis_temp_units=None, part_validation_enabled=None, force_model_rebuild=None, reuse_modal_analysis=None, perform_nf_freq_range_check=None, require_material_assignment_enabled=None, model_source=None, strain_map_natural_freqs=None)\n\nUpdate properties for a random vibe analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nrandom_vibe_damping: str, optional\n\nOne or more modal damping ratios. The default is None.\nSeparate multiple float values with commas.\n\nnatural_freq_min: float, optional\n\nMinimum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units: str, optional\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max: float, optional\n\nMaximum frequency. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units: str, optional\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nanalysis_temp: float, optional\n\nTemperature. The default is None.\n\nanalysis_temp_units: str, optional\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\npart_validation_enabled: bool, optional\n\nWhether to enable part validation. The default is None.\n\nforce_model_rebuild: str, optional\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nreuse_modal_analysis: bool, optional\n\nWhether to reuse the natural frequency for modal analysis. The\ndefault is None. This parameter is for NX Nastran analysis only.\n\nperform_nf_freq_range_check: bool, optional\n\nWhether to perform a frequency range check. The default is None.\nThis parameter is for NX Nastran analysis only.\n\nrequire_material_assignment_enabled: bool, optional\n\nWhether to require material assignment. The default is None.\n\nmodel_source: ModelSource, optional\n\nModel source. The default is None.\nThis parameter is required for strain map analysis.\n\nstrain_map_natural_freqs: str, optional\n\nComma-separated list of natural frequencies. The default is None.\nThis parameter is required for strain map analysis.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_random_vibe_props(\n    \"Test\",\n    \"Card\",\n    random_vibe_damping=\"0.01, 0.05\",\n    analysis_temp=20,\n    analysis_temp_units=\"C\",\n    model_source=ModelSource.STRAIN_MAP\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CircularShape.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.html#ansyssherlockcoretypesproject_typesimagebounds",
        "title": "ansys.sherlock.core.types.project_types.ImageBounds",
        "section": "ansys.sherlock.core.types.project_types.ImageBounds",
        "text": "Contains the properties of the image bounds.\nImageBounds.image_x\nx coordinate of the upper left corner\nImageBounds.image_y\ny coordinate of the upper left corner\nImageBounds.height\nheight of the image\nImageBounds.width\nwidth of the image\nansys.sherlock.core.types.project_types.ImageBounds\nImageBounds.image_x\nImageBounds.image_y\nImageBounds.height\nImageBounds.width"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.html#ansys.sherlock.core.types.project_types.ImageBounds",
        "title": "ansys.sherlock.core.types.project_types.ImageBounds > ansys.sherlock.core.types.project_types.ImageBounds > ImageBounds",
        "section": "ansys.sherlock.core.types.project_types.ImageBounds > ImageBounds",
        "text": "class ansys.sherlock.core.types.project_types.ImageBounds(image_x, image_y, height, width)\n\nContains the properties of the image bounds.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nImageBounds.image_x\n\nx coordinate of the upper left corner\n\nImageBounds.image_y\n\ny coordinate of the upper left corner\n\nImageBounds.height\n\nheight of the image\n\nImageBounds.width\n\nwidth of the image\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.dict.html#ansys.sherlock.core.types.project_types.OutlineFile.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "OutlineFile.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionDeleteData.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PottingRegionCopyData.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionCopyData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_config.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "RectangularShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.html#ansyssherlockcoretypesproject_typesoutlinefile",
        "title": "ansys.sherlock.core.types.project_types.OutlineFile",
        "section": "ansys.sherlock.core.types.project_types.OutlineFile",
        "text": "Contains the properties for an outline file.\nOutlineFile.construct([_fields_set])\n\nOutlineFile.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nOutlineFile.dict(*[, include, exclude, ...])\n\nOutlineFile.from_orm(obj)\n\nOutlineFile.json(*[, include, exclude, ...])\n\nOutlineFile.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nOutlineFile.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nOutlineFile.model_dump(*[, mode, include, ...])\n!!! abstract \"Usage Documentation\"\nOutlineFile.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nOutlineFile.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nOutlineFile.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nOutlineFile.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nOutlineFile.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nOutlineFile.model_validate(obj, *[, strict, ...])\nValidate a pydantic model instance.\nOutlineFile.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nOutlineFile.model_validate_strings(obj, *[, ...])\nValidate the given object with string data against the Pydantic model.\nOutlineFile.optional_str_validation(value, info)\nAllow empty strings for file_comment.\nOutlineFile.parse_file(path, *[, ...])\n\nOutlineFile.parse_obj(obj)\n\nOutlineFile.parse_raw(b, *[, content_type, ...])\n\nOutlineFile.schema([by_alias, ref_template])\n\nOutlineFile.schema_json(*[, by_alias, ...])\n\nOutlineFile.str_validation(value, info)\nValidate string fields listed.\nOutlineFile.update_forward_refs(**localns)\n\nOutlineFile.validate(value)\n\nOutlineFile.validate_non_empty_cca_names(...)\nValidate cca_names contains at least one name and none are empty.\nOutlineFile.model_computed_fields\n\nOutlineFile.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nOutlineFile.model_extra\nGet extra fields set during validation.\nOutlineFile.model_fields\n\nOutlineFile.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nOutlineFile.file_name\nThe filename of the outline file.\nOutlineFile.file_comment\nThe comment for the outline file.\nOutlineFile.file_type\nThe type of outline file.\nOutlineFile.outline_file_data\nSpecific outline file type properties\nOutlineFile.cca_names\nThe list of CCA names for the outline file.\nansys.sherlock.core.types.project_types.OutlineFile\nOutlineFile.construct\nOutlineFile.copy\nOutlineFile.dict\nOutlineFile.from_orm\nOutlineFile.json\nOutlineFile.model_construct\nOutlineFile.model_copy\nOutlineFile.model_dump\nOutlineFile.model_dump_json\nOutlineFile.model_json_schema\nOutlineFile.model_parametrized_name\nOutlineFile.model_post_init\nOutlineFile.model_rebuild\nOutlineFile.model_validate\nOutlineFile.model_validate_json\nOutlineFile.model_validate_strings\nOutlineFile.optional_str_validation\nOutlineFile.parse_file\nOutlineFile.parse_obj\nOutlineFile.parse_raw\nOutlineFile.schema\nOutlineFile.schema_json\nOutlineFile.str_validation\nOutlineFile.update_forward_refs\nOutlineFile.validate\nOutlineFile.validate_non_empty_cca_names\nOutlineFile.model_computed_fields\nOutlineFile.model_config\nOutlineFile.model_extra\nOutlineFile.model_fields\nOutlineFile.model_fields_set\nOutlineFile.file_name\nOutlineFile.file_comment\nOutlineFile.file_type\nOutlineFile.outline_file_data\nOutlineFile.cca_names"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.html#ansys.sherlock.core.types.project_types.OutlineFile",
        "title": "ansys.sherlock.core.types.project_types.OutlineFile > ansys.sherlock.core.types.project_types.OutlineFile > OutlineFile",
        "section": "ansys.sherlock.core.types.project_types.OutlineFile > OutlineFile",
        "text": "class ansys.sherlock.core.types.project_types.OutlineFile(**data)\n\nContains the properties for an outline file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nOutlineFile.construct([_fields_set])\n\n\n\nOutlineFile.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nOutlineFile.dict(*[, include, exclude, ...])\n\n\n\nOutlineFile.from_orm(obj)\n\n\n\nOutlineFile.json(*[, include, exclude, ...])\n\n\n\nOutlineFile.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nOutlineFile.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nOutlineFile.model_dump(*[, mode, include, ...])\n\n!!! abstract \"Usage Documentation\"\n\nOutlineFile.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nOutlineFile.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nOutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nOutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nOutlineFile.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nOutlineFile.model_validate(obj, *[, strict, ...])\n\nValidate a pydantic model instance.\n\nOutlineFile.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nOutlineFile.model_validate_strings(obj, *[, ...])\n\nValidate the given object with string data against the Pydantic model.\n\nOutlineFile.optional_str_validation(value, info)\n\nAllow empty strings for file_comment.\n\nOutlineFile.parse_file(path, *[, ...])\n\n\n\nOutlineFile.parse_obj(obj)\n\n\n\nOutlineFile.parse_raw(b, *[, content_type, ...])\n\n\n\nOutlineFile.schema([by_alias, ref_template])\n\n\n\nOutlineFile.schema_json(*[, by_alias, ...])\n\n\n\nOutlineFile.str_validation(value, info)\n\nValidate string fields listed.\n\nOutlineFile.update_forward_refs(**localns)\n\n\n\nOutlineFile.validate(value)\n\n\n\nOutlineFile.validate_non_empty_cca_names(...)\n\nValidate cca_names contains at least one name and none are empty.\n\n\n\nAttributes\n\n\n\n\n\n\n\nOutlineFile.model_computed_fields\n\n\n\nOutlineFile.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nOutlineFile.model_extra\n\nGet extra fields set during validation.\n\nOutlineFile.model_fields\n\n\n\nOutlineFile.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nOutlineFile.file_name\n\nThe filename of the outline file.\n\nOutlineFile.file_comment\n\nThe comment for the outline file.\n\nOutlineFile.file_type\n\nThe type of outline file.\n\nOutlineFile.outline_file_data\n\nSpecific outline file type properties\n\nOutlineFile.cca_names\n\nThe list of CCA names for the outline file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.validate.html#ansys.sherlock.core.types.project_types.OutlineFile.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod OutlineFile.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "X coordinate for the center of the new potting region.\ncenter_x\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "PottingRegionCopyData.center_x: float\n\nX coordinate for the center of the new potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.CircularShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CircularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.schema_json.html#ansys.sherlock.core.types.layer_types.PCBShape.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PCBShape.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_fields.html#ansys.sherlock.core.types.layer_types.PCBShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "PCBShape.model_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod CopyPottingRegionRequest.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis",
        "href": "api/analysis.html#analysis",
        "title": "Analysis",
        "section": "Analysis",
        "text": "Module containing all analysis capabilities.\nAnalysis(channel, server_version)\nContains all analysis capabilities.\nAnalysis\nAnalysis"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props.html#update_mechanical_shock_props",
        "title": "update_mechanical_shock_props",
        "section": "update_mechanical_shock_props",
        "text": "Update properties for a mechanical shock analysis.\nAvailable Since: 2024R1\nName of the Sherlock project.\nMechanical shock properties for a CCA consisting of these properties:\nName of the CCA.\nModel source. The default is None.\nNumber of mechanical shock result layers to generate.\nCritical shock strain. The default is None.\nCritical shock strain units. The default is None.\nOptions are \"strain\", \"ε\", and \"µε\".\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\nMinimum frequency. The default is None.\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nMaximum frequency. The default is None.\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nTemperature. The default is None.\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nStatus code of the response. 0 for success.\nint\nupdate_mechanical_shock_props\nNone\nNone\nNone\n\"strain\"\n\"ε\"\n\"µε\"\nNone\nNone\nNone\n\"FORCE\"\n\"AUTO\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props.html#ansys.sherlock.core.analysis.Analysis.update_mechanical_shock_props",
        "title": "update_mechanical_shock_props > update_mechanical_shock_props > update_mechanical_shock_props",
        "section": "update_mechanical_shock_props > update_mechanical_shock_props",
        "text": "Analysis.update_mechanical_shock_props(project, mechanical_shock_properties)\n\nUpdate properties for a mechanical shock analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nmechanical_shock_properties: list[dict[str, bool | float | int | str]]\n\nMechanical shock properties for a CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nmodel_source: ModelSource, optional\n\nModel source. The default is None.\n\nshock_result_count\n\nint\n\nNumber of mechanical shock result layers to generate.\n\ncritical_shock_strain: float\n\nCritical shock strain. The default is None.\n\ncritical_shock_strain_units: str\n\nCritical shock strain units. The default is None.\nOptions are \"strain\", \"ε\", and \"µε\".\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nforce_model_rebuild: str\n\nHow to handle rebuilding of the model. The default is None.\nOptions are \"FORCE\" and \"AUTO\".\n\nnatural_freq_min: int\n\nMinimum frequency. The default is None.\n\nnatural_freq_min_units: str\n\nMinimum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nnatural_freq_max: int\n\nMaximum frequency. The default is None.\n\nnatural_freq_max_units: str\n\nMaximum frequency units. The default is None.\nOptions are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nanalysis_temp: float\n\nTemperature. The default is None.\n\nanalysis_temp_units: str\n\nTemperature units. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_mechanical_shock_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"model_source\": ModelSource.GENERATED,\n        \"shock_result_count\": 2,\n        \"critical_shock_strain\": 10,\n        \"critical_shock_strain_units\": \"strain\",\n        \"part_validation_enabled\": True,\n        \"require_material_assignment_enabled\": False,\n        \"force_model_rebuild\": \"AUTO\",\n        \"natural_freq_min\": 10,\n        \"natural_freq_min_units\": \"Hz\",\n        \"natural_freq_max\": 100,\n        \"natural_freq_max_units\": \"KHz\",\n        \"analysis_temp\": 20,\n        \"analysis_temp_units\": \"F\",\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count.html#header_row_count",
        "title": "header_row_count",
        "section": "header_row_count",
        "text": "header_row_count\nint\nheader_row_count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count.html#ansys.sherlock.core.types.project_types.CsvExcelFile.header_row_count",
        "title": "header_row_count > header_row_count > header_row_count",
        "section": "header_row_count > header_row_count",
        "text": "CsvExcelFile.header_row_count\n\nheader_row_count\n\n!! processed by numpydoc !!\n\nType\n\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.center_y.html#ansys.sherlock.core.types.layer_types.SlotShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "SlotShape.center_y: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "UpdatePottingRegionRequest.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod GerberOutlineFile.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.validate.html#ansys.sherlock.core.types.layer_types.PolygonalShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PolygonalShape.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod DeletePottingRegionRequest.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegionCopyData.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields.html#ansys.sherlock.core.types.project_types.OutlineFile.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "OutlineFile.model_fields = {'cca_names': FieldInfo(annotation=list[str], required=True), 'file_comment': FieldInfo(annotation=Union[str, NoneType], required=False, default=None), 'file_name': FieldInfo(annotation=str, required=True), 'file_type': FieldInfo(annotation=OutlineFileType, required=True), 'outline_file_data': FieldInfo(annotation=Union[CsvExcelOutlineFile, GerberOutlineFile, NoneType], required=False, default=None)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "UpdatePottingRegionRequest.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.html#ansyssherlockcoretypesproject_typesimagefile",
        "title": "ansys.sherlock.core.types.project_types.ImageFile",
        "section": "ansys.sherlock.core.types.project_types.ImageFile",
        "text": "Contains the properties for a thermal map image file.\nImageFile.board_bounds\nboard_bounds\nImageFile.coordinate_units\ncoordinate_units\nImageFile.image_bounds\nimage_bounds\nImageFile.legend_bounds\nlegend_bounds\nImageFile.legend_orientation\nlegend_orientation\nImageFile.max_temperature\nmax_temperature\nImageFile.max_temperature_units\nmax_temperature_units\nImageFile.min_temperature\nmin_temperature\nImageFile.min_temperature_units\nmin_temperature_units\nansys.sherlock.core.types.project_types.ImageFile\nImageFile.board_bounds\nImageFile.coordinate_units\nImageFile.image_bounds\nImageFile.legend_bounds\nImageFile.legend_orientation\nImageFile.max_temperature\nImageFile.max_temperature_units\nImageFile.min_temperature\nImageFile.min_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.html#ansys.sherlock.core.types.project_types.ImageFile",
        "title": "ansys.sherlock.core.types.project_types.ImageFile > ansys.sherlock.core.types.project_types.ImageFile > ImageFile",
        "section": "ansys.sherlock.core.types.project_types.ImageFile > ImageFile",
        "text": "class ansys.sherlock.core.types.project_types.ImageFile(board_bounds, coordinate_units, image_bounds, legend_bounds, legend_orientation, max_temperature, max_temperature_units, min_temperature, min_temperature_units)\n\nContains the properties for a thermal map image file.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nImageFile.board_bounds\n\nboard_bounds\n\nImageFile.coordinate_units\n\ncoordinate_units\n\nImageFile.image_bounds\n\nimage_bounds\n\nImageFile.legend_bounds\n\nlegend_bounds\n\nImageFile.legend_orientation\n\nlegend_orientation\n\nImageFile.max_temperature\n\nmax_temperature\n\nImageFile.max_temperature_units\n\nmax_temperature_units\n\nImageFile.min_temperature\n\nmin_temperature\n\nImageFile.min_temperature_units\n\nmin_temperature_units\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps.html#add_strain_maps",
        "title": "add_strain_maps",
        "section": "add_strain_maps",
        "text": "Add strain map files to CCAs in a Sherlock project.\nAvailable Since: 2023R2\nName of the Sherlock project to add strain maps to.\nStrain maps consisting of these properties:\nFull path to the CSV file with the strain maps.\nComment to associate with the file.\nStrain maps file type. Options are CSV, Excel, and Image.\nNumber of rows before the file’s column header.\nName of the column in the file with reference IDs.\nName of the column in the file with strain values.\nStrain units. Options are µε and ε.\nThe properties of the strain map file to add.\nList of CCA names to assign the file to. When no list is\nspecified, the file is assigned to all CCAs in the project.\nStatus code of the response. 0 for success.\nint\nadd_strain_maps\nµε\nε\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_strain_maps.html#ansys.sherlock.core.project.Project.add_strain_maps",
        "title": "add_strain_maps > add_strain_maps > add_strain_maps",
        "section": "add_strain_maps > add_strain_maps",
        "text": "Project.add_strain_maps(project, strain_maps)\n\nAdd strain map files to CCAs in a Sherlock project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project to add strain maps to.\n\nstrain_maps: list\n\nStrain maps consisting of these properties:\n\nstrain_map_file: str\n\nFull path to the CSV file with the strain maps.\n\nfile_comment: str\n\nComment to associate with the file.\n\nfile_type: StrainMapsFileType\n\nStrain maps file type. Options are CSV, Excel, and Image.\n\nheader_row_count: int\n\nNumber of rows before the file’s column header.\n\nreference_id_column: str\n\nName of the column in the file with reference IDs.\n\nstrain_column: str\n\nName of the column in the file with strain values.\n\nstrain_units: str\n\nStrain units. Options are µε and ε.\n\nimage_file: StrainMapImageFile, optional\n\nThe properties of the strain map file to add.\n\nccas: list, optional\n\nList of CCA names to assign the file to. When no list is\nspecified, the file is assigned to all CCAs in the project.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    StrainMapsFileType,\n    StrainMapLegendOrientation,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.add_strain_maps(\n    \"Tutorial Project\",\n        [\n            (\n                \"StrainMap.csv\",\n                \"This is the strain map file for the project\",\n                StrainMapsFileType.CSV,\n                0,\n                \"refDes\",\n                \"strain\",\n                \"µε\",\n                [\"Main Board\"]\n            )\n        ]\n    )\n>>> properties = (\n        BoardBounds([\n            (1.0, 2.0),\n            (3.0, 4.0),\n            (1.0, 2.0),\n            (1.0, 2.0)\n        ]),\n        \"in\",\n        ImageBounds(0.0, 0.0, 10.0, 8.0),\n        LegendBounds(1.0, 2.0, 4.0, 2.0),\n        StrainMapLegendOrientation.VERTICAL,\n        20.0,\n        50.0,\n        \"µε\"\n    )\n>>> sherlock.project.add_strain_maps(\n    \"Tutorial Project\",\n        [\n            (\n                \"StrainMap.jpg\",\n                \"This is the strain map image for the project\",\n                StrainMapsFileType.IMAGE,\n                properties,\n                [\"Main Board\"]\n            )\n        ]\n    )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PottingRegionUpdateData.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.SlotShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod SlotShape.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionCopyData.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data.html#potting_region_copy_data",
        "title": "potting_region_copy_data",
        "section": "potting_region_copy_data",
        "text": "Data identifying which potting regions to copy and what potting regions to copy from.\npotting_region_copy_data\nlist\nPottingRegionCopyData"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.potting_region_copy_data",
        "title": "potting_region_copy_data > potting_region_copy_data > potting_region_copy_data",
        "section": "potting_region_copy_data > potting_region_copy_data",
        "text": "CopyPottingRegionRequest.potting_region_copy_data: list[PottingRegionCopyData]\n\nData identifying which potting regions to copy and what potting regions to copy from.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#release-notes",
        "title": "Release notes",
        "section": "Release notes",
        "text": "This document contains the release notes for the project.\nRelease notes"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#090---may-22-2025",
        "title": "Release notes > 0.9.0 - May 22, 2025",
        "section": "0.9.0 - May 22, 2025",
        "text": "feat: launching a specific version of Sherlock\n#431\nfeat: add Analysis.update_component_failure_mechanism_analysis_props()\n#478\nfeat: New API update_semiconductor_wearout_props()\n#488\nfeat: new API update_PTH_fatigue_props()\n#492\nfeat: add Parts.get_parts_list_properties()\n#502\nfeat: new API update_pad_properties()\n#505\nfeat: Refactor launcher to allow connecting to Sherlock that is running\n#508\nfeat: new API deletePartsFromPartsList()\n#526\nfeat: Update thermal maps APIs\n#530\nfeat: Get solder info RPC\n#534\nfeat: new API import_GDSII_file\n#537\nfeat: new API to add board outline\n#560\nfix: proper AUTHORS file\n#438\nfix: API updatePTHFatigueProps()\n#506\nfix: PartLocation variable was renamed by mistake\n#515\nfix: update_pad_properties - returnCode management\n#522\nfix: don’t try to launch Sherlock that isn’t installed with corresponding version of Ansys\n#548\nfix: Error handling: improved for Parts, Lifecycle, and Stackup\n#567\nMAINT: add action changelog and changelog.rst for release notes\n#426\nUpdate unit test for HV strain map analysis.\n#428\nMAINT: Bump ansys-sphinx-theme from 1.1.6 to 1.1.7\n#429\nMAINT: Bump grpcio from 1.67.0 to 1.67.1\n#433\nMAINT: Bump pytest-cov from 5.0.0 to 6.0.0\n#434\nMAINT: Bump ansys-sphinx-theme from 1.1.7 to 1.2.0\n#436\nfeat: Adding version check to all API methods\n#440\nfeat: Keith/potting region update\n#441\nfix: Analysis.update_harmonic_vibe_props(): add support for setting model source and strain map natural frequency\n#442\ndocs: update the pull request template\n#446\nfeat:Keith/copy delete potting region\n#448\nMAINT: Bump ansys-sphinx-theme from 1.2.0 to 1.2.1\n#449\ndoc: project logo\n#450\nMAINT: Bump codecov/codecov-action from 4 to 5\n#451\nfeat: add type hints\n#454\nfeat: increment version of ansys-api-sherlock to 0.1.35\n#461\nfea: adding new PySherlock APIs Layer.list_layers and Layer.export_layer_image\n#462\nchore: update CHANGELOG for v0.8.0\n#469\nchore: update CHANGELOG for v0.8.1\n#471\nMAINT: Bump version ansys-api-sherlock to v0.1.36\n#473\ndocs: Updated documentation in update potting region.\n#477\nMAINT: bump ansys-sphinx-theme from 1.2.3 to 1.2.4\n#479\nDOC: New documentation examples\n#480\nMAINT: Add support for Python 3.13\n#481\nMAINT: bump grpcio from 1.67.1 to 1.69.0\n#482\nMAINT: bump ansys-sphinx-theme from 1.2.4 to 1.2.6\n#483\nMAINT: Revert grpcio version for tests. Modify dependabot.yml so it doesn’t update grpcio dependencies\n#485\nchore: update CHANGELOG for v0.8.2\n#489\nMAINT: bump ansys-api-sherlock from 0.1.37 to 0.1.38\n#490\nfeat: Update license file to latest\n#494\nMAINT: bump ansys-sphinx-theme from 1.2.6 to 1.2.7\n#496\nMAINT: bump ansys-api-sherlock from 0.1.38 to 0.1.39\n#497\nMAINT: bump sphinx-gallery from 0.18.0 to 0.19.0\n#499\nMAINT: bump ansys-sphinx-theme from 1.2.7 to 1.3.1\n#500\nMAINT: bump ansys-api-sherlock from 0.1.39 to 0.1.40\n#503\nMAINT: bump sphinx from 8.1.3 to 8.2.0\n#504\nMAINT: bump ansys-sphinx-theme from 1.3.1 to 1.3.2\n#509\nMAINT: bump sphinx from 8.2.0 to 8.2.3\n#516\nMAINT: bump pytest from 8.3.4 to 8.3.5\n#518\nMAINT: bump ansys-api-sherlock from 0.1.41 to 0.1.42\n#520\nfix: unit test for Layer.list_layers()\n#529\nMAINT: bump ansys-api-sherlock from 0.1.43 to 0.1.44\n#531\nMAINT: bump ansys-sphinx-theme from 1.3.2 to 1.4.2\n#532\nfeat: Keith/solder info\n#533\nmaint: set sphinx-design as documentation requirement\n#535\nMAINT: bump pytest-cov from 6.0.0 to 6.1.0\n#540\ntest: modify test for getting part list properties to validate partNumber instead of validating number of properties\n#541\nMAINT: bump pytest-cov from 6.1.0 to 6.1.1\n#542\ndocs: Update CONTRIBUTORS.md with the latest contributors\n#543, #554\nMAINT: Bump ansys/actions from 8 to 9\n#544\nfix: stackup test- modified expected CTEz for result of Stackup.get_stackup_props()\n#545\ndocs: Layer.update_modeling_region()- fixed HTML formatting of example (rem…\n#547\ntest: fix launcher tests\n#549\nMAINT: Bump ansys-api-sherlock from 0.1.45 to 0.1.46\n#552\nMAINT: Bump matplotlib from 3.9.2 to 3.10.1\n#555\nMAINT: Bump sphinx-notfound-page from 1.0.4 to 1.1.0\n#556\nMAINT: Bump ansys-sphinx-theme from 1.3.1 to 1.4.2\n#557\nMAINT: Bump sphinx-autodoc-typehints from 2.5.0 to 3.0.1\n#558\ndocs: Examples: reorganize folders, fix Sphinx warnings\n#561\ndocs: corrected the syntax of the API example for Model.exportTraceModel()\n#565\nchore: Update pre-config-hooks from 4.6.0 to 5.0.0\n#566\nMAINT: Bump ansys-sphinx-theme from 1.4.2 to 1.4.3\n#568\nMAINT: Bump ansys-sphinx-theme from 1.4.3 to 1.4.4\n#569\nMAINT: Bump matplotlib from 3.10.1 to 3.10.3\n#570\ndocs: document version compatibility in the installation instructions\n#571\n0.9.0 - May 22, 2025\nCONTRIBUTORS.md"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#082---2025-01-20",
        "title": "Release notes > 0.8.2 - 2025-01-20",
        "section": "0.8.2 - 2025-01-20",
        "text": "0.8.2 - 2025-01-20"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#documentation",
        "title": "Release notes > Documentation",
        "section": "Documentation",
        "text": "fix: changed Launcher.launch_sherlock() to properly append sherlock_command_args #487\nDocumentation"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#081---2024-12-10",
        "title": "Release notes > 0.8.1 - 2024-12-10",
        "section": "0.8.1 - 2024-12-10",
        "text": "0.8.1 - 2024-12-10"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: conf.py issue #467\nfix: import statements #470\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#documentation",
        "title": "Release notes > Documentation",
        "section": "Documentation",
        "text": "MAINT: Bump pytest from 8.3.3 to 8.3.4 #459\nMAINT: Bump ansys-sphinx-theme from 1.2.1 to 1.2.3 #463\nDocumentation"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#080---2024-12-10",
        "title": "Release notes > 0.8.0 - 2024-12-10",
        "section": "0.8.0 - 2024-12-10",
        "text": "0.8.0 - 2024-12-10"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: conf.py issue #467\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#080---2024-12-09",
        "title": "Release notes > 0.8.0 - 2024-12-09",
        "section": "0.8.0 - 2024-12-09",
        "text": "0.8.0 - 2024-12-09"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#added",
        "title": "Release notes > Added",
        "section": "Added",
        "text": "feat: launching a specific version of Sherlock #431\nAdded"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#fixed",
        "title": "Release notes > Fixed",
        "section": "Fixed",
        "text": "fix: proper AUTHORS file #438\nFixed"
    },
    {
        "objectID": "changelog",
        "href": "changelog.html#documentation",
        "title": "Release notes > Documentation",
        "section": "Documentation",
        "text": "MAINT: add action changelog and changelog.rst for release notes #426\nUpdate unit test for HV strain map analysis. #428\nMAINT: Bump ansys-sphinx-theme from 1.1.6 to 1.1.7 #429\nMAINT: Bump grpcio from 1.67.0 to 1.67.1 #433\nMAINT: Bump pytest-cov from 5.0.0 to 6.0.0 #434\nMAINT: Bump ansys-sphinx-theme from 1.1.7 to 1.2.0 #436\nfeat: Adding version check to all API methods #440\nfeat: Keith/potting region update #441\nfix: Analysis.update_harmonic_vibe_props(): add support for setting model source and strain map natural frequency #442\ndocs: update the pull request template #446\nfeat:Keith/copy delete potting region #448\nMAINT: Bump ansys-sphinx-theme from 1.2.0 to 1.2.1 #449\ndoc: project logo #450\nMAINT: Bump codecov/codecov-action from 4 to 5 #451\nfeat: add type hints #454\nfeat: increment version of ansys-api-sherlock to 0.1.35 #461\nDocumentation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_fields_set.html#ansys.sherlock.core.types.project_types.OutlineFile.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property OutlineFile.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_layer_image",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_layer_image.html#export_layer_image",
        "title": "export_layer_image",
        "section": "export_layer_image",
        "text": "Export one or more 2D Layer Viewer images from a project CCA.\nName of the Sherlock project.\nName of the CCA.\nList of parameters for the export image specified.\nEach dictionary should contain:\nDisplays the components in the export image. Default to true when not provided.\nDisplays the component reference designators in the export image. Default to true\nwhen not provided.\nDisplays the component leads and solder balls in the export image. Default to true\nwhen not provided.\nDisplays the x and y axes in the export image.\nDisplays a grid in the export image.\nThe layers as seen in the Layer Viewer for the given project CCA.\nEach dictionary should contain:\n“layer_folder”: enum, layer_folder enum.\n“layers”: list, list of names of layers under this folder\nFull file path of the export image.\nThe export image height.\nThe export image width.\nIf the file path already exists, overwrite the file if this is set to true.\nStatus code of the response. 0 for success.\nint\nexport_layer_image\npython:str\npython:str\nexport_layer_image_info\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_layer_image",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_layer_image.html#ansys.sherlock.core.layer.Layer.export_layer_image",
        "title": "export_layer_image > export_layer_image > export_layer_image",
        "section": "export_layer_image > export_layer_image",
        "text": "Layer.export_layer_image(project, cca_name, export_layers)\n\nExport one or more 2D Layer Viewer images from a project CCA.\n\nParameters\n\nproject\n\npython:str\n\nName of the Sherlock project.\n\ncca_name\n\npython:str\n\nName of the CCA.\n\nexport_layers\n\nexport_layer_image_info\n\nList of parameters for the export image specified.\nEach dictionary should contain:\n\ncomponents_enabled: bool, optional\n\nDisplays the components in the export image. Default to true when not provided.\n\nlabels_enabled: bool, optional\n\nDisplays the component reference designators in the export image. Default to true\nwhen not provided.\n\nleads_enabled\n\nbool, optional\n\nDisplays the component leads and solder balls in the export image. Default to true\nwhen not provided.\n\naxes_enabled\n\nbool\n\nDisplays the x and y axes in the export image.\n\ngrid_enabled\n\nbool\n\nDisplays a grid in the export image.\n\nlayer_infos: list[dict[enum, list]]\n\nThe layers as seen in the Layer Viewer for the given project CCA.\nEach dictionary should contain:\n\n“layer_folder”: enum, layer_folder enum.\n\n“layers”: list, list of names of layers under this folder\n\nfile_path\n\nstr\n\nFull file path of the export image.\n\nimage_height\n\nint\n\nThe export image height.\n\nimage_width\n\nint\n\nThe export image width.\n\noverwrite_existing_file\n\nbool\n\nIf the file path already exists, overwrite the file if this is set to true.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\"\n>>> )\n>>> layer_infos = [\n>>> { \"layer_folder\": \"Components\",\n>>>   \"layers\": [\"comp-top\"]},\n>>> { \"layer_folder\": \"Harmonic_Vibe\",\n>>>   \"layers\":[\"HV Disp @ 203.39 Hz\"]}\n>>> ]\n>>> export_layers = [\n>>> {\n>>>     \"components_enabled\": True,\n>>>     \"labels_enabled\": True,\n>>>     \"leads_enabled\": True,\n>>>     \"axes_enabled\": True,\n>>>     \"grid_enabled\": True,\n>>>     \"layer_infos\": layer_infos,\n>>>     \"file_path\": \"C:\\\\Users\\\\user_id\\\\Downloads\\\\SH-image.jpg\",\n>>>     \"image_height\": 600,\n>>>     \"image_width\": 800,\n>>>     \"overwrite_existing_file\": True\n>>> }\n>>> ]\n>>> sherlock.layer.export_layer_image(\"Tutorial Project\", \"Card\", export_layers)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.schema.html#ansys.sherlock.core.types.layer_types.PolygonalShape.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PolygonalShape.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionCopyData.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_file.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CsvExcelOutlineFile.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod PottingRegionCopyData.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegionUpdateData.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields.html#get_mechanical_shock_input_fields",
        "title": "get_mechanical_shock_input_fields",
        "section": "get_mechanical_shock_input_fields",
        "text": "Get mechanical shock property fields based on the user configuration.\nAvailable Since: 2024R1\nModel source to get the random vibe property fields from.\nOnly GENERATED is supported.\nDefault is None.\nMechanical shock property fields based on the user configuration.\nlist[str]\nget_mechanical_shock_input_fields\nNone\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_mechanical_shock_input_fields",
        "title": "get_mechanical_shock_input_fields > get_mechanical_shock_input_fields > get_mechanical_shock_input_fields",
        "section": "get_mechanical_shock_input_fields > get_mechanical_shock_input_fields",
        "text": "Analysis.get_mechanical_shock_input_fields(model_source=None)\n\nGet mechanical shock property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nParameters\n\nmodel_source: ModelSource, optional\n\nModel source to get the random vibe property fields from.\nOnly GENERATED is supported.\nDefault is None.\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nMechanical shock property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_mechanical_shock_input_fields(ModelSource.GENERATED)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project.html#delete_project",
        "title": "delete_project",
        "section": "delete_project",
        "text": "Delete a Sherlock project.\nAvailable Since: 2022R2\nName of the Sherlock project.\nStatus code of the response. 0 for success.\nint\ndelete_project\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.delete_project.html#ansys.sherlock.core.project.Project.delete_project",
        "title": "delete_project > delete_project > delete_project",
        "section": "delete_project > delete_project",
        "text": "Project.delete_project(project)\n\nDelete a Sherlock project.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.delete_project(\"Test Project\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_copy.html#ansys.sherlock.core.types.layer_types.CircularShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CircularShape.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_json.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CsvExcelOutlineFile.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "getting_started/index",
        "href": "getting_started/index.html#getting-started",
        "title": "Getting started",
        "section": "Getting started",
        "text": "PySherlock provides a Pythonic interface to Sherlock functionalities.\nTo use PySherlock, you must have a licensed copy of Sherlock 2022 R2 or later installed.\nFor more information on Sherlock, see the\nAnsys Sherlock\npage on the Ansys website.\nGetting started"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_file.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PCBShape.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#add-harmonic-event-to-lifecycle-phase",
        "title": "Add Harmonic Event to Lifecycle Phase",
        "section": "Add Harmonic Event to Lifecycle Phase",
        "text": "This example demonstrates how to launch the Sherlock gRPC service, import a project,\ncreate a lifecycle phase, and add a harmonic event to the phase, then properly close the connection.\nAdd Harmonic Event to Lifecycle Phase"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#description",
        "title": "Add Harmonic Event to Lifecycle Phase > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as creating lifecycle phases\nand adding harmonic events.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Create a lifecycle phase.\n- Add a harmonic event to the lifecycle phase.\nThe harmonic event can be used for thermal analysis and helps in simulating the effects\nof various conditions on the board.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#connect-to-sherlock",
        "title": "Add Harmonic Event to Lifecycle Phase > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#delete-project",
        "title": "Add Harmonic Event to Lifecycle Phase > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#import-tutorial-project",
        "title": "Add Harmonic Event to Lifecycle Phase > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#create-lifecycle-phase",
        "title": "Add Harmonic Event to Lifecycle Phase > Create Lifecycle Phase",
        "section": "Create Lifecycle Phase",
        "text": "Create a new lifecycle phase called “Example” in the “Test” project.\nCreate Lifecycle Phase"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_harmonic_event",
        "href": "examples/gallery_examples/01-project-configuration/add_harmonic_event.html#add-harmonic-event-to-lifecycle-phase",
        "title": "Add Harmonic Event to Lifecycle Phase",
        "section": "Add Harmonic Event to Lifecycle Phase",
        "text": "Add a harmonic event to the “Example” lifecycle phase.\nDownload Jupyter notebook: add_harmonic_event.ipynb\nDownload Python source code: add_harmonic_event.py\nDownload zipped: add_harmonic_event.zip\nAdd Harmonic Event to Lifecycle Phase\nDownload Jupyter notebook: add_harmonic_event.ipynb\nDownload Python source code: add_harmonic_event.py\nDownload zipped: add_harmonic_event.zip"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#add-potting-regions-for-pcb-analysis",
        "title": "Add Potting Regions for PCB Analysis",
        "section": "Add Potting Regions for PCB Analysis",
        "text": "This example demonstrates how to use the Sherlock gRPC service to:\n- Import a project.\n- Add potting regions to a PCB model.\n- Define potting shapes and properties.\nAdd Potting Regions for PCB Analysis"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#description",
        "title": "Add Potting Regions for PCB Analysis > Description",
        "section": "Description",
        "text": "This script connects to the Sherlock gRPC service, imports a project,\nand creates potting regions.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#connect-to-sherlock",
        "title": "Add Potting Regions for PCB Analysis > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#delete-project",
        "title": "Add Potting Regions for PCB Analysis > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#import-tutorial-project",
        "title": "Add Potting Regions for PCB Analysis > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/add_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/add_potting_region.html#add-potting-region",
        "title": "Add Potting Regions for PCB Analysis > Add Potting Region",
        "section": "Add Potting Region",
        "text": "Define a polygonal shape and add it as a potting region to the PCB.\nDownload Jupyter notebook: add_potting_region.ipynb\nDownload Python source code: add_potting_region.py\nDownload zipped: add_potting_region.zip\nAdd Potting Region\nDownload Jupyter notebook: add_potting_region.ipynb\nDownload Python source code: add_potting_region.py\nDownload zipped: add_potting_region.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_file.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod GerberOutlineFile.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project",
        "href": "api/project.html#project",
        "title": "Project",
        "section": "Project",
        "text": "Module containing all project management capabilities.\nProject(channel, server_version)\nContains all project management capabilities.\nProject\nProject"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_post_init.html#ansys.sherlock.core.types.layer_types.CircularShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "CircularShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_extra.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property GerberOutlineFile.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PolygonalShape.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region.html#delete_modeling_region",
        "title": "delete_modeling_region",
        "section": "delete_modeling_region",
        "text": "Delete one or more modeling regions for a specific project.\nName of the Sherlock project.\nModeling regions to delete. Each dictionary should contain:\n- “cca_name”: str, Name of the CCA.\n- “region_id”: str, Unique region ID of the modeling region to delete.\nStatus code of the response. 0 for success.\nint\ndelete_modeling_region\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.delete_modeling_region.html#ansys.sherlock.core.layer.Layer.delete_modeling_region",
        "title": "delete_modeling_region > delete_modeling_region > delete_modeling_region",
        "section": "delete_modeling_region > delete_modeling_region",
        "text": "Layer.delete_modeling_region(project, delete_regions)\n\nDelete one or more modeling regions for a specific project.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ndelete_regions: list[dict[str, str]]\n\nModeling regions to delete. Each dictionary should contain:\n- “cca_name”: str, Name of the CCA.\n- “region_id”: str, Unique region ID of the modeling region to delete.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> modeling_regions = [{\"cca_name\": \"Card\", \"region_id\": \"12345\"}]\n>>> sherlock.layer.delete_modeling_region(\"Test\", modeling_regions)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionUpdateData.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_decimal_first",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_decimal_first.html#parse_decimal_first",
        "title": "parse_decimal_first",
        "section": "parse_decimal_first",
        "text": "Indicates to parse decimals based on the length of the format specifier.\nparse_decimal_first\nbool"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_decimal_first",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_decimal_first.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_decimal_first",
        "title": "parse_decimal_first > parse_decimal_first > parse_decimal_first",
        "section": "parse_decimal_first > parse_decimal_first",
        "text": "GerberOutlineFile.parse_decimal_first: bool\n\nIndicates to parse decimals based on the length of the format specifier.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "The potting ID.\npotting_id\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegion.potting_id: str\n\nThe potting ID.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.copy.html#ansys.sherlock.core.types.layer_types.SlotShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "SlotShape.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.from_orm.html#ansys.sherlock.core.types.layer_types.SlotShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod SlotShape.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.copy.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CsvExcelOutlineFile.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "UpdatePottingRegionRequest.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#export-all-test-fixtures",
        "title": "Export All Test Fixtures",
        "section": "Export All Test Fixtures",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export all test fixtures for a CCA.\nExport All Test Fixtures"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#description",
        "title": "Export All Test Fixtures > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API enables users to automate various workflows, including exporting all\ntest fixtures for a CCA.\nThis script demonstrates how to:\nConnect to the Sherlock service.\nImport a tutorial project.\nExport all test fixtures to a CSV file.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#connect-to-sherlock",
        "title": "Export All Test Fixtures > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#delete-project",
        "title": "Export All Test Fixtures > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#import-tutorial-project",
        "title": "Export All Test Fixtures > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_all_test_fixtures",
        "href": "examples/gallery_examples/03-exporting/export_all_test_fixtures.html#export-all-test-fixtures",
        "title": "Export All Test Fixtures",
        "section": "Export All Test Fixtures",
        "text": "Export all test fixtures for the “Main Board” to a CSV file.\nDownload Jupyter notebook: export_all_test_fixtures.ipynb\nDownload Python source code: export_all_test_fixtures.py\nDownload zipped: export_all_test_fixtures.zip\nExport All Test Fixtures\nDownload Jupyter notebook: export_all_test_fixtures.ipynb\nDownload Python source code: export_all_test_fixtures.py\nDownload zipped: export_all_test_fixtures.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.SlotShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "SlotShape.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region.html#add_modeling_region",
        "title": "add_modeling_region",
        "section": "add_modeling_region",
        "text": "Add one or more modeling regions to a specific project.\nName of the Sherlock project.\nModeling regions to add. Each dictionary should contain:\nName of the CCA.\nUnique region ID of the modeling region.\nUnits of the modeling region.\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\nThe shape of the modeling region.\nPCB model parameters consisting of these properties:\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum size of the mesh to be used in the region.\nUnits for the maximum mesh size.\nWhether to generate quad-shaped elements when creating the mesh if true.\nTrace model parameters consisting of these properties:\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\nUnits for the maximum mesh size when trace modeling is enabled.\nStatus code of the response. 0 for success.\nint\nadd_modeling_region\nEnabled\nDisabled\nExcluded\nDefault\nSherlock\nSweep\nNone\nFirst_Order\nSecond_Order\nSolid_Shell\nDefault\nEnabled\nDisabled\nFirst_Order\nSecond_Order\nSolid_Shell\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.add_modeling_region.html#ansys.sherlock.core.layer.Layer.add_modeling_region",
        "title": "add_modeling_region > add_modeling_region > add_modeling_region",
        "section": "add_modeling_region > add_modeling_region",
        "text": "Layer.add_modeling_region(project, modeling_regions)\n\nAdd one or more modeling regions to a specific project.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nmodeling_regions: list[dict[str, bool | float | str | dict[str, bool | float | str]                | dict[str, float | str]]]\n\nModeling regions to add. Each dictionary should contain:\n\ncca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type\n\nstr\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size\n\nfloat, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> modeling_regions = [\n>>> {\n>>>     \"cca_name\": \"Card\",\n>>>     \"region_id\": \"Region001\",\n>>>     \"region_units\": \"mm\",\n>>>     \"model_mode\": \"Enabled\",\n>>>     \"shape\": PolygonalShape(points=[\n>>>         (0, 0),\n>>>         (0, 6.35),\n>>>         (9.77, 0)\n>>>     ], rotation=87.8),\n>>>     \"pcb_model_props\": {\n>>>         \"export_model_type\": \"Sherlock\",\n>>>         \"elem_order\": \"First_Order\",\n>>>         \"max_mesh_size\": 0.5,\n>>>         \"max_mesh_size_units\": \"mm\",\n>>>         \"quads_preferred\": True\n>>>     },\n>>>     \"trace_model_props\": {\n>>>         \"trace_model_type\": \"Enabled\",\n>>>         \"elem_order\": \"Second_Order\",\n>>>         \"trace_mesh_size\": 0.3,\n>>>         \"trace_mesh_size_units\": \"mm\"\n>>>     }\n>>> }\n>>> ]\n>>> result = sherlock.layer.add_modeling_region(\"Tutorial Project\", modeling_regions)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegionUpdateData.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model.html#generate_trace_model",
        "title": "generate_trace_model",
        "section": "generate_trace_model",
        "text": "Generate one or more trace models for a project.\nAvailable Since: 2023R2\nName of the Sherlock project to generate one or more trace models for.\nName of the CCA to generate one or more trace models from. The default is\n\"\", in which case trace models are generated for CCAs and\nall layers.\nName of the copper layer to generate one or more trace models from. The default\nis \"\", in which case trace models are generated either for the given CCA\nor for all layers.\nMaximum length of the segment to generate when Sherlock\nconverts EDA arc drawing commands to line segments. The default is\n0.0. Smaller values for the maximum arc segment result in smoother\narc representations on the FEA model. However, the cost of generating a\nlarger number of shorter segments is higher. Such short segments cause\nthe FEA tool to generate a larger number of smaller elements to represent\nthe curved solid.\nUnits for the maximum arc segment. The default is \"mm\".\nMinimum area of any trace polygon to include in the trace model.\nThe default is 0.0, which turns off any area filtering.\nUnits for the minimum trace area. The default is \"mm2\".\nMinimum area of any trace hole to include in the trace model.\nThe default is 0.0, which turns off any hole filtering.\nUnits for the minimum hole area. The default is \"mm2\".\nWhether to use an image to generate the trace model for layers that are not\nimage layers. The default is False. If True and a snapshot image for\nthe layer exists, the snapshot image is used. Otherwise, an image is created\nin the same way as a snapshot image is created.\nStatus code of the response. 0 for success.\nint\ngenerate_trace_model\n\"\"\n\"\"\n0.0\n\"mm\"\n0.0\n\"mm2\"\n0.0\n\"mm2\"\nFalse\nTrue\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.generate_trace_model.html#ansys.sherlock.core.model.Model.generate_trace_model",
        "title": "generate_trace_model > generate_trace_model > generate_trace_model",
        "section": "generate_trace_model > generate_trace_model",
        "text": "Model.generate_trace_model(project_name, cca_name='', copper_layer_name='', max_arc_segment=0.0, max_arc_segment_units='mm', min_trace_area=0.0, min_trace_area_units='mm2', min_hole_area=0.0, min_hole_area_units='mm2', use_snapshot_for_non_image_layer=False)\n\nGenerate one or more trace models for a project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject_name: str\n\nName of the Sherlock project to generate one or more trace models for.\n\ncca_name: str, optional\n\nName of the CCA to generate one or more trace models from. The default is\n\"\", in which case trace models are generated for CCAs and\nall layers.\n\ncopper_layer_name: str, optional\n\nName of the copper layer to generate one or more trace models from. The default\nis \"\", in which case trace models are generated either for the given CCA\nor for all layers.\n\nmax_arc_segment: float, optional\n\nMaximum length of the segment to generate when Sherlock\nconverts EDA arc drawing commands to line segments. The default is\n0.0. Smaller values for the maximum arc segment result in smoother\narc representations on the FEA model. However, the cost of generating a\nlarger number of shorter segments is higher. Such short segments cause\nthe FEA tool to generate a larger number of smaller elements to represent\nthe curved solid.\n\nmax_arc_segment_units: str, optional\n\nUnits for the maximum arc segment. The default is \"mm\".\n\nmin_trace_area: float, optional\n\nMinimum area of any trace polygon to include in the trace model.\nThe default is 0.0, which turns off any area filtering.\n\nmin_trace_area_units: str, optional\n\nUnits for the minimum trace area. The default is \"mm2\".\n\nmin_hole_area: float, optional\n\nMinimum area of any trace hole to include in the trace model.\nThe default is 0.0, which turns off any hole filtering.\n\nmin_hole_area_units: str, optional\n\nUnits for the minimum hole area. The default is \"mm2\".\n\nuse_snapshot_for_non_image_layer: bool, optional\n\nWhether to use an image to generate the trace model for layers that are not\nimage layers. The default is False. If True and a snapshot image for\nthe layer exists, the snapshot image is used. Otherwise, an image is created\nin the same way as a snapshot image is created.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.generate_trace_model(\n    'Tutorial Project', 'Main Board', 0.05, 'mm'\n    0.0, 'mm2', 0.0, 'mm2')\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#run-mechanical-shock-analysis-example",
        "title": "Run Mechanical Shock Analysis Example",
        "section": "Run Mechanical Shock Analysis Example",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nadd strain maps, and run a mechanical shock analysis based on strain maps.\nRun Mechanical Shock Analysis Example"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#description",
        "title": "Run Mechanical Shock Analysis Example > Description",
        "section": "Description",
        "text": "Sherlock provides tools to perform mechanical shock analysis using strain maps.\nThis script includes the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Add a strain map file to the project.\n- Configure the analysis properties for mechanical shock.\n- Execute the mechanical shock analysis.\nFor further details, refer to the official documentation on mechanical shock analysis in Sherlock.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#connect-to-sherlock",
        "title": "Run Mechanical Shock Analysis Example > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#delete-project",
        "title": "Run Mechanical Shock Analysis Example > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#import-tutorial-project",
        "title": "Run Mechanical Shock Analysis Example > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#add-strain-map",
        "title": "Run Mechanical Shock Analysis Example > Add Strain Map",
        "section": "Add Strain Map",
        "text": "Add a strain map to the project.\nAdd Strain Map"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#update-mechanical-shock-properties",
        "title": "Run Mechanical Shock Analysis Example > Update Mechanical Shock Properties",
        "section": "Update Mechanical Shock Properties",
        "text": "Configure properties for mechanical shock analysis using strain maps.\nUpdate Mechanical Shock Properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis",
        "href": "examples/gallery_examples/04-analyses/run_mechanical_shock_strain_map_analysis.html#run-mechanical-shock-analysis",
        "title": "Run Mechanical Shock Analysis Example > Run Mechanical Shock Analysis",
        "section": "Run Mechanical Shock Analysis",
        "text": "Execute the mechanical shock analysis based on strain maps.\nDownload Jupyter notebook: run_mechanical_shock_strain_map_analysis.ipynb\nDownload Python source code: run_mechanical_shock_strain_map_analysis.py\nDownload zipped: run_mechanical_shock_strain_map_analysis.zip\nRun Mechanical Shock Analysis\nDownload Jupyter notebook: run_mechanical_shock_strain_map_analysis.ipynb\nDownload Python source code: run_mechanical_shock_strain_map_analysis.py\nDownload zipped: run_mechanical_shock_strain_map_analysis.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PolygonalShape.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CopyPottingRegionRequest.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionCopyData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property UpdatePottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile.html#load_thermal_profile",
        "title": "load_thermal_profile",
        "section": "load_thermal_profile",
        "text": "Load a thermal profile from a .dat or .csv file.\nAvailable Since: 2021R1\nName of the Sherlock project\nName of the lifecycle phase to add this event to.\nName of the random vibe event.\nFile path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_thermal_profile\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_thermal_profile",
        "title": "load_thermal_profile > load_thermal_profile > load_thermal_profile",
        "section": "load_thermal_profile > load_thermal_profile",
        "text": "Lifecycle.load_thermal_profile(project, phase_name, event_name, file_path)\n\nLoad a thermal profile from a .dat or .csv file.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nphase_name: str\n\nName of the lifecycle phase to add this event to.\n\nevent_name: str\n\nName of the random vibe event.\n\nfile_path: str\n\nFile path for thermal profile .dat or .csv file\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n >>>loaded = sherlock.lifecycle.load_thermal_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Thermal Event\",\n        file_path=\"Tutorial_Profile.dat\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_project.html#add_project",
        "title": "add_project",
        "section": "add_project",
        "text": "Add a sherlock project to sherlock.\nAvailable Since: 2024R1\nName of the Sherlock project.\nCategory of the Sherlock project\nDescription of the Sherlock project\n0 for success otherwise error\nint\nadd_project\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_project.html#ansys.sherlock.core.project.Project.add_project",
        "title": "add_project > add_project > add_project",
        "section": "add_project > add_project",
        "text": "Project.add_project(project_name, project_category, project_description)\n\nAdd a sherlock project to sherlock.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject_name: str\n\nName of the Sherlock project.\n\nproject_category: str\n\nCategory of the Sherlock project\n\nproject_description: str\n\nDescription of the Sherlock project\n\nReturns\n\n:\n\n\n\npython:int\n\n0 for success otherwise error\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> code = sherlock.project.add_project(\n    \"project name example\",\n    \"project category example\",\n    \"project description example\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionUpdateData.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PolygonalShape.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length.html#length",
        "title": "length",
        "section": "length",
        "text": "float\nlength\nlength\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.length.html#ansys.sherlock.core.types.layer_types.RectangularShape.length",
        "title": "length > length > length",
        "section": "length > length",
        "text": "RectangularShape.length: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nlength"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "UpdatePottingRegionRequest.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields.html#get_ict_analysis_input_fields",
        "title": "get_ict_analysis_input_fields",
        "section": "get_ict_analysis_input_fields",
        "text": "Get ICT analysis property fields based on the user configuration.\nAvailable Since: 2024R1\nICT analysis property fields based on the user configuration.\nNone if not connected to Sherlock.\nlist[str]\nget_ict_analysis_input_fields\npython:list\npython:str\nNone\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_ict_analysis_input_fields",
        "title": "get_ict_analysis_input_fields > get_ict_analysis_input_fields > get_ict_analysis_input_fields",
        "section": "get_ict_analysis_input_fields > get_ict_analysis_input_fields",
        "text": "Analysis.get_ict_analysis_input_fields()\n\nGet ICT analysis property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nICT analysis property fields based on the user configuration.\nNone if not connected to Sherlock.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.analysis.get_ict_analysis_input_fields()\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "UpdatePottingRegionRequest.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.PCBShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PCBShape.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.construct.html#ansys.sherlock.core.types.layer_types.PottingRegion.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegion.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionCopyData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PCBShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PCBShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report.html#generate_project_report",
        "title": "generate_project_report",
        "section": "generate_project_report",
        "text": "Generate a project report.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the author who is generating the report.\nName of the author’s company.\nFull path to where to create the report.\nStatus code of the response. 0 for success.\nint\ngenerate_project_report\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.generate_project_report.html#ansys.sherlock.core.project.Project.generate_project_report",
        "title": "generate_project_report > generate_project_report > generate_project_report",
        "section": "generate_project_report > generate_project_report",
        "text": "Project.generate_project_report(project, author, company, report_file)\n\nGenerate a project report.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nauthor: str\n\nName of the author who is generating the report.\n\ncompany: str\n\nName of the author’s company.\n\nreport_file: str\n\nFull path to where to create the report.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\"ODB++ Tutorial.tgz\", True, True,\n                        True, True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\")\n>>> sherlock.project.generate_project_report(\n    \"Tutorial\",\n    \"John Doe\",\n    \"Example\",\n    \"Project Report.pdf\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod RectangularShape.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PolygonalShape.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures.html#export_all_test_fixtures",
        "title": "export_all_test_fixtures",
        "section": "export_all_test_fixtures",
        "text": "Export the test fixture properties for a CCA.\nName of the Sherlock project.\nName of the CCA.\nFull path for the CSV file to export the text fixtures list to.\nUnits to use when exporting the test fixtures.\nThe default is DEFAULT.\nStatus code of the response. 0 for success.\nint\nexport_all_test_fixtures\nDEFAULT\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.export_all_test_fixtures.html#ansys.sherlock.core.layer.Layer.export_all_test_fixtures",
        "title": "export_all_test_fixtures > export_all_test_fixtures > export_all_test_fixtures",
        "section": "export_all_test_fixtures > export_all_test_fixtures",
        "text": "Layer.export_all_test_fixtures(project, cca_name, export_file, units='DEFAULT')\n\nExport the test fixture properties for a CCA.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nexport_file: str\n\nFull path for the CSV file to export the text fixtures list to.\n\nunits: str, optional\n\nUnits to use when exporting the test fixtures.\nThe default is DEFAULT.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.export_all_test_fixtures(\n>>>     \"Tutorial Project\",\n>>>     \"Card\",\n>>>     \"TestFixturesExport.csv\",\n>>>     \"DEFAULT\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.from_orm.html#ansys.sherlock.core.types.layer_types.PCBShape.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PCBShape.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.cca_names",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.cca_names.html#cca_names",
        "title": "cca_names",
        "section": "cca_names",
        "text": "The list of CCA names for the outline file.\ncca_names\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.cca_names",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.cca_names.html#ansys.sherlock.core.types.project_types.OutlineFile.cca_names",
        "title": "cca_names > cca_names > cca_names",
        "section": "cca_names > cca_names",
        "text": "OutlineFile.cca_names: list[str]\n\nThe list of CCA names for the outline file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.html#ansyssherlockcoretypesproject_typesboardbounds",
        "title": "ansys.sherlock.core.types.project_types.BoardBounds",
        "section": "ansys.sherlock.core.types.project_types.BoardBounds",
        "text": "Contains the properties of the board bounds.\nBoardBounds.bounds\nbounds (two tuples of the form (x, y)\nansys.sherlock.core.types.project_types.BoardBounds\nBoardBounds.bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.html#ansys.sherlock.core.types.project_types.BoardBounds",
        "title": "ansys.sherlock.core.types.project_types.BoardBounds > ansys.sherlock.core.types.project_types.BoardBounds > BoardBounds",
        "section": "ansys.sherlock.core.types.project_types.BoardBounds > BoardBounds",
        "text": "class ansys.sherlock.core.types.project_types.BoardBounds(bounds)\n\nContains the properties of the board bounds.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nBoardBounds.bounds\n\nbounds (two tuples of the form (x, y)\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations.html#update_parts_locations",
        "title": "update_parts_locations",
        "section": "update_parts_locations",
        "text": "Update one or more part locations.\nAvailable Since: 2022R2\nName of the Sherlock project.\nName of the CCA.\nList defining the part locations. The list consists\nof these properties:\nReference designator of the part.\nValue for the x coordinate.\nValue for the y coordinate.\nRotation.\nLocations units.\nBoard side.\nMirrored.\nStatus code of the response. 0 for success.\nint\nupdate_parts_locations\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_locations.html#ansys.sherlock.core.parts.Parts.update_parts_locations",
        "title": "update_parts_locations > update_parts_locations > update_parts_locations",
        "section": "update_parts_locations > update_parts_locations",
        "text": "Parts.update_parts_locations(project, cca_name, part_loc)\n\nUpdate one or more part locations.\n\nAvailable Since: 2022R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\npart_loc: list[tuple[str, str, str, str, str, str, str]]\n\nList defining the part locations. The list consists\nof these properties:\n\nrefDes: str\n\nReference designator of the part.\n\nx: str\n\nValue for the x coordinate.\n\ny: str\n\nValue for the y coordinate.\n\nrotation: str\n\nRotation.\n\nlocation_units: str\n\nLocations units.\n\nboard_side: str\n\nBoard side.\n\nmirrored: str\n\nMirrored.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_locations(\n    \"Test\",\n    \"Card\",\n    [\n        (\"C1\", \"-2.7\", \"-1.65\", \"0\", \"in\", \"TOP\", \"False\"),\n        (\"J1\", \"-3.55\", \"-2.220446049250313E-16\", \"90\", \"in\", \"TOP\", \"False\"),\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegionUpdateData.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_extra.html#ansys.sherlock.core.types.layer_types.SlotShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property SlotShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionDeleteData.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod UpdatePottingRegionRequest.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps.html#update_thermal_maps",
        "title": "update_thermal_maps",
        "section": "update_thermal_maps",
        "text": "Update thermal map files to a Sherlock project.\nAvailable Since: 2024R2\nName of the Sherlock project to update thermal maps to.\nList of thermal map files consisting of these properties:\nName of the thermal file to update.\nThermal maps file type.\nComment to associate with the file.\nThermal board side.\nThe properties of the thermal map file to update.\nList of thermal profiles.\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\nStatus code of the response. 0 for success.\nint\nupdate_thermal_maps\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.update_thermal_maps.html#ansys.sherlock.core.project.Project.update_thermal_maps",
        "title": "update_thermal_maps > update_thermal_maps > update_thermal_maps",
        "section": "update_thermal_maps > update_thermal_maps",
        "text": "Project.update_thermal_maps(project, thermal_map_files)\n\nUpdate thermal map files to a Sherlock project.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project to update thermal maps to.\n\nthermal_map_files: list\n\nList of thermal map files consisting of these properties:\n\nfile_name: str\n\nName of the thermal file to update.\n\nfile_type: ThermalMapsFileType\n\nThermal maps file type.\n\nfile_comment: str, optional\n\nComment to associate with the file.\n\nthermal_board_side: ThermalBoardSide\n\nThermal board side.\n\nfile_data: CsvExcelFile|IcepakFile|ImageFile\n\nThe properties of the thermal map file to update.\n\nthermal_profiles: List of str\n\nList of thermal profiles.\n\ncca_names: List of str, optional\n\nList of CCA names to provide thermal maps for. The default is None,\nin which case all CCAs in the project are returned.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.project_types import (\n    BoardBounds,\n    ImageBounds,\n    ImageFile,\n    LegendBounds,\n    LegendOrientation,\n    ThermalBoardSide,\n    ThermalMapsFileType,\n)\n>>> sherlock = launch_sherlock()\n>>> thermal_map_properties = ImageFile(board_bounds=BoardBounds([\n    (1.0, 2.0),\n    (3.0, 4.0),\n    (1.0, 2.0),\n    (1.0, 2.0)]),\n    coordinate_units=\"in\",\n    image_bounds=ImageBounds(0.0, 0.0, 10.0, 8.0),\n    legend_bounds=LegendBounds(1.0, 2.0, 4.0, 2.0),\n    legend_orientation=LegendOrientation.VERTICAL,\n    max_temperature=50.0,\n    max_temperature_units=\"C\",\n    min_temperature=20.0,\n    min_temperature_units=\"C\"\n)\n>>> files = [\n    {\n        \"file_name\": \"thermal_map_file.jpg\",\n        \"file_type\": ThermalMapsFileType.IMAGE,\n        \"file_comment\": \"Update thermal map\",\n        \"thermal_board_side\": ThermalBoardSide.TOP,\n        \"file_data\": thermal_map_properties,\n        \"thermal_profiles\": [\"Environmental/1 - Temp Cycle - Min\"],\n        \"cca_names\": [\"CCA1\", \"CCA2\"]\n    },\n]\n>>> sherlock.project.update_thermal_maps(\"Tutorial Project\", files)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region.html#potting_region",
        "title": "potting_region",
        "section": "potting_region",
        "text": "Potting region data used to update the potting region.\npotting_region\nPottingRegion"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.potting_region",
        "title": "potting_region > potting_region > potting_region",
        "section": "potting_region > potting_region",
        "text": "PottingRegionUpdateData.potting_region: PottingRegion\n\nPotting region data used to update the potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width.html#width",
        "title": "width",
        "section": "width",
        "text": "width of the legend\nfloat\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.width.html#ansys.sherlock.core.types.project_types.LegendBounds.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "LegendBounds.width\n\nwidth of the legend\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_obj.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CircularShape.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property DeletePottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.json.html#ansys.sherlock.core.types.layer_types.PolygonalShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PolygonalShape.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionDeleteData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PolygonalShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_post_init.html#ansys.sherlock.core.types.project_types.OutlineFile.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "OutlineFile.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_config.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "PottingRegion.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PottingRegionUpdateData.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "Id of the potting region(s) to delete.\npotting_id\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegionDeleteData.potting_id: str\n\nId of the potting region(s) to delete.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/index",
        "href": "examples/gallery_examples/04-analyses/index.html#running-analyses",
        "title": "Running Analyses",
        "section": "Running Analyses",
        "text": "Examples on how to run analyses using PySherlock.\nsphx_glr_examples_gallery_examples_04-analyses_get_parts_list_analysis_props.py\nsphx_glr_examples_gallery_examples_04-analyses_get_random_vibe_inputs_fields.py\nsphx_glr_examples_gallery_examples_04-analyses_run_analysis.py\nsphx_glr_examples_gallery_examples_04-analyses_run_harmonic_vibe_strain_map_analysis.py\nsphx_glr_examples_gallery_examples_04-analyses_run_mechanical_shock_strain_map_analysis.py\nsphx_glr_examples_gallery_examples_04-analyses_run_random_vibe_strain_map_analysis.py\nsphx_glr_examples_gallery_examples_04-analyses_update_harmonic_vibe_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_ict_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_mechanical_shock_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_part_validation_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_pcb_modeling_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_random_vibe_properties.py\nsphx_glr_examples_gallery_examples_04-analyses_update_solder_fatigue_properties.py\nRunning Analyses"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter.html#diameter",
        "title": "diameter",
        "section": "diameter",
        "text": "float\ndiameter\ndiameter\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.diameter.html#ansys.sherlock.core.types.layer_types.CircularShape.diameter",
        "title": "diameter > diameter > diameter",
        "section": "diameter > diameter",
        "text": "CircularShape.diameter: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\ndiameter"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "DeletePottingRegionRequest.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup.html#gen_stackup",
        "title": "gen_stackup",
        "section": "gen_stackup",
        "text": "Generate a new stackup from given properties.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nBoard thickness.\nUnits for the board thickness.\nManufacturer for the PCB material.\nGrade for the PCB material.\nMaterial for the PCB.\nNumber of conductor layers.\nSignal layer thickness.\nUnits for the signal layer thickness.\nMinimum thickness of laminate layers.\nUnits for the minimum thickness of laminate layers.\nWhether to maintain symmetry.\nPower layer thickness.\nUnits for the power layer thickness.\nStatus code of the response. 0 for success.\nint\ngen_stackup\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.gen_stackup.html#ansys.sherlock.core.stackup.Stackup.gen_stackup",
        "title": "gen_stackup > gen_stackup > gen_stackup",
        "section": "gen_stackup > gen_stackup",
        "text": "Stackup.gen_stackup(project, cca_name, board_thickness, board_thickness_unit, pcb_material_manufacturer, pcb_material_grade, pcb_material, conductor_layers_cnt, signal_layer_thickness, signal_layer_thickness_unit, min_laminate_thickness, min_laminate_thickness_unit, maintain_symmetry, power_layer_thickness, power_layer_thickness_unit)\n\nGenerate a new stackup from given properties.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nboard_thickness: float\n\nBoard thickness.\n\nboard_thickness_unit: str\n\nUnits for the board thickness.\n\npcb_material_manufacturer: str\n\nManufacturer for the PCB material.\n\npcb_material_grade: str\n\nGrade for the PCB material.\n\npcb_material: str\n\nMaterial for the PCB.\n\nconductor_layers_cnt: int32\n\nNumber of conductor layers.\n\nsignal_layer_thickness: float\n\nSignal layer thickness.\n\nsignal_layer_thickness_unit: str\n\nUnits for the signal layer thickness.\n\nmin_laminate_thickness: float\n\nMinimum thickness of laminate layers.\n\nmin_laminate_thickness_unit: str\n\nUnits for the minimum thickness of laminate layers.\n\nmaintain_symmetry: bool\n\nWhether to maintain symmetry.\n\npower_layer_thickness: float\n\nPower layer thickness.\n\npower_layer_thickness_unit: str\n\nUnits for the power layer thickness.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.gen_stackup(\n    \"Test\",\n    \"Card\",\n    82.6,\n    \"mil\",\n    \"Generic\",\n    \"FR-4\",\n    \"Generic FR-4\",\n    6,\n    0.5,\n    \"oz\",\n    1.0,\n    \"mil\",\n    False,\n    1.0,\n    \"mil\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegion.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event.html#add_random_vibe_event",
        "title": "add_random_vibe_event",
        "section": "add_random_vibe_event",
        "text": "Add a random vibe event to a life cycle phase.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the life cycle phase to add the random vibe event to.\nName of the random vibe event.\nEvent duration length.\nEvent duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\nNumber of cycles for the random vibe event.\nCycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nRandom load profile type. The only option is \"Uniaxial\".\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\nDescription of the random vibe event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_random_vibe_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY_CYCLE\"\n\"PER_YEAR\"\n\"PER_DAY\"\n\"PER_HOUR\"\n\"PER_MIN\"\n\"PER_SEC\"\n\"azimuth, elevation\"\n\"30,15\"\n\"Uniaxial\"\n\"x,y,z\"\n\"0,0,1\"\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_random_vibe_event",
        "title": "add_random_vibe_event > add_random_vibe_event > add_random_vibe_event",
        "section": "add_random_vibe_event > add_random_vibe_event",
        "text": "Lifecycle.add_random_vibe_event(project, phase_name, event_name, duration, duration_units, num_of_cycles, cycle_type, orientation, profile_type, load_direction, description='')\n\nAdd a random vibe event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nphase_name: str\n\nName of the life cycle phase to add the random vibe event to.\n\nevent_name: str\n\nName of the random vibe event.\n\nduration: float\n\nEvent duration length.\n\nduration_units: str\n\nEvent duration units. Options are \"ms\", \"sec\", \"min\",\n\"hr\", \"day\", and \"year\".\n\nnum_of_cycles: float\n\nNumber of cycles for the random vibe event.\n\ncycle_type: str\n\nCycle type. Options are \"COUNT\", \"DUTY_CYCLE\", \"PER_YEAR\",\n\"PER_DAY\", \"PER_HOUR\", \"PER_MIN\", and \"PER_SEC\".\n\norientation: str\n\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nprofile_type: str\n\nRandom load profile type. The only option is \"Uniaxial\".\n\nload_direction: str\n\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription: str, optional\n\nDescription of the random vibe event. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_random_vibe_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"Uniaxial\",\n    \"2,4,5\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side.html#potting_side",
        "title": "potting_side",
        "section": "potting_side",
        "text": "The potting side, options are “TOP”, “BOT”, or “BOTTOM”.\npotting_side\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_side.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_side",
        "title": "potting_side > potting_side > potting_side",
        "section": "potting_side > potting_side",
        "text": "PottingRegion.potting_side: str\n\nThe potting side, options are “TOP”, “BOT”, or “BOTTOM”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegion.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegion.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CopyPottingRegionRequest.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod PottingRegionDeleteData.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_fea_model",
        "href": "examples/gallery_examples/03-exporting/export_fea_model.html#export-fea-model",
        "title": "Export FEA Model",
        "section": "Export FEA Model",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export a Finite Element Analysis (FEA) model.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including exporting FEA models.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a tutorial project.\n- Export an FEA model with specific parameters.\nExport FEA Model"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_fea_model",
        "href": "examples/gallery_examples/03-exporting/export_fea_model.html#connect-to-sherlock",
        "title": "Export FEA Model > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_fea_model",
        "href": "examples/gallery_examples/03-exporting/export_fea_model.html#delete-project",
        "title": "Export FEA Model > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_fea_model",
        "href": "examples/gallery_examples/03-exporting/export_fea_model.html#import-tutorial-project",
        "title": "Export FEA Model > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive provided with the Sherlock installation.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_fea_model",
        "href": "examples/gallery_examples/03-exporting/export_fea_model.html#export-fea-model",
        "title": "Export FEA Model",
        "section": "Export FEA Model",
        "text": "Export the FEA model with customized parameters.\nDownload Jupyter notebook: export_fea_model.ipynb\nDownload Python source code: export_fea_model.py\nDownload zipped: export_fea_model.zip\nExport FEA Model\nDownload Jupyter notebook: export_fea_model.ipynb\nDownload Python source code: export_fea_model.py\nDownload zipped: export_fea_model.zip"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_part_list",
        "href": "examples/gallery_examples/03-exporting/export_part_list.html#export-parts-list",
        "title": "Export Parts List",
        "section": "Export Parts List",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export the parts list associated with the imported project.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including parts list export.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Exporting the parts list from the project.\nExport Parts List"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_part_list",
        "href": "examples/gallery_examples/03-exporting/export_part_list.html#connect-to-sherlock",
        "title": "Export Parts List > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_part_list",
        "href": "examples/gallery_examples/03-exporting/export_part_list.html#delete-project",
        "title": "Export Parts List > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_part_list",
        "href": "examples/gallery_examples/03-exporting/export_part_list.html#import-tutorial-project",
        "title": "Export Parts List > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_part_list",
        "href": "examples/gallery_examples/03-exporting/export_part_list.html#export-parts-list",
        "title": "Export Parts List",
        "section": "Export Parts List",
        "text": "Export the parts list from the imported project.\nDownload Jupyter notebook: export_part_list.ipynb\nDownload Python source code: export_part_list.py\nDownload zipped: export_part_list.zip\nExport Parts List\nDownload Jupyter notebook: export_part_list.ipynb\nDownload Python source code: export_part_list.py\nDownload zipped: export_part_list.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PottingRegionCopyData.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionUpdateData.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PolygonalShape.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.html#ansyssherlockcorelayerlayer",
        "title": "ansys.sherlock.core.layer.Layer",
        "section": "ansys.sherlock.core.layer.Layer",
        "text": "Module containing all the layer management capabilities.\nLayer.add_modeling_region(project, ...)\nAdd one or more modeling regions to a specific project.\nLayer.add_potting_region(project, ...)\nAdd one or more potting regions to a given project.\nLayer.copy_modeling_region(project, copy_regions)\nCopy one or more modeling regions in a specific project.\nLayer.copy_potting_region(request)\nCopy one or more potting regions in a specific project.\nLayer.delete_all_ict_fixtures(project, cca_name)\nDelete all ICT fixtures for a CCA.\nLayer.delete_all_mount_points(project, cca_name)\nDelete all mount points for a CCA.\nLayer.delete_all_test_points(project, cca_name)\nDelete all test points for a CCA.\nLayer.delete_modeling_region(project, ...)\nDelete one or more modeling regions for a specific project.\nLayer.delete_potting_region(request)\nDelete on or more potting regions in a specific project.\nLayer.export_all_mount_points(project, ...)\nExport the mount point properties for a CCA.\nLayer.export_all_test_fixtures(project, ...)\nExport the test fixture properties for a CCA.\nLayer.export_all_test_points(project, ...[, ...])\nExport the test point properties for a CCA.\nLayer.export_layer_image(project, cca_name, ...)\nExport one or more 2D Layer Viewer images from a project CCA.\nLayer.list_layers(project, cca_name)\nList all layers as seen in the Layer Viewer for a specific project CCA.\nLayer.update_modeling_region(project, ...)\nUpdate one or more modeling regions in a specific project.\nLayer.update_mount_points_by_file(project, ...)\nUpdate mount point properties of a CCA from a CSV file.\nLayer.update_potting_region(request)\nUpdate one or more potting regions in a specific project.\nLayer.update_test_fixtures_by_file(project, ...)\nUpdate test fixture properties of a CCA from a CSV file.\nLayer.update_test_points_by_file(project, ...)\nUpdate test point properties of a CCA from a CSV file.\nansys.sherlock.core.layer.Layer\nLayer.add_modeling_region\nLayer.add_potting_region\nLayer.copy_modeling_region\nLayer.copy_potting_region\nLayer.delete_all_ict_fixtures\nLayer.delete_all_mount_points\nLayer.delete_all_test_points\nLayer.delete_modeling_region\nLayer.delete_potting_region\nLayer.export_all_mount_points\nLayer.export_all_test_fixtures\nLayer.export_all_test_points\nLayer.export_layer_image\nLayer.list_layers\nLayer.update_modeling_region\nLayer.update_mount_points_by_file\nLayer.update_potting_region\nLayer.update_test_fixtures_by_file\nLayer.update_test_points_by_file"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.html#ansys.sherlock.core.layer.Layer",
        "title": "ansys.sherlock.core.layer.Layer > ansys.sherlock.core.layer.Layer > Layer",
        "section": "ansys.sherlock.core.layer.Layer > Layer",
        "text": "class ansys.sherlock.core.layer.Layer(channel, server_version)\n\nModule containing all the layer management capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLayer.add_modeling_region(project, ...)\n\nAdd one or more modeling regions to a specific project.\n\nLayer.add_potting_region(project, ...)\n\nAdd one or more potting regions to a given project.\n\nLayer.copy_modeling_region(project, copy_regions)\n\nCopy one or more modeling regions in a specific project.\n\nLayer.copy_potting_region(request)\n\nCopy one or more potting regions in a specific project.\n\nLayer.delete_all_ict_fixtures(project, cca_name)\n\nDelete all ICT fixtures for a CCA.\n\nLayer.delete_all_mount_points(project, cca_name)\n\nDelete all mount points for a CCA.\n\nLayer.delete_all_test_points(project, cca_name)\n\nDelete all test points for a CCA.\n\nLayer.delete_modeling_region(project, ...)\n\nDelete one or more modeling regions for a specific project.\n\nLayer.delete_potting_region(request)\n\nDelete on or more potting regions in a specific project.\n\nLayer.export_all_mount_points(project, ...)\n\nExport the mount point properties for a CCA.\n\nLayer.export_all_test_fixtures(project, ...)\n\nExport the test fixture properties for a CCA.\n\nLayer.export_all_test_points(project, ...[, ...])\n\nExport the test point properties for a CCA.\n\nLayer.export_layer_image(project, cca_name, ...)\n\nExport one or more 2D Layer Viewer images from a project CCA.\n\nLayer.list_layers(project, cca_name)\n\nList all layers as seen in the Layer Viewer for a specific project CCA.\n\nLayer.update_modeling_region(project, ...)\n\nUpdate one or more modeling regions in a specific project.\n\nLayer.update_mount_points_by_file(project, ...)\n\nUpdate mount point properties of a CCA from a CSV file.\n\nLayer.update_potting_region(request)\n\nUpdate one or more potting regions in a specific project.\n\nLayer.update_test_fixtures_by_file(project, ...)\n\nUpdate test fixture properties of a CCA from a CSV file.\n\nLayer.update_test_points_by_file(project, ...)\n\nUpdate test point properties of a CCA from a CSV file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.html#ansyssherlockcoreanalysisanalysis",
        "title": "ansys.sherlock.core.analysis.Analysis",
        "section": "ansys.sherlock.core.analysis.Analysis",
        "text": "Contains all analysis capabilities.\nAnalysis.get_harmonic_vibe_input_fields([...])\nGet harmonic vibe property fields based on the user configuration.\nAnalysis.get_ict_analysis_input_fields()\nGet ICT analysis property fields based on the user configuration.\nAnalysis.get_mechanical_shock_input_fields([...])\nGet mechanical shock property fields based on the user configuration.\nAnalysis.get_natural_frequency_input_fields()\nGet natural frequency property fields based on the user configuration.\nAnalysis.get_parts_list_validation_analysis_props(...)\nGet properties for a Part List Validation analysis.\nAnalysis.get_random_vibe_input_fields([...])\nGet random vibe property fields based on the user configuration.\nAnalysis.get_solder_fatigue_input_fields()\nGet solder fatigue property fields based on the user configuration.\nAnalysis.run_analysis(project, cca_name, ...)\nRun one or more Sherlock analyses.\nAnalysis.run_strain_map_analysis(project, ...)\nRun one or more strain map analyses.\nAnalysis.update_PTH_fatigue_props(request)\nUpdate properties for one or more Plated Through Hole (PTH) Fatigue Analyses.\nAnalysis.update_component_failure_mechanism_analysis_props(request)\nUpdate properties for one or more Component Failure Mechanism analysis.\nAnalysis.update_harmonic_vibe_props(project, ...)\nUpdate properties for a harmonic vibe analysis.\nAnalysis.update_ict_analysis_props(project, ...)\nUpdate properties for an ICT analysis.\nAnalysis.update_mechanical_shock_props(...)\nUpdate properties for a mechanical shock analysis.\nAnalysis.update_natural_frequency_props(...)\nUpdate properties for a natural frequency analysis.\nAnalysis.update_part_list_validation_analysis_props(...)\nUpdate properties for a Part List Validation analysis.\nAnalysis.update_part_modeling_props(project, ...)\nUpdate part modeling properties for a given project's CCA.\nAnalysis.update_pcb_modeling_props(project, ...)\nUpdate FEA PCB Modeling properties for one or more CCAs.\nAnalysis.update_random_vibe_props(project, ...)\nUpdate properties for a random vibe analysis.\nAnalysis.update_semiconductor_wearout_props(request)\nUpdate properties for one or more Semiconductor Wearout Analysis.\nAnalysis.update_solder_fatigue_props(...)\nUpdate properties for a solder fatigue analysis.\nansys.sherlock.core.analysis.Analysis\nAnalysis.get_harmonic_vibe_input_fields\nAnalysis.get_ict_analysis_input_fields\nAnalysis.get_mechanical_shock_input_fields\nAnalysis.get_natural_frequency_input_fields\nAnalysis.get_parts_list_validation_analysis_props\nAnalysis.get_random_vibe_input_fields\nAnalysis.get_solder_fatigue_input_fields\nAnalysis.run_analysis\nAnalysis.run_strain_map_analysis\nAnalysis.update_PTH_fatigue_props\nAnalysis.update_component_failure_mechanism_analysis_props\nAnalysis.update_harmonic_vibe_props\nAnalysis.update_ict_analysis_props\nAnalysis.update_mechanical_shock_props\nAnalysis.update_natural_frequency_props\nAnalysis.update_part_list_validation_analysis_props\nAnalysis.update_part_modeling_props\nAnalysis.update_pcb_modeling_props\nAnalysis.update_random_vibe_props\nAnalysis.update_semiconductor_wearout_props\nAnalysis.update_solder_fatigue_props"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.html#ansys.sherlock.core.analysis.Analysis",
        "title": "ansys.sherlock.core.analysis.Analysis > ansys.sherlock.core.analysis.Analysis > Analysis",
        "section": "ansys.sherlock.core.analysis.Analysis > Analysis",
        "text": "class ansys.sherlock.core.analysis.Analysis(channel, server_version)\n\nContains all analysis capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nAnalysis.get_harmonic_vibe_input_fields([...])\n\nGet harmonic vibe property fields based on the user configuration.\n\nAnalysis.get_ict_analysis_input_fields()\n\nGet ICT analysis property fields based on the user configuration.\n\nAnalysis.get_mechanical_shock_input_fields([...])\n\nGet mechanical shock property fields based on the user configuration.\n\nAnalysis.get_natural_frequency_input_fields()\n\nGet natural frequency property fields based on the user configuration.\n\nAnalysis.get_parts_list_validation_analysis_props(...)\n\nGet properties for a Part List Validation analysis.\n\nAnalysis.get_random_vibe_input_fields([...])\n\nGet random vibe property fields based on the user configuration.\n\nAnalysis.get_solder_fatigue_input_fields()\n\nGet solder fatigue property fields based on the user configuration.\n\nAnalysis.run_analysis(project, cca_name, ...)\n\nRun one or more Sherlock analyses.\n\nAnalysis.run_strain_map_analysis(project, ...)\n\nRun one or more strain map analyses.\n\nAnalysis.update_PTH_fatigue_props(request)\n\nUpdate properties for one or more Plated Through Hole (PTH) Fatigue Analyses.\n\nAnalysis.update_component_failure_mechanism_analysis_props(request)\n\nUpdate properties for one or more Component Failure Mechanism analysis.\n\nAnalysis.update_harmonic_vibe_props(project, ...)\n\nUpdate properties for a harmonic vibe analysis.\n\nAnalysis.update_ict_analysis_props(project, ...)\n\nUpdate properties for an ICT analysis.\n\nAnalysis.update_mechanical_shock_props(...)\n\nUpdate properties for a mechanical shock analysis.\n\nAnalysis.update_natural_frequency_props(...)\n\nUpdate properties for a natural frequency analysis.\n\nAnalysis.update_part_list_validation_analysis_props(...)\n\nUpdate properties for a Part List Validation analysis.\n\nAnalysis.update_part_modeling_props(project, ...)\n\nUpdate part modeling properties for a given project's CCA.\n\nAnalysis.update_pcb_modeling_props(project, ...)\n\nUpdate FEA PCB Modeling properties for one or more CCAs.\n\nAnalysis.update_random_vibe_props(project, ...)\n\nUpdate properties for a random vibe analysis.\n\nAnalysis.update_semiconductor_wearout_props(request)\n\nUpdate properties for one or more Semiconductor Wearout Analysis.\n\nAnalysis.update_solder_fatigue_props(...)\n\nUpdate properties for a solder fatigue analysis.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x.html#center_x",
        "title": "center_x",
        "section": "center_x",
        "text": "float\nx coordinate of center\ncenter_x\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_x.html#ansys.sherlock.core.types.layer_types.CircularShape.center_x",
        "title": "center_x > center_x > center_x",
        "section": "center_x > center_x",
        "text": "CircularShape.center_x: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nx coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw.html#ansys.sherlock.core.types.layer_types.PolygonalShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PolygonalShape.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.location_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.location_units.html#location_units",
        "title": "location_units",
        "section": "location_units",
        "text": "Units for location values\nlocation_units\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.location_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.location_units.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.location_units",
        "title": "location_units > location_units > location_units",
        "section": "location_units > location_units",
        "text": "CsvExcelOutlineFile.location_units: str\n\nUnits for location values\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionDeleteData.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "CsvExcelOutlineFile.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionUpdateData.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name.html#cca_name",
        "title": "cca_name",
        "section": "cca_name",
        "text": "Name of the cca.\ncca_name\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.cca_name",
        "title": "cca_name > cca_name > cca_name",
        "section": "cca_name > cca_name",
        "text": "PottingRegionCopyData.cca_name: str\n\nName of the cca.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/sg_execution_times",
        "href": "examples/gallery_examples/02-importing/sg_execution_times.html#computation-times",
        "title": "Computation times",
        "section": "Computation times",
        "text": "00:00.000 total execution time for 5 files from examplesgallery_examples02-importing:\nExample\nTime\nMem (MB)\nsphx_glr_examples_gallery_examples_02-importing_import_ipc_2581_archive.py (import_ipc_2581_archive.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_odb_archive.py (import_odb_archive.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_parts_list.py (import_parts_list.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_archive_single_mode.py (import_project_zip_archive_single_mode.py)\n00:00.000\n0.0\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_file.py (import_project_zip_file.py)\n00:00.000\n0.0\nComputation times\nimport_ipc_2581_archive.py\nimport_odb_archive.py\nimport_parts_list.py\nimport_project_zip_archive_single_mode.py\nimport_project_zip_file.py"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PottingRegionUpdateData.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump.html#ansys.sherlock.core.types.layer_types.SlotShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "SlotShape.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "UpdatePottingRegionRequest.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod DeletePottingRegionRequest.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegion.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_obj.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod CsvExcelOutlineFile.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature.html#min_temperature",
        "title": "min_temperature",
        "section": "min_temperature",
        "text": "min_temperature\nfloat\nmin_temperature"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.min_temperature.html#ansys.sherlock.core.types.project_types.ImageFile.min_temperature",
        "title": "min_temperature > min_temperature > min_temperature",
        "section": "min_temperature > min_temperature",
        "text": "ImageFile.min_temperature\n\nmin_temperature\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "CopyPottingRegionRequest.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.str_validation.html#ansys.sherlock.core.types.project_types.OutlineFile.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod OutlineFile.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props.html#update_natural_frequency_props",
        "title": "update_natural_frequency_props",
        "section": "update_natural_frequency_props",
        "text": "Update properties for a natural frequency analysis.\nAvailable Since:2023R2\nName of the Sherlock project.\nName of the CCA.\nNatural frequency result count.\nMinimum frequency. This parameter is for NX Nastran analysis only.\nMinimum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nMaximum frequency. This parameter is for NX Nastran analysis only.\nMaximum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\nWhether part validation is enabled.\nWhether to require material assignment.\nTemperature.\nTemperature units. Options are \"C\", \"F\", and \"K\".\nStatus code of the response. 0 for success.\nint\nupdate_natural_frequency_props\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"C\"\n\"F\"\n\"K\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props.html#ansys.sherlock.core.analysis.Analysis.update_natural_frequency_props",
        "title": "update_natural_frequency_props > update_natural_frequency_props > update_natural_frequency_props",
        "section": "update_natural_frequency_props > update_natural_frequency_props",
        "text": "Analysis.update_natural_frequency_props(project, cca_name, natural_freq_count, natural_freq_min, natural_freq_min_units, natural_freq_max, natural_freq_max_units, part_validation_enabled, require_material_assignment_enabled, analysis_temp=None, analysis_temp_units=None)\n\nUpdate properties for a natural frequency analysis.\n\nAvailable Since:2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nnatural_freq_count: int\n\nNatural frequency result count.\n\nnatural_freq_min: int, optional\n\nMinimum frequency. This parameter is for NX Nastran analysis only.\n\nnatural_freq_min_units: str, optional\n\nMinimum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\nnatural_freq_max: int, optional\n\nMaximum frequency. This parameter is for NX Nastran analysis only.\n\nnatural_freq_max_units: str, optional\n\nMaximum frequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nThis parameter is for NX Nastran analysis only.\n\npart_validation_enabled: bool\n\nWhether part validation is enabled.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment.\n\nanalysis_temp: float, optional\n\nTemperature.\n\nanalysis_temp_units: str, optional\n\nTemperature units. Options are \"C\", \"F\", and \"K\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\"\n>>> )\n>>> sherlock.analysis.update_natural_frequency_props(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     natural_freq_count=2,\n>>>     natural_freq_min=10,\n>>>     natural_freq_min_units=\"HZ\",\n>>>     natural_freq_max=100,\n>>>     natural_freq_max_units=\"HZ\",\n>>>     part_validation_enabled=True,\n>>>     require_material_assignment_enabled=False,\n>>>     analysis_temp=25,\n>>>     analysis_temp_units=\"C\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod UpdatePottingRegionRequest.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff.html#potting_standoff",
        "title": "potting_standoff",
        "section": "potting_standoff",
        "text": "The potting standoff.\npotting_standoff\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_standoff",
        "title": "potting_standoff > potting_standoff > potting_standoff",
        "section": "potting_standoff > potting_standoff",
        "text": "PottingRegion.potting_standoff: float\n\nThe potting standoff.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.json.html#ansys.sherlock.core.types.layer_types.RectangularShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "RectangularShape.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PolygonalShape.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_copy.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PottingRegion.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.json.html#ansys.sherlock.core.types.project_types.OutlineFile.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "OutlineFile.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod CopyPottingRegionRequest.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod PottingRegionCopyData.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#add-and-update-potting-regions",
        "title": "Add and Update Potting Regions",
        "section": "Add and Update Potting Regions",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nadd potting regions, update existing potting regions, and properly close the connection.\nAdd and Update Potting Regions"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#description",
        "title": "Add and Update Potting Regions > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as adding and updating potting\nregions for CCAs.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Add a potting region.\n- Update an existing potting region.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#connect-to-sherlock",
        "title": "Add and Update Potting Regions > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#delete-project",
        "title": "Add and Update Potting Regions > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#import-tutorial-project",
        "title": "Add and Update Potting Regions > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#add-potting-region",
        "title": "Add and Update Potting Regions > Add Potting Region",
        "section": "Add Potting Region",
        "text": "Add a new potting region to a CCA.\nAdd Potting Region"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_potting_region",
        "href": "examples/gallery_examples/01-project-configuration/update_potting_region.html#update-potting-region",
        "title": "Add and Update Potting Regions > Update Potting Region",
        "section": "Update Potting Region",
        "text": "Update an existing potting region.\nDownload Jupyter notebook: update_potting_region.ipynb\nDownload Python source code: update_potting_region.py\nDownload zipped: update_potting_region.zip\nUpdate Potting Region\nDownload Jupyter notebook: update_potting_region.ipynb\nDownload Python source code: update_potting_region.py\nDownload zipped: update_potting_region.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers.html#list_conductor_layers",
        "title": "list_conductor_layers",
        "section": "list_conductor_layers",
        "text": "List CCA conductor layers.\nAvailable Since: 2021R2\nName of the Sherlock project.\nThe conductor layers of all CCAs in the project.\nlist[CCAConductorLayerProp]\nlist_conductor_layers\npython:list\nSherlockStackupService_pb2.ListConductorLayersResponse.CCAConductorLayerProp\nlist\nCCAConductorLayerProp"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_conductor_layers.html#ansys.sherlock.core.stackup.Stackup.list_conductor_layers",
        "title": "list_conductor_layers > list_conductor_layers > list_conductor_layers",
        "section": "list_conductor_layers > list_conductor_layers",
        "text": "Stackup.list_conductor_layers(project)\n\nList CCA conductor layers.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockStackupService_pb2.ListConductorLayersResponse.CCAConductorLayerProp]\n\nThe conductor layers of all CCAs in the project.\n\nReturn type\n\nlist[CCAConductorLayerProp]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> conductorLayers = sherlock.stackup.list_conductor_layers(project=\"Tutorial\")\n>>> for layer in conductorLayers:\n>>>     properties = layer.conductorLayerProps\n>>>     for prop in properties:\n>>>     print(f\"{prop}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "DeletePottingRegionRequest.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_obj.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod GerberOutlineFile.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file.html#update_test_points_by_file",
        "title": "update_test_points_by_file",
        "section": "update_test_points_by_file",
        "text": "Update test point properties of a CCA from a CSV file.\nAvailable Since: 2023R1\nName of the Sherlock project.\nName of the CCA.\nPath for the CSV file with the test point properties.\nStatus code of the response. 0 for success.\nint\nupdate_test_points_by_file\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_test_points_by_file.html#ansys.sherlock.core.layer.Layer.update_test_points_by_file",
        "title": "update_test_points_by_file > update_test_points_by_file > update_test_points_by_file",
        "section": "update_test_points_by_file > update_test_points_by_file",
        "text": "Layer.update_test_points_by_file(project, cca_name, file_path)\n\nUpdate test point properties of a CCA from a CSV file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nfile_path: str\n\nPath for the CSV file with the test point properties.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Test\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> sherlock.layer.update_test_points_by_file(\n>>>     \"Test\",\n>>>     \"Card\",\n>>>     \"TestPointsImport.csv\"\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "PottingRegionDeleteData.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_json_schema.html#ansys.sherlock.core.types.project_types.OutlineFile.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod OutlineFile.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.validate.html#ansys.sherlock.core.types.layer_types.SlotShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod SlotShape.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.SlotShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod SlotShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles.html#add_shock_profiles",
        "title": "add_shock_profiles",
        "section": "add_shock_profiles",
        "text": "Add shock profiles to a life cycle phase.\nAvailable Since: 2023R2\nName of the Sherlock project\nShock profiles consisting of these properties:\nName of the life cycle phase to add the shock profile to.\nName of the shock event.\nName of the shock profile.\nPulse duration.\nPulse duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nSample rate.\nSample rate units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nLoad units. Options are: \"G\", \"m/s2\", \"mm/s2\", \"in/s2\",\nand \"ft/s2\".\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\nShock profile entries consisting of these properties:\nShape of the shock profile entry. Options are \"FullSine\",\n\"HalfSine\", \"Haversine\", \"Triangle\", \"Sawtooth\",\n\"FullSquare\", and \"HalfSquare\".\nLoad of the profile entry expressed in load units.\nFrequency of the profile entry expressed in frequency units.\nDecay value of the profile entry.\nStatus code of the response. 0 for success.\nint\nadd_shock_profiles\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"G\"\n\"m/s2\"\n\"mm/s2\"\n\"in/s2\"\n\"ft/s2\"\n\"HZ\"\n\"KHZ\"\n\"MHZ\"\n\"GHZ\"\n\"FullSine\"\n\"HalfSine\"\n\"Haversine\"\n\"Triangle\"\n\"Sawtooth\"\n\"FullSquare\"\n\"HalfSquare\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_shock_profiles",
        "title": "add_shock_profiles > add_shock_profiles > add_shock_profiles",
        "section": "add_shock_profiles > add_shock_profiles",
        "text": "Lifecycle.add_shock_profiles(project, shock_profiles)\n\nAdd shock profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nshock_profiles: list\n\nShock profiles consisting of these properties:\n\nphase_name: str\n\nName of the life cycle phase to add the shock profile to.\n\nevent_name: str\n\nName of the shock event.\n\nprofile_name: str\n\nName of the shock profile.\n\nduration: float\n\nPulse duration.\n\nduration_units: str\n\nPulse duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nsample_rate: float\n\nSample rate.\n\nsample_rate_units: str\n\nSample rate units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nload_units: str\n\nLoad units. Options are: \"G\", \"m/s2\", \"mm/s2\", \"in/s2\",\nand \"ft/s2\".\n\nfreq_units: str\n\nFrequency units. Options are \"HZ\", \"KHZ\", \"MHZ\", and \"GHZ\".\n\nshock_profile_entries: list\n\nShock profile entries consisting of these properties:\n\nshape: str\n\nShape of the shock profile entry. Options are \"FullSine\",\n\"HalfSine\", \"Haversine\", \"Triangle\", \"Sawtooth\",\n\"FullSquare\", and \"HalfSquare\".\n\nload: float\n\nLoad of the profile entry expressed in load units.\n\nfreq: float\n\nFrequency of the profile entry expressed in frequency units.\n\ndecay: float\n\nDecay value of the profile entry.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_shock_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"2,4,5\",\n)\n>>> sherlock.lifecycle.add_shock_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        10.0, \"ms\",\n        0.1, \"ms\",\n        \"G\",\n        \"HZ\",\n        [(\"HalfSine\", 100.0, 100.0, 0)],\n    )]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region.html#update_modeling_region",
        "title": "update_modeling_region",
        "section": "update_modeling_region",
        "text": "Update one or more modeling regions in a specific project.\nName of the Sherlock project.\nModeling regions to update. Each dictionary should contain:\nName of the CCA.\nUnique region ID of the modeling region.\nUnits of the modeling region.\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\nThe shape of the modeling region.\nPCB model parameters consisting of these properties:\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum size of the mesh to be used in the region.\nUnits for the maximum mesh size.\nWhether to generate quad-shaped elements when creating the mesh if true.\nTrace model parameters consisting of these properties:\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\nUnits for the maximum mesh size when trace modeling is enabled.\nRepresents a unique region id that will replace the existing regionId value during\na modeling region update if a value exists.\nStatus code of the response. 0 for success.\nint\nupdate_modeling_region\npython:list\npython:dict\nEnabled\nDisabled\nExcluded\nDefault\nSherlock\nSweep\nNone\nFirst_Order\nSecond_Order\nSolid_Shell\nDefault\nEnabled\nDisabled\nFirst_Order\nSecond_Order\nSolid_Shell\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.update_modeling_region.html#ansys.sherlock.core.layer.Layer.update_modeling_region",
        "title": "update_modeling_region > update_modeling_region > update_modeling_region",
        "section": "update_modeling_region > update_modeling_region",
        "text": "Layer.update_modeling_region(project, modeling_regions)\n\nUpdate one or more modeling regions in a specific project.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nmodeling_regions\n\npython:list[python:dict]\n\nModeling regions to update. Each dictionary should contain:\n\ncca_name: str\n\nName of the CCA.\n\nregion_id: str\n\nUnique region ID of the modeling region.\n\nregion_units: str\n\nUnits of the modeling region.\n\nmodel_mode: str\n\nMode that specifies how the region is used. Valid values are Enabled,\nDisabled and Excluded.\n\nshape: PolygonalShape|RectangularShape|SlotShape|CircularShape|PCBShape\n\nThe shape of the modeling region.\n\npcb_model_props: dict[str, bool | float | str]\n\nPCB model parameters consisting of these properties:\n\nexport_model_type: str\n\nThe type of model to be generated for a given modeling region.\nValid values are Default, Sherlock, Sweep and None.\n\nelem_order: str\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\nmax_mesh_size: float\n\nThe maximum size of the mesh to be used in the region.\n\nmax_mesh_size_units: str\n\nUnits for the maximum mesh size.\n\nquads_preferred: bool\n\nWhether to generate quad-shaped elements when creating the mesh if true.\n\ntrace_model_props: dict[str, float | str]\n\nTrace model parameters consisting of these properties:\n\ntrace_model_type: str\n\nThe specification of whether trace modeling should be performed\nwithin the region. Valid values are Default, Enabled and\nDisabled.\n\nelem_order: str, optional\n\nThe type of 3D elements to be created for the PCB in the modeling region.\nValid values are First_Order, Second_Order and Solid_Shell.\n\ntrace_mesh_size: float, optional\n\nThe maximum mesh size to be used in the region when trace modeling\nis enabled.\n\ntrace_mesh_size_units: str, optional\n\nUnits for the maximum mesh size when trace modeling is enabled.\n\nregion_id_replacement: str, optional\n\nRepresents a unique region id that will replace the existing regionId value during\na modeling region update if a value exists.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> modeling_regions = [\n>>>     {\n>>>         \"cca_name\": \"Card\",\n>>>         \"region_id\": \"Region001\",\n>>>         \"region_units\": \"mm\",\n>>>         \"model_mode\": \"Enabled\",\n>>>         \"shape\": PolygonalShape(points=[(0, 0), (1, 1)], rotation=0),\n>>>         \"pcb_model_props\": {\n>>>             \"export_model_type\": \"Sherlock\",\n>>>             \"elem_order\": \"Second_Order\",\n>>>             \"max_mesh_size\": 0.5,\n>>>             \"max_mesh_size_units\": \"mm\",\n>>>             \"quads_preferred\": True,\n>>>         },\n>>>         \"trace_model_props\": {\n>>>             \"trace_model_type\": \"Enabled\",\n>>>             \"elem_order\": \"Second_Order\",\n>>>             \"trace_mesh_size\": 0.1,\n>>>             \"trace_mesh_size_units\": \"mm\",\n>>>         },\n>>>         \"region_id_replacement\": \"NewRegion001\",\n>>>     }\n>>> ]\n>>> result = sherlock.layer.update_modeling_region(\"Tutorial Project\", modeling_regions)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id.html#potting_id",
        "title": "potting_id",
        "section": "potting_id",
        "text": "Id to assign to the new potting region.\npotting_id\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.potting_id",
        "title": "potting_id > potting_id > potting_id",
        "section": "potting_id > potting_id",
        "text": "PottingRegionCopyData.potting_id: str\n\nId to assign to the new potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate_strings.html#ansys.sherlock.core.types.project_types.OutlineFile.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod OutlineFile.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.html#ansyssherlockcoretypeslayer_typespolygonalshape",
        "title": "ansys.sherlock.core.types.layer_types.PolygonalShape",
        "section": "ansys.sherlock.core.types.layer_types.PolygonalShape",
        "text": "Contains the properties for a polygonal shape.\nPolygonalShape.construct([_fields_set])\n\nPolygonalShape.copy(*[, include, exclude, ...])\nReturns a copy of the model.\nPolygonalShape.dict(*[, include, exclude, ...])\n\nPolygonalShape.from_orm(obj)\n\nPolygonalShape.json(*[, include, exclude, ...])\n\nPolygonalShape.model_construct([_fields_set])\nCreates a new instance of the Model class with validated data.\nPolygonalShape.model_copy(*[, update, deep])\n!!! abstract \"Usage Documentation\"\nPolygonalShape.model_dump(*[, mode, ...])\n!!! abstract \"Usage Documentation\"\nPolygonalShape.model_dump_json(*[, indent, ...])\n!!! abstract \"Usage Documentation\"\nPolygonalShape.model_json_schema([by_alias, ...])\nGenerates a JSON schema for a model class.\nPolygonalShape.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nPolygonalShape.model_post_init(context, /)\nOverride this method to perform additional initialization after __init__ and model_construct.\nPolygonalShape.model_rebuild(*[, force, ...])\nTry to rebuild the pydantic-core schema for the model.\nPolygonalShape.model_validate(obj, *[, ...])\nValidate a pydantic model instance.\nPolygonalShape.model_validate_json(json_data, *)\n!!! abstract \"Usage Documentation\"\nPolygonalShape.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nPolygonalShape.parse_file(path, *[, ...])\n\nPolygonalShape.parse_obj(obj)\n\nPolygonalShape.parse_raw(b, *[, ...])\n\nPolygonalShape.schema([by_alias, ref_template])\n\nPolygonalShape.schema_json(*[, by_alias, ...])\n\nPolygonalShape.update_forward_refs(**localns)\n\nPolygonalShape.validate(value)\n\nPolygonalShape.model_computed_fields\n\nPolygonalShape.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nPolygonalShape.model_extra\nGet extra fields set during validation.\nPolygonalShape.model_fields\n\nPolygonalShape.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nPolygonalShape.points\nlist[tuple[float, float]]\nPolygonalShape.rotation\nfloat\nansys.sherlock.core.types.layer_types.PolygonalShape\nPolygonalShape.construct\nPolygonalShape.copy\nPolygonalShape.dict\nPolygonalShape.from_orm\nPolygonalShape.json\nPolygonalShape.model_construct\nPolygonalShape.model_copy\nPolygonalShape.model_dump\nPolygonalShape.model_dump_json\nPolygonalShape.model_json_schema\nPolygonalShape.model_parametrized_name\nPolygonalShape.model_post_init\nPolygonalShape.model_rebuild\nPolygonalShape.model_validate\nPolygonalShape.model_validate_json\nPolygonalShape.model_validate_strings\nPolygonalShape.parse_file\nPolygonalShape.parse_obj\nPolygonalShape.parse_raw\nPolygonalShape.schema\nPolygonalShape.schema_json\nPolygonalShape.update_forward_refs\nPolygonalShape.validate\nPolygonalShape.model_computed_fields\nPolygonalShape.model_config\nPolygonalShape.model_extra\nPolygonalShape.model_fields\nPolygonalShape.model_fields_set\nPolygonalShape.points\nPolygonalShape.rotation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.html#ansys.sherlock.core.types.layer_types.PolygonalShape",
        "title": "ansys.sherlock.core.types.layer_types.PolygonalShape > ansys.sherlock.core.types.layer_types.PolygonalShape > PolygonalShape",
        "section": "ansys.sherlock.core.types.layer_types.PolygonalShape > PolygonalShape",
        "text": "class ansys.sherlock.core.types.layer_types.PolygonalShape(**data)\n\nContains the properties for a polygonal shape.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nPolygonalShape.construct([_fields_set])\n\n\n\nPolygonalShape.copy(*[, include, exclude, ...])\n\nReturns a copy of the model.\n\nPolygonalShape.dict(*[, include, exclude, ...])\n\n\n\nPolygonalShape.from_orm(obj)\n\n\n\nPolygonalShape.json(*[, include, exclude, ...])\n\n\n\nPolygonalShape.model_construct([_fields_set])\n\nCreates a new instance of the Model class with validated data.\n\nPolygonalShape.model_copy(*[, update, deep])\n\n!!! abstract \"Usage Documentation\"\n\nPolygonalShape.model_dump(*[, mode, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPolygonalShape.model_dump_json(*[, indent, ...])\n\n!!! abstract \"Usage Documentation\"\n\nPolygonalShape.model_json_schema([by_alias, ...])\n\nGenerates a JSON schema for a model class.\n\nPolygonalShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nPolygonalShape.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nPolygonalShape.model_rebuild(*[, force, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nPolygonalShape.model_validate(obj, *[, ...])\n\nValidate a pydantic model instance.\n\nPolygonalShape.model_validate_json(json_data, *)\n\n!!! abstract \"Usage Documentation\"\n\nPolygonalShape.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nPolygonalShape.parse_file(path, *[, ...])\n\n\n\nPolygonalShape.parse_obj(obj)\n\n\n\nPolygonalShape.parse_raw(b, *[, ...])\n\n\n\nPolygonalShape.schema([by_alias, ref_template])\n\n\n\nPolygonalShape.schema_json(*[, by_alias, ...])\n\n\n\nPolygonalShape.update_forward_refs(**localns)\n\n\n\nPolygonalShape.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nPolygonalShape.model_computed_fields\n\n\n\nPolygonalShape.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nPolygonalShape.model_extra\n\nGet extra fields set during validation.\n\nPolygonalShape.model_fields\n\n\n\nPolygonalShape.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nPolygonalShape.points\n\nlist[tuple[float, float]]\n\nPolygonalShape.rotation\n\nfloat\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionDeleteData.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_json_schema.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod CsvExcelOutlineFile.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_config.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "CsvExcelOutlineFile.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model.html#export_fea_model",
        "title": "export_FEA_model",
        "section": "export_FEA_model",
        "text": "Export a FEA model.\nName of the Sherlock project.\nName of the CCA.\nFull path for saving exported files to. The file extension must be .wbjn.\nThe type of analysis that is being exported. Valid values are NaturalFreq,\nHarmonicVibe, ICTAnalysis, MechanicalShock or RandomVibe.\nList of the drill hole parameters consisting of these properties:\nThe status of the drill hole modeling feature. If enabled, automatically enable\ndrill hole modeling. Valid values are ENABLED/enabled or\nDISABLED/disabled.\nThe properties of the minimum hole diameter.\nThe properties of the maximum edge length.\nThe status of the detect lead modeling feature. If enabled, automatically enable lead\nmodeling if any part has lead geometry defined. Valid values are ENABLED or\nDISABLED.\nList of the lead model parameters consisting of these properties:\nThe status of the lead modeling feature. If enabled, automatically enable lead\nmodeling. Valid values are ENABLED or DISABLED.\nThe type of the element order. Valid values are First Order (Linear),\nSecond Order (Quadratic), or Solid Shell.\nThe properties of the maximum mesh size.\nThe properties of the vertical mesh size.\nThe default value is 3 and the maximum is 5. Only used when the advanced lead\nmesh setting is enabled.\nThe aspect ratio is multiplied by the lead thickness divided by the through\nthickness count to give the lead element height. The default value is 2 and the\nmaximum is 10. Only used when the advanced lead mesh setting is enabled.\nWhether to display the model after export.\nWhether to clear FEA database before defining model.\nWhether to use FEA model ID.\nUnits of the model coordinates to use when exporting a model.\nStatus code of the response. 0 for success.\nint\nexport_FEA_model\n.wbjn\nNaturalFreq\nHarmonicVibe\nICTAnalysis\nMechanicalShock\nRandomVibe\nENABLED/enabled\nDISABLED/disabled\nENABLED\nDISABLED\nENABLED\nDISABLED\nFirst Order (Linear)\nSecond Order (Quadratic)\nSolid Shell\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_FEA_model.html#ansys.sherlock.core.model.Model.export_FEA_model",
        "title": "export_FEA_model > export_FEA_model > export_FEA_model",
        "section": "export_FEA_model > export_FEA_model",
        "text": "Model.export_FEA_model(project, cca_name, export_file, analysis, drill_hole_parameters, detect_lead_modeling, lead_model_parameters, display_model, clear_FEA_database, use_FEA_model_id, coordinate_units)\n\nExport a FEA model.\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nexport_file: str\n\nFull path for saving exported files to. The file extension must be .wbjn.\n\nanalysis: str\n\nThe type of analysis that is being exported. Valid values are NaturalFreq,\nHarmonicVibe, ICTAnalysis, MechanicalShock or RandomVibe.\n\ndrill_hole_parameters: list[dict[str, str | Measurement]]\n\nList of the drill hole parameters consisting of these properties:\n\ndrill_hole_modeling: str\n\nThe status of the drill hole modeling feature. If enabled, automatically enable\ndrill hole modeling. Valid values are ENABLED/enabled or\nDISABLED/disabled.\n\nmin_hole_diameter: MinHoleDiameter\n\nThe properties of the minimum hole diameter.\n\nmax_edge_length: MaxEdgeLength\n\nThe properties of the maximum edge length.\n\ndetect_lead_modeling: str\n\nThe status of the detect lead modeling feature. If enabled, automatically enable lead\nmodeling if any part has lead geometry defined. Valid values are ENABLED or\nDISABLED.\n\nlead_model_parameters: list[dict[str, int | str | Measurement]]\n\nList of the lead model parameters consisting of these properties:\n\nlead_modeling: str\n\nThe status of the lead modeling feature. If enabled, automatically enable lead\nmodeling. Valid values are ENABLED or DISABLED.\n\nlead_element_order: str\n\nThe type of the element order. Valid values are First Order (Linear),\nSecond Order (Quadratic), or Solid Shell.\n\nmax_mesh_size: MaxMeshSize\n\nThe properties of the maximum mesh size.\n\nvertical_mesh_size: VerticalMeshSize\n\nThe properties of the vertical mesh size.\n\nthicknessCount: int, optional\n\nThe number of elements through the lead thickness that will be created per lead.\n\nThe default value is 3 and the maximum is 5. Only used when the advanced lead\nmesh setting is enabled.\n\naspectRatio: int, optional\n\nThe aspect ratio is multiplied by the lead thickness divided by the through\nthickness count to give the lead element height. The default value is 2 and the\nmaximum is 10. Only used when the advanced lead mesh setting is enabled.\n\ndisplay_model: bool\n\nWhether to display the model after export.\n\nclear_FEA_database: bool\n\nWhether to clear FEA database before defining model.\n\nuse_FEA_model_id: bool\n\nWhether to use FEA model ID.\n\ncoordinate_units: str\n\nUnits of the model coordinates to use when exporting a model.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.common_types import (\n    Measurement,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.model.export_FEA_model(\n        project=\"Test Project\",\n        cca_name=\"Main Board\",\n        export_file=\"C:/Temp/export.wbjn\",\n        analysis=\"NaturalFreq\",\n        drill_hole_parameters=[\n            {\n                \"drill_hole_modeling\": \"ENABLED\",\n                \"min_hole_diameter\": Measurement(value=0.5, unit=\"mm\"),\n                \"max_edge_length\": Measurement(value=1.0, unit=\"mm\")\n            }\n        ],\n        detect_lead_modeling=\"ENABLED\",\n        lead_model_parameters=[\n            {\n                \"lead_modeling\": \"ENABLED\",\n                \"lead_element_order\": \"First Order (Linear)\",\n                \"max_mesh_size\": Measurement(value=0.5, unit=\"mm\"),\n                \"vertical_mesh_size\": Measurement(value=0.1, unit=\"mm\"),\n                \"thicknessCount\": 3,\n                \"aspectRatio\": 2\n            }\n        ],\n        display_model=True,\n        clear_FEA_database=True,\n        use_FEA_model_id=True,\n        coordinate_units=\"mm\"\n    )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common",
        "href": "api/common.html#common",
        "title": "Common",
        "section": "Common",
        "text": "Module for running the gRPC APIs in the Sherlock Common service.\nCommon(channel, server_version)\nContains methods from the Sherlock Common service.\nCommon\nCommon"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.json.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "GerberOutlineFile.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionCopyData.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.html#ansyssherlockcorelifecyclelifecycle",
        "title": "ansys.sherlock.core.lifecycle.Lifecycle",
        "section": "ansys.sherlock.core.lifecycle.Lifecycle",
        "text": "Contains all life cycle management capabilities.\nLifecycle.add_harmonic_event(project, ...[, ...])\nAdd a harmonic event to a life cycle phase.\nLifecycle.add_harmonic_vibe_profiles(...)\nAdd harmonic vibe profiles to a life cycle phase.\nLifecycle.add_random_vibe_event(project, ...)\nAdd a random vibe event to a life cycle phase.\nLifecycle.add_random_vibe_profiles(project, ...)\nAdd random vibe profiles to a life cycle phase.\nLifecycle.add_shock_event(project, ...[, ...])\nAdd a shock event to a life cycle phase.\nLifecycle.add_shock_profiles(project, ...)\nAdd shock profiles to a life cycle phase.\nLifecycle.add_thermal_event(project, ...[, ...])\nAdd a thermal event to a life cycle phase.\nLifecycle.add_thermal_profiles(project, ...)\nAdd thermal profiles to a life cycle phase.\nLifecycle.create_life_phase(project, ...[, ...])\nCreate a life phase.\nLifecycle.load_harmonic_profile(project, ...)\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\nLifecycle.load_random_vibe_profile(project, ...)\nLoad random vibe profile from .csv or .dat file.\nLifecycle.load_shock_profile_dataset(...)\nLoad shock profile dataset from a .csv or .dat file.\nLifecycle.load_shock_profile_pulses(project, ...)\nLoad shock profile pulses from a .csv .dat file.\nLifecycle.load_thermal_profile(project, ...)\nLoad a thermal profile from a .dat or .csv file.\nansys.sherlock.core.lifecycle.Lifecycle\nLifecycle.add_harmonic_event\nLifecycle.add_harmonic_vibe_profiles\nLifecycle.add_random_vibe_event\nLifecycle.add_random_vibe_profiles\nLifecycle.add_shock_event\nLifecycle.add_shock_profiles\nLifecycle.add_thermal_event\nLifecycle.add_thermal_profiles\nLifecycle.create_life_phase\nLifecycle.load_harmonic_profile\nLifecycle.load_random_vibe_profile\nLifecycle.load_shock_profile_dataset\nLifecycle.load_shock_profile_pulses\nLifecycle.load_thermal_profile"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.html#ansys.sherlock.core.lifecycle.Lifecycle",
        "title": "ansys.sherlock.core.lifecycle.Lifecycle > ansys.sherlock.core.lifecycle.Lifecycle > Lifecycle",
        "section": "ansys.sherlock.core.lifecycle.Lifecycle > Lifecycle",
        "text": "class ansys.sherlock.core.lifecycle.Lifecycle(channel, server_version)\n\nContains all life cycle management capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nLifecycle.add_harmonic_event(project, ...[, ...])\n\nAdd a harmonic event to a life cycle phase.\n\nLifecycle.add_harmonic_vibe_profiles(...)\n\nAdd harmonic vibe profiles to a life cycle phase.\n\nLifecycle.add_random_vibe_event(project, ...)\n\nAdd a random vibe event to a life cycle phase.\n\nLifecycle.add_random_vibe_profiles(project, ...)\n\nAdd random vibe profiles to a life cycle phase.\n\nLifecycle.add_shock_event(project, ...[, ...])\n\nAdd a shock event to a life cycle phase.\n\nLifecycle.add_shock_profiles(project, ...)\n\nAdd shock profiles to a life cycle phase.\n\nLifecycle.add_thermal_event(project, ...[, ...])\n\nAdd a thermal event to a life cycle phase.\n\nLifecycle.add_thermal_profiles(project, ...)\n\nAdd thermal profiles to a life cycle phase.\n\nLifecycle.create_life_phase(project, ...[, ...])\n\nCreate a life phase.\n\nLifecycle.load_harmonic_profile(project, ...)\n\nLoad a harmonic profile from a DAT or CSV file to a life cycle phase.\n\nLifecycle.load_random_vibe_profile(project, ...)\n\nLoad random vibe profile from .csv or .dat file.\n\nLifecycle.load_shock_profile_dataset(...)\n\nLoad shock profile dataset from a .csv or .dat file.\n\nLifecycle.load_shock_profile_pulses(project, ...)\n\nLoad shock profile pulses from a .csv .dat file.\n\nLifecycle.load_thermal_profile(project, ...)\n\nLoad a thermal profile from a .dat or .csv file.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event.html#add_thermal_event",
        "title": "add_thermal_event",
        "section": "add_thermal_event",
        "text": "Add a thermal event to a life cycle phase.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the life cycle phase to add the thermal event to.\nName of the thermal event.\nNumber of cycles for the thermal event.\nCycle type. Options are \"COUNT\", \"DUTY CYCLE\", \"PER YEAR\",\n\"PER DAY\", \"PER HOUR\", \"PER MIN\", and \"PER SEC\".\nLife cycle state. Options are \"OPERATING\" and \"STORAGE\".\nDescription of the thermal event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_thermal_event\n\"COUNT\"\n\"DUTY CYCLE\"\n\"PER YEAR\"\n\"PER DAY\"\n\"PER HOUR\"\n\"PER MIN\"\n\"PER SEC\"\n\"OPERATING\"\n\"STORAGE\"\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_event",
        "title": "add_thermal_event > add_thermal_event > add_thermal_event",
        "section": "add_thermal_event > add_thermal_event",
        "text": "Lifecycle.add_thermal_event(project, phase_name, event_name, num_of_cycles, cycle_type, cycle_state, description='')\n\nAdd a thermal event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nphase_name: str\n\nName of the life cycle phase to add the thermal event to.\n\nevent_name: str\n\nName of the thermal event.\n\nnum_of_cycles: float\n\nNumber of cycles for the thermal event.\n\ncycle_type: str\n\nCycle type. Options are \"COUNT\", \"DUTY CYCLE\", \"PER YEAR\",\n\"PER DAY\", \"PER HOUR\", \"PER MIN\", and \"PER SEC\".\n\ncycle_state: str\n\nLife cycle state. Options are \"OPERATING\" and \"STORAGE\".\n\ndescription: str, optional\n\nDescription of the thermal event. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_thermal_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    4.0,\n    \"PER YEAR\",\n    \"STORAGE\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_validate.html#ansys.sherlock.core.types.project_types.OutlineFile.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod OutlineFile.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod UpdatePottingRegionRequest.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod UpdatePottingRegionRequest.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CircularShape.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event.html#add_shock_event",
        "title": "add_shock_event",
        "section": "add_shock_event",
        "text": "Add a shock event to a life cycle phase.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the life cycle phase to add this shock event to.\nName of the shock event.\nEvent duration length.\nEvent duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nNumber of cycles for the shock event.\nCycle type. Options are \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\nDescription of the shock event. The default is \"\".\nStatus code of the response. 0 for success.\nint\nadd_shock_event\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"COUNT\"\n\"DUTY CYCLE\"\n\"PER YEAR\"\n\"PER HOUR\"\n\"azimuth, elevation\"\n\"30,15\"\n\"x,y,z\"\n\"0,0,1\"\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event.html#ansys.sherlock.core.lifecycle.Lifecycle.add_shock_event",
        "title": "add_shock_event > add_shock_event > add_shock_event",
        "section": "add_shock_event > add_shock_event",
        "text": "Lifecycle.add_shock_event(project, phase_name, event_name, duration, duration_units, num_of_cycles, cycle_type, orientation, load_direction, description='')\n\nAdd a shock event to a life cycle phase.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nphase_name: str\n\nName of the life cycle phase to add this shock event to.\n\nevent_name: str\n\nName of the shock event.\n\nduration: float\n\nEvent duration length.\n\nduration_units: str\n\nEvent duration units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\nnum_of_cycles: float\n\nNumber of cycles for the shock event.\n\ncycle_type: str\n\nCycle type. Options are \"COUNT\", \"DUTY CYCLE\",\n\"PER YEAR\", and \"PER HOUR\".\n\norientation: str\n\nPCB orientation in the format of \"azimuth, elevation\". For example,\n\"30,15\".\n\nload_direction: str\n\nLoad direction in the format of \"x,y,z\". For example, \"0,0,1\".\n\ndescription: str, optional\n\nDescription of the shock event. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_shock_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    1.5,\n    \"sec\",\n    4.0,\n    \"PER MIN\",\n    \"45,45\",\n    \"2,4,5\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive.html#import_ipc2581_archive",
        "title": "import_ipc2581_archive",
        "section": "import_ipc2581_archive",
        "text": "Import an IPC-2581 archive file.\nAvailable Since: 2021R1\nFull path to the IPC-2581 archive file.\nWhether to include other layers.\nWhether to guess part properties\nName of the Sherlock project. The default is None, in which case\nthe name of the IPC-2581 archive file is used for the project name.\nName of the CCA. The default is None, in which case the name of\nthe IPC-2581 archive file is used for the CCA name.\nWhether to enable polyline simplification\nPolyline simplification tolerance\nPolyline simplification tolerance units\nStatus code of the response. 0 for success.\nint\nimport_ipc2581_archive\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_ipc2581_archive.html#ansys.sherlock.core.project.Project.import_ipc2581_archive",
        "title": "import_ipc2581_archive > import_ipc2581_archive > import_ipc2581_archive",
        "section": "import_ipc2581_archive > import_ipc2581_archive",
        "text": "Project.import_ipc2581_archive(archive_file, include_other_layers, guess_part_properties, project=None, cca_name=None, polyline_simplification=False, polyline_tolerance=0.1, polyline_tolerance_units='mm')\n\nImport an IPC-2581 archive file.\n\nAvailable Since: 2021R1\n\nParameters\n\narchive_file: str\n\nFull path to the IPC-2581 archive file.\n\ninclude_other_layers: bool\n\nWhether to include other layers.\n\nguess_part_properties: bool\n\nWhether to guess part properties\n\nproject: str, optional\n\nName of the Sherlock project. The default is None, in which case\nthe name of the IPC-2581 archive file is used for the project name.\n\ncca_name: str, optional\n\nName of the CCA. The default is None, in which case the name of\nthe IPC-2581 archive file is used for the CCA name.\n\npolyline_simplification: bool, optional\n\nWhether to enable polyline simplification\n\npolyline_tolerance: float, optional\n\nPolyline simplification tolerance\n\npolyline_tolerance_units: str, optional\n\nPolyline simplification tolerance units\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_ipc2581_archive(\"Tutorial.zip\", True, True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\",\n                        polyline_simplification=True,\n                        polyline_tolerance=0.1,\n                        polyline_tolerance_units=\"mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.dict.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "GerberOutlineFile.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_raw.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PCBShape.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_parametrized_name.html#ansys.sherlock.core.types.project_types.OutlineFile.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod OutlineFile.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod UpdatePottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_copy.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "GerberOutlineFile.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds.html#legend_bounds",
        "title": "legend_bounds",
        "section": "legend_bounds",
        "text": "legend_bounds\nLegendBounds\nlegend_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.legend_bounds",
        "title": "legend_bounds > legend_bounds > legend_bounds",
        "section": "legend_bounds > legend_bounds",
        "text": "ImageFile.legend_bounds\n\nlegend_bounds\n\n!! processed by numpydoc !!\n\nType\n\nLegendBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_config.html#ansys.sherlock.core.types.layer_types.SlotShape.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "SlotShape.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_construct.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CsvExcelOutlineFile.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#common-types",
        "title": "Common Types",
        "section": "Common Types",
        "text": "Module containing types for the Common Service.\nCommon Types"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#constants",
        "title": "Common Types > Constants",
        "section": "Constants",
        "text": "Constants for Unit Type in the List Units request.\nACCELERATION\nACCEL_DENSITY\nAREA\nBANDWIDTH\nCAPACITANCE\nCTE\nCURRENT\nDENSITY\nDISP_DENSITY\nFORCE\nFREQUENCY\nINDUCTANCE\nLENGTH\nPOWER\nRESISTANCE\nSIZE\nSPECIFIC_HEAT\nSTRAIN\nSTRESS\nTEMPERATURE\nTHERMAL_CONDUCTIVITY\nTHERMAL_RESISTANCE\nTIME\nVELOCITY\nVELOCITY_DENSITY\nVOLTAGE\nVOLUME\nWEIGHT\nTypes of delimiters that can be used for exporting tables.\nCOMMA\nSEMICOLON\nSPACE\nTAB\nContains the properties of the measurement.\nmeasurement units\nstr\nmeasurement value\nfloat\nConstants"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType",
        "title": "Common Types > Constants > ListUnitsRequestUnitType",
        "section": "Constants > ListUnitsRequestUnitType",
        "text": "class ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType\n\nConstants for Unit Type in the List Units request.\n\n!! processed by numpydoc !!\n\n\n\nACCELERATION = 2\n\nACCELERATION\n\n!! processed by numpydoc !!\n\n\n\nACCEL_DENSITY = 1\n\nACCEL_DENSITY\n\n!! processed by numpydoc !!\n\n\n\nAREA = 3\n\nAREA\n\n!! processed by numpydoc !!\n\n\n\nBANDWIDTH = 4\n\nBANDWIDTH\n\n!! processed by numpydoc !!\n\n\n\nCAPACITANCE = 5\n\nCAPACITANCE\n\n!! processed by numpydoc !!\n\n\n\nCTE = 6\n\nCTE\n\n!! processed by numpydoc !!\n\n\n\nCURRENT = 7\n\nCURRENT\n\n!! processed by numpydoc !!\n\n\n\nDENSITY = 8\n\nDENSITY\n\n!! processed by numpydoc !!\n\n\n\nDISP_DENSITY = 9\n\nDISP_DENSITY\n\n!! processed by numpydoc !!\n\n\n\nFORCE = 10\n\nFORCE\n\n!! processed by numpydoc !!\n\n\n\nFREQUENCY = 11\n\nFREQUENCY\n\n!! processed by numpydoc !!\n\n\n\nINDUCTANCE = 12\n\nINDUCTANCE\n\n!! processed by numpydoc !!\n\n\n\nLENGTH = 13\n\nLENGTH\n\n!! processed by numpydoc !!\n\n\n\nPOWER = 14\n\nPOWER\n\n!! processed by numpydoc !!\n\n\n\nRESISTANCE = 15\n\nRESISTANCE\n\n!! processed by numpydoc !!\n\n\n\nSIZE = 16\n\nSIZE\n\n!! processed by numpydoc !!\n\n\n\nSPECIFIC_HEAT = 17\n\nSPECIFIC_HEAT\n\n!! processed by numpydoc !!\n\n\n\nSTRAIN = 18\n\nSTRAIN\n\n!! processed by numpydoc !!\n\n\n\nSTRESS = 19\n\nSTRESS\n\n!! processed by numpydoc !!\n\n\n\nTEMPERATURE = 20\n\nTEMPERATURE\n\n!! processed by numpydoc !!\n\n\n\nTHERMAL_CONDUCTIVITY = 21\n\nTHERMAL_CONDUCTIVITY\n\n!! processed by numpydoc !!\n\n\n\nTHERMAL_RESISTANCE = 22\n\nTHERMAL_RESISTANCE\n\n!! processed by numpydoc !!\n\n\n\nTIME = 23\n\nTIME\n\n!! processed by numpydoc !!\n\n\n\nVELOCITY = 24\n\nVELOCITY\n\n!! processed by numpydoc !!\n\n\n\nVELOCITY_DENSITY = 25\n\nVELOCITY_DENSITY\n\n!! processed by numpydoc !!\n\n\n\nVOLTAGE = 26\n\nVOLTAGE\n\n!! processed by numpydoc !!\n\n\n\nVOLUME = 27\n\nVOLUME\n\n!! processed by numpydoc !!\n\n\n\nWEIGHT = 28\n\nWEIGHT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.ACCELERATION",
        "title": "Common Types > Constants > ACCELERATION",
        "section": "Constants > ACCELERATION",
        "text": "ACCELERATION = 2\n\nACCELERATION\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.ACCEL_DENSITY",
        "title": "Common Types > Constants > ACCEL_DENSITY",
        "section": "Constants > ACCEL_DENSITY",
        "text": "ACCEL_DENSITY = 1\n\nACCEL_DENSITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.AREA",
        "title": "Common Types > Constants > AREA",
        "section": "Constants > AREA",
        "text": "AREA = 3\n\nAREA\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.BANDWIDTH",
        "title": "Common Types > Constants > BANDWIDTH",
        "section": "Constants > BANDWIDTH",
        "text": "BANDWIDTH = 4\n\nBANDWIDTH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CAPACITANCE",
        "title": "Common Types > Constants > CAPACITANCE",
        "section": "Constants > CAPACITANCE",
        "text": "CAPACITANCE = 5\n\nCAPACITANCE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CTE",
        "title": "Common Types > Constants > CTE",
        "section": "Constants > CTE",
        "text": "CTE = 6\n\nCTE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.CURRENT",
        "title": "Common Types > Constants > CURRENT",
        "section": "Constants > CURRENT",
        "text": "CURRENT = 7\n\nCURRENT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.DENSITY",
        "title": "Common Types > Constants > DENSITY",
        "section": "Constants > DENSITY",
        "text": "DENSITY = 8\n\nDENSITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.DISP_DENSITY",
        "title": "Common Types > Constants > DISP_DENSITY",
        "section": "Constants > DISP_DENSITY",
        "text": "DISP_DENSITY = 9\n\nDISP_DENSITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.FORCE",
        "title": "Common Types > Constants > FORCE",
        "section": "Constants > FORCE",
        "text": "FORCE = 10\n\nFORCE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.FREQUENCY",
        "title": "Common Types > Constants > FREQUENCY",
        "section": "Constants > FREQUENCY",
        "text": "FREQUENCY = 11\n\nFREQUENCY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.INDUCTANCE",
        "title": "Common Types > Constants > INDUCTANCE",
        "section": "Constants > INDUCTANCE",
        "text": "INDUCTANCE = 12\n\nINDUCTANCE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.LENGTH",
        "title": "Common Types > Constants > LENGTH",
        "section": "Constants > LENGTH",
        "text": "LENGTH = 13\n\nLENGTH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.POWER",
        "title": "Common Types > Constants > POWER",
        "section": "Constants > POWER",
        "text": "POWER = 14\n\nPOWER\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.RESISTANCE",
        "title": "Common Types > Constants > RESISTANCE",
        "section": "Constants > RESISTANCE",
        "text": "RESISTANCE = 15\n\nRESISTANCE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.SIZE",
        "title": "Common Types > Constants > SIZE",
        "section": "Constants > SIZE",
        "text": "SIZE = 16\n\nSIZE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.SPECIFIC_HEAT",
        "title": "Common Types > Constants > SPECIFIC_HEAT",
        "section": "Constants > SPECIFIC_HEAT",
        "text": "SPECIFIC_HEAT = 17\n\nSPECIFIC_HEAT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.STRAIN",
        "title": "Common Types > Constants > STRAIN",
        "section": "Constants > STRAIN",
        "text": "STRAIN = 18\n\nSTRAIN\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.STRESS",
        "title": "Common Types > Constants > STRESS",
        "section": "Constants > STRESS",
        "text": "STRESS = 19\n\nSTRESS\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.TEMPERATURE",
        "title": "Common Types > Constants > TEMPERATURE",
        "section": "Constants > TEMPERATURE",
        "text": "TEMPERATURE = 20\n\nTEMPERATURE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.THERMAL_CONDUCTIVITY",
        "title": "Common Types > Constants > THERMAL_CONDUCTIVITY",
        "section": "Constants > THERMAL_CONDUCTIVITY",
        "text": "THERMAL_CONDUCTIVITY = 21\n\nTHERMAL_CONDUCTIVITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.THERMAL_RESISTANCE",
        "title": "Common Types > Constants > THERMAL_RESISTANCE",
        "section": "Constants > THERMAL_RESISTANCE",
        "text": "THERMAL_RESISTANCE = 22\n\nTHERMAL_RESISTANCE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.TIME",
        "title": "Common Types > Constants > TIME",
        "section": "Constants > TIME",
        "text": "TIME = 23\n\nTIME\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VELOCITY",
        "title": "Common Types > Constants > VELOCITY",
        "section": "Constants > VELOCITY",
        "text": "VELOCITY = 24\n\nVELOCITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VELOCITY_DENSITY",
        "title": "Common Types > Constants > VELOCITY_DENSITY",
        "section": "Constants > VELOCITY_DENSITY",
        "text": "VELOCITY_DENSITY = 25\n\nVELOCITY_DENSITY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VOLTAGE",
        "title": "Common Types > Constants > VOLTAGE",
        "section": "Constants > VOLTAGE",
        "text": "VOLTAGE = 26\n\nVOLTAGE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.VOLUME",
        "title": "Common Types > Constants > VOLUME",
        "section": "Constants > VOLUME",
        "text": "VOLUME = 27\n\nVOLUME\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.ListUnitsRequestUnitType.WEIGHT",
        "title": "Common Types > Constants > WEIGHT",
        "section": "Constants > WEIGHT",
        "text": "WEIGHT = 28\n\nWEIGHT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter",
        "title": "Common Types > Constants > TableDelimiter",
        "section": "Constants > TableDelimiter",
        "text": "class ansys.sherlock.core.types.common_types.TableDelimiter\n\nTypes of delimiters that can be used for exporting tables.\n\n!! processed by numpydoc !!\n\n\n\nCOMMA = 0\n\nCOMMA\n\n!! processed by numpydoc !!\n\n\n\nSEMICOLON = 3\n\nSEMICOLON\n\n!! processed by numpydoc !!\n\n\n\nSPACE = 1\n\nSPACE\n\n!! processed by numpydoc !!\n\n\n\nTAB = 2\n\nTAB\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.COMMA",
        "title": "Common Types > Constants > COMMA",
        "section": "Constants > COMMA",
        "text": "COMMA = 0\n\nCOMMA\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.SEMICOLON",
        "title": "Common Types > Constants > SEMICOLON",
        "section": "Constants > SEMICOLON",
        "text": "SEMICOLON = 3\n\nSEMICOLON\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.SPACE",
        "title": "Common Types > Constants > SPACE",
        "section": "Constants > SPACE",
        "text": "SPACE = 1\n\nSPACE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.TableDelimiter.TAB",
        "title": "Common Types > Constants > TAB",
        "section": "Constants > TAB",
        "text": "TAB = 2\n\nTAB\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement",
        "title": "Common Types > Constants > Measurement",
        "section": "Constants > Measurement",
        "text": "class ansys.sherlock.core.types.common_types.Measurement(value, unit)\n\nContains the properties of the measurement.\n\n!! processed by numpydoc !!\n\n\n\nunit\n\nmeasurement units\n\n!! processed by numpydoc !!\n\nType\n\nstr\n\n\n\nvalue\n\nmeasurement value\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement.unit",
        "title": "Common Types > Constants > unit",
        "section": "Constants > unit",
        "text": "unit\n\nmeasurement units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/common_types",
        "href": "api/common_types.html#ansys.sherlock.core.types.common_types.Measurement.value",
        "title": "Common Types > Constants > value",
        "section": "Constants > value",
        "text": "value\n\nmeasurement value\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "DeletePottingRegionRequest.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca.html#add_cca",
        "title": "add_cca",
        "section": "add_cca",
        "text": "Add one or more CCAs to a project.\nAvailable Since: 2023R2\nName of the Sherlock project.\nList of CCAs to be added consisting of these properties:\nName of the CCA.\nDescription of the CCA. The default is None.\nThe default solder type. The default is None.\nThe default stencil thickness. The default is None.\nUnits for default stencil thickness. The default is None.\nDefault part temp rise. The default is None.\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\nWhether to enable guess part properties. The default is None.\nStatus code of the response. 0 for success.\nint\nadd_cca\nNone\nNone\nNone\nNone\nNone\nNone\n\"C\"\n\"F\"\n\"K\"\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.add_cca.html#ansys.sherlock.core.project.Project.add_cca",
        "title": "add_cca > add_cca > add_cca",
        "section": "add_cca > add_cca",
        "text": "Project.add_cca(project, cca_properties)\n\nAdd one or more CCAs to a project.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_properties: list[dict[str, bool | float | str]]\n\nList of CCAs to be added consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\ndescription: str\n\nDescription of the CCA. The default is None.\n\ndefault_solder_type: str\n\nThe default solder type. The default is None.\n\ndefault_stencil_thickness: float\n\nThe default stencil thickness. The default is None.\n\ndefault_stencil_thickness_units: str\n\nUnits for default stencil thickness. The default is None.\n\ndefault_part_temp_rise: float\n\nDefault part temp rise. The default is None.\n\ndefault_part_temp_rise_units: str\n\nUnits for default part temp rise. The default is None.\nOptions are \"C\", \"F\", and \"K\".\n\nguess_part_properties_enabled: bool\n\nWhether to enable guess part properties. The default is None.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.project.add_cca(\n    \"Test\",\n    [{\n        'cca_name': 'Card 2',\n        'description': 'Second CCA',\n        'default_solder_type': 'SAC305',\n        'default_stencil_thickness': 10,\n        'default_stencil_thickness_units': 'mm',\n        'default_part_temp_rise': 20,\n        'default_part_temp_rise_units': 'C',\n        'guess_part_properties_enabled': False,\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_dump.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "RectangularShape.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/teardown",
        "href": "examples/gallery_examples/99-teardown/teardown.html#teardown",
        "title": "Teardown",
        "section": "Teardown",
        "text": "This restores the environment after running the examples.\nTeardown"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/teardown",
        "href": "examples/gallery_examples/99-teardown/teardown.html#description",
        "title": "Teardown > Description",
        "section": "Description",
        "text": "Perform the following steps to set up the environment:\n- Connect to Sherlock\n- Exit Sherlock\n- Delete temp files\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/teardown",
        "href": "examples/gallery_examples/99-teardown/teardown.html#exit-sherlock",
        "title": "Teardown > Exit Sherlock",
        "section": "Exit Sherlock",
        "text": "Exit the gRPC connection and shut down Sherlock.\nExit Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/teardown",
        "href": "examples/gallery_examples/99-teardown/teardown.html#clean-temporary-directory",
        "title": "Teardown > Clean temporary directory",
        "section": "Clean temporary directory",
        "text": "Delete the directory for storing temp files.\nDownload Jupyter notebook: teardown.ipynb\nDownload Python source code: teardown.py\nDownload zipped: teardown.zip\nClean temporary directory\nDownload Jupyter notebook: teardown.ipynb\nDownload Python source code: teardown.py\nDownload zipped: teardown.zip"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#contribute",
        "title": "Contribute",
        "section": "Contribute",
        "text": "Overall guidance on contributing to a PyAnsys library appears in the\nContributing topic\nin the PyAnsys Developer’s Guide. Ensure that you are thoroughly familiar with\nthis guide before attempting to contribute to PySherlock.\nThe following contribution information is specific to PySherlock.\nContribute"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#post-issues",
        "title": "Contribute > Post issues",
        "section": "Post issues",
        "text": "Use the PySherlock Issues\npage to submit questions, report bugs, and request new features. When possible, you\nshould use these issue templates:\nBug report template\nFeature request template\nIf your issue does not fit into these categories, create your own issue.\nTo reach the PyAnsys team, email pyansys.core@ansys.com.\nPost issues"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#view-documentation",
        "title": "Contribute > View documentation",
        "section": "View documentation",
        "text": "Documentation for the latest stable release of PySherlock is hosted at\nPySherlock Documentation.\nIn the upper right corner of the documentation’s title bar, there is an option\nfor switching from viewing the documentation for the latest stable release to\nviewing the documentation for the development version or previously released versions.\nView documentation"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#code-style",
        "title": "Contribute > Code style",
        "section": "Code style",
        "text": "PySherlock follows the PEP8 standard as outlined in the PyAnsys Development Guide and implements style checking using\npre-commit.\nTo ensure your code meets minimum code styling standards, run:\nYou can also install this as a pre-commit hook by running:\nThis way, it’s not possible for you to push code that fails the style checks. For example:\nCode style"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-the-package",
        "title": "Contribute > Install the package",
        "section": "Install the package",
        "text": "PySherlock has three installation modes: user, developer, and offline.\nInstall the package"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-user-mode",
        "title": "Contribute > Install in user mode",
        "section": "Install in user mode",
        "text": "Before installing PySherlock in user mode, use this command to make sure that\nyou have the latest version of pip:\nThen, use this command to install PySherlock:\nInstall in user mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-developer-mode",
        "title": "Contribute > Install in developer mode",
        "section": "Install in developer mode",
        "text": "To install PySherlock in developer mode, run these commands:\nThen run this command:\nDetails\nInstalling PySherlock in developer mode allows you to modify the source\nand enhance it.\nBefore contributing to the project, see the PyAnsys Developer’s\nguide. You must follow these steps:\nStart by cloning this repository:\nCreate a fresh-clean Python environment and activate it:\nIf you require additional information on virtual environments, see the\nofficial Python venv topic.\nTo make sure you have the latest version of pip,\nrun this command:\nInstall the project in editable mode by running the following commands:\nInstall in developer mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#install-in-offline-mode",
        "title": "Contribute > Install in offline mode",
        "section": "Install in offline mode",
        "text": "If you lack an internet connection on your installation machine (or you do not have access to the\nprivate Ansys PyPI packages repository), you should install PySherlock by downloading the wheelhouse\narchive from the Releases Page for your\ncorresponding machine architecture.\nEach wheelhouse archive contains all the Python wheels necessary to install PySherlock from scratch on Windows,\nLinux, and MacOS from Python 3.10 to 3.13. You can install this on an isolated system with a fresh Python\ninstallation or on a virtual environment.\nFor example, on Linux with Python 3.10, unzip the wheelhouse archive and install it with:\nIf you’re on Windows with Python 3.10, unzip to a wheelhouse directory and install using the preceding command.\nConsider installing using a virtual environment.\nInstall in offline mode"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#testing",
        "title": "Contribute > Testing",
        "section": "Testing",
        "text": "This project takes advantage of tox. This tool automates common\ndevelopment tasks (similar to Makefile), but it is oriented towards Python\ndevelopment.\nTesting"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#using-tox",
        "title": "Contribute > Using tox",
        "section": "Using tox",
        "text": "While Makefile has rules, tox has environments. In fact, tox creates its\nown virtual environment so that anything being tested is isolated from the project\nto guarantee the project’s integrity.\nThe following environments commands are provided:\ntox -e style: Checks for coding style quality.\ntox -e py: Checks for unit tests.\ntox -e py-coverage: Checks for unit testing and code coverage.\ntox -e doc: Checks for successfully building the documentation.\nUsing tox\ntox\ntox"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#raw-testing",
        "title": "Contribute > Raw testing",
        "section": "Raw testing",
        "text": "PySherlock also makes use of PyTest,\nwhich can be easily run by using this command to install the tests target:\nOnce the dependencies are installed in your project, you can simply execute the\nfollowing command to run the PySherlock tests:\nRaw testing\ntests"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#documentation",
        "title": "Contribute > Documentation",
        "section": "Documentation",
        "text": "For building documentation, you can run the usual rules provided in the\nSphinx Makefile, such as:\nHowever, the recommended way of checking documentation integrity is to use\ntox:\nDocumentation\ntox"
    },
    {
        "objectID": "contributing",
        "href": "contributing.html#distributing",
        "title": "Contribute > Distributing",
        "section": "Distributing",
        "text": "If you would like to create either source or wheel files, start by installing\nthe building requirements and then executing the build module with these commands:\nDistributing"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields.html#get_random_vibe_input_fields",
        "title": "get_random_vibe_input_fields",
        "section": "get_random_vibe_input_fields",
        "text": "Get random vibe property fields based on the user configuration.\nAvailable Since: 2023R2\nModel source to get the random vibe property fields from.\nThe default is None.\nRandom vibe input field property names based on the user configuration.\nlist[str]\nget_random_vibe_input_fields\nNone\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_random_vibe_input_fields",
        "title": "get_random_vibe_input_fields > get_random_vibe_input_fields > get_random_vibe_input_fields",
        "section": "get_random_vibe_input_fields > get_random_vibe_input_fields",
        "text": "Analysis.get_random_vibe_input_fields(model_source=None)\n\nGet random vibe property fields based on the user configuration.\n\nAvailable Since: 2023R2\n\nParameters\n\nmodel_source: ModelSource, optional\n\nModel source to get the random vibe property fields from.\nThe default is None.\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nRandom vibe input field property names based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_random_vibe_input_fields(ModelSource.STRAIN_MAP)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_extra.html#ansys.sherlock.core.types.layer_types.PCBShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property PCBShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/index",
        "href": "examples/gallery_examples/02-importing/index.html#importing-projects-and-files",
        "title": "Importing Projects and Files",
        "section": "Importing Projects and Files",
        "text": "Examples on how to import projects and files using PySherlock.\nsphx_glr_examples_gallery_examples_02-importing_import_ipc_2581_archive.py\nsphx_glr_examples_gallery_examples_02-importing_import_odb_archive.py\nsphx_glr_examples_gallery_examples_02-importing_import_parts_list.py\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_archive_single_mode.py\nsphx_glr_examples_gallery_examples_02-importing_import_project_zip_file.py\nImporting Projects and Files"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PottingRegionDeleteData.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.parse_file.html#ansys.sherlock.core.types.layer_types.SlotShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod SlotShape.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#update-part-locations",
        "title": "Update Part Locations",
        "section": "Update Part Locations",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update part locations.\nUpdate Part Locations"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#description",
        "title": "Update Part Locations > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating part\nlocations for CCAs.\nThis script shows how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Update part locations.\nThe updated part locations can be used for accurate placement validation and optimization.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#connect-to-sherlock",
        "title": "Update Part Locations > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#delete-project",
        "title": "Update Part Locations > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#import-tutorial-project",
        "title": "Update Part Locations > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_part_location",
        "href": "examples/gallery_examples/01-project-configuration/update_part_location.html#update-part-locations",
        "title": "Update Part Locations",
        "section": "Update Part Locations",
        "text": "Update the part locations for the “Card” of the “Test” project.\nDownload Jupyter notebook: update_part_location.ipynb\nDownload Python source code: update_part_location.py\nDownload zipped: update_part_location.zip\nUpdate Part Locations\nDownload Jupyter notebook: update_part_location.ipynb\nDownload Python source code: update_part_location.py\nDownload zipped: update_part_location.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_PTH_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_PTH_fatigue_props.html#update_pth_fatigue_props",
        "title": "update_PTH_fatigue_props",
        "section": "update_PTH_fatigue_props",
        "text": "Update properties for one or more Plated Through Hole (PTH) Fatigue Analyses.\nContains all the information needed to update the properties for one or more\nPTH fatigue analyses in a project.\nReturn codes for each update request.\nlist[ReturnCode]\nupdate_PTH_fatigue_props\npython:list\nSherlockCommonService_pb2.ReturnCode\nlist\nReturnCode"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_PTH_fatigue_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_PTH_fatigue_props.html#ansys.sherlock.core.analysis.Analysis.update_PTH_fatigue_props",
        "title": "update_PTH_fatigue_props > update_PTH_fatigue_props > update_PTH_fatigue_props",
        "section": "update_PTH_fatigue_props > update_PTH_fatigue_props",
        "text": "Analysis.update_PTH_fatigue_props(request)\n\nUpdate properties for one or more Plated Through Hole (PTH) Fatigue Analyses.\n\nParameters\n\nrequest: UpdatePTHFatiguePropsRequest\n\nContains all the information needed to update the properties for one or more\nPTH fatigue analyses in a project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockCommonService_pb2.ReturnCode]\n\nReturn codes for each update request.\n\nReturn type\n\nlist[ReturnCode]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.analysis_types import (\n    PTHFatiguePropsAnalysis,\n    UpdatePTHFatiguePropsRequestAnalysisType,\n    UpdatePTHFatiguePropsRequest,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\n    project=\"Assembly Tutorial\",\n    category=\"category\",\n    archive_file=\"C:\\\\Program Files\\\\ANSYS Inc\\\\v252\\\\sherlock\\\\tutorial\\\\\n        Assembly Tutorial.zip\",\n)\n>>> update_request1 = PTHFatiguePropsAnalysis(\n    cca_name=\"Main Board\",\n    qualification=UpdatePTHFatiguePropsRequestAnalysisType.SUPPLIER,\n    pth_quality_factor=\"Good\",\n    pth_wall_thickness=0.1,\n    pth_wall_thickness_units=\"mm\",\n    min_hole_size=0.5,\n    min_hole_size_units=\"mm\",\n    max_hole_size=1.0,\n    max_hole_size_units=\"mm\",\n)\n>>> update_request2 = PTHFatiguePropsAnalysis(\n    cca_name=\"Memory Card 1\",\n    qualification=UpdatePTHFatiguePropsRequestAnalysisType.PRODUCT,\n    pth_quality_factor=\"Good\",\n    pth_wall_thickness=0.2,\n    pth_wall_thickness_units=\"mil\",\n    min_hole_size=0.7,\n    min_hole_size_units=\"mil\",\n    max_hole_size=1.5,\n    max_hole_size_units=\"mil\",\n)\n>>> request = UpdatePTHFatiguePropsRequest(\n    project=\"Assembly Tutorial\",\n    pth_fatigue_analysis_properties=[\n        update_request1,\n        update_request2\n    ]\n)\n>>> return_codes = sherlock.analysis.update_PTH_fatigue_props(request)\n>>> for return_code in return_codes:\n    print(f\"Return code: value={return_code.value}, message={return_code.message}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props.html#update_ict_analysis_props",
        "title": "update_ict_analysis_props",
        "section": "update_ict_analysis_props",
        "text": "Update properties for an ICT analysis.\nAvailable Since: 2024R1\nName of the Sherlock project.\nICT analysis properties for a CCA consisting of these properties:\nName of the CCA.\nSpecifies the amount of time to complete one ICT event.\nApplication time units.\nOptions are \"ms\", \"sec\", \"min\", \"hr\", \"day\", \"year\".\nSpecifies the number of events to apply to the application time when computing\nthe time to failure for a component.\nWhether to enable part validation. The default is None.\nWhether to require material assignment. The default is None.\nThe number of ICT result layers to generate. This parameter is for use with\nthermal analysis.\nStatus code of the response. 0 for success.\nint\nupdate_ict_analysis_props\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props.html#ansys.sherlock.core.analysis.Analysis.update_ict_analysis_props",
        "title": "update_ict_analysis_props > update_ict_analysis_props > update_ict_analysis_props",
        "section": "update_ict_analysis_props > update_ict_analysis_props",
        "text": "Analysis.update_ict_analysis_props(project, ict_analysis_properties)\n\nUpdate properties for an ICT analysis.\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nict_analysis_properties: list[dict[str, bool | float | int | str]]\n\nICT analysis properties for a CCA consisting of these properties:\n\ncca_name: str\n\nName of the CCA.\n\nict_application_time: float\n\nSpecifies the amount of time to complete one ICT event.\n\nict_application_time_units: str\n\nApplication time units.\nOptions are \"ms\", \"sec\", \"min\", \"hr\", \"day\", \"year\".\n\nict_number_of_events: int\n\nSpecifies the number of events to apply to the application time when computing\nthe time to failure for a component.\n\npart_validation_enabled: bool\n\nWhether to enable part validation. The default is None.\n\nrequire_material_assignment_enabled: bool\n\nWhether to require material assignment. The default is None.\n\nict_result_count: int\n\nThe number of ICT result layers to generate. This parameter is for use with\nthermal analysis.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.update_ict_analysis_props(\n    \"Test\",\n    [{\n        \"cca_name\": \"Card\",\n        \"ict_application_time\": 2,\n        \"ict_application_time_units\": \"sec\",\n        \"ict_number_of_events\": 10,\n        \"part_validation_enabled\": False,\n        \"require_material_assignment_enabled\": False,\n    },\n    ]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod PottingRegionUpdateData.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.construct.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod CsvExcelOutlineFile.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list.html#import_parts_list",
        "title": "import_parts_list",
        "section": "import_parts_list",
        "text": "Import a parts list for a CCA.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nFull path to the CSV file with the parts list.\nWhether to set the data source of the properties to \"User\".\nOtherwise, the data source is set to the name of the CSV file.\nStatus code of the response. 0 for success.\nint\nimport_parts_list\n\"User\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.import_parts_list.html#ansys.sherlock.core.parts.Parts.import_parts_list",
        "title": "import_parts_list > import_parts_list > import_parts_list",
        "section": "import_parts_list > import_parts_list",
        "text": "Parts.import_parts_list(project, cca_name, import_file, import_as_user_src)\n\nImport a parts list for a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nimport_file: str\n\nFull path to the CSV file with the parts list.\n\nimport_as_user_src: bool\n\nWhether to set the data source of the properties to \"User\".\nOtherwise, the data source is set to the name of the CSV file.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.import_parts_list(\n    \"Test\",\n    \"Card\",\n    \"Parts List.csv\",\n    False\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_construct.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PottingRegion.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.connect",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.connect.html#connect",
        "title": "connect",
        "section": "connect",
        "text": "Connect to a local instance of Sherlock.\nAvailable Since: 2025R2\nPort number for the connection.\nDefault is 9090.\nMaximum time (in seconds) to wait for the connection to Sherlock to be established.\nDefault is 120 seconds.\nThe instance of sherlock.\nSherlock\nconnect\nSherlock\nSherlock"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.connect",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.connect.html#ansys.sherlock.core.launcher.connect",
        "title": "connect > connect > connect",
        "section": "connect > connect",
        "text": "ansys.sherlock.core.launcher.connect(port=9090, timeout=120)\n\nConnect to a local instance of Sherlock.\n\nAvailable Since: 2025R2\n\nParameters\n\nport: int, optional\n\nPort number for the connection.\nDefault is 9090.\n\ntimeout: int, optional\n\nMaximum time (in seconds) to wait for the connection to Sherlock to be established.\nDefault is 120 seconds.\n\nReturns\n\n:\n\n\n\nSherlock\n\nThe instance of sherlock.\n\nReturn type\n\nSherlock\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> sherlock = launcher.connect(port=9092)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_validate.html#ansys.sherlock.core.types.layer_types.CircularShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CircularShape.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "Y coordinate for the center of the new potting region.\ncenter_y\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "PottingRegionCopyData.center_y: float\n\nY coordinate for the center of the new potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod UpdatePottingRegionRequest.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields_set.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property GerberOutlineFile.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_construct.html#ansys.sherlock.core.types.layer_types.CircularShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod CircularShape.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "404",
        "href": "404.html#oops",
        "title": "Oops",
        "section": "Oops",
        "text": "This is unexpected.\nThe page you are requesting does not exist.\nOops"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields.html#model_computed_fields",
        "title": "model_computed_fields",
        "section": "model_computed_fields",
        "text": "model_computed_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields.html#ansys.sherlock.core.types.layer_types.PCBShape.model_computed_fields",
        "title": "model_computed_fields > model_computed_fields > model_computed_fields",
        "section": "model_computed_fields > model_computed_fields",
        "text": "PCBShape.model_computed_fields = {}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.html#ansyssherlockcorestackupstackup",
        "title": "ansys.sherlock.core.stackup.Stackup",
        "section": "ansys.sherlock.core.stackup.Stackup",
        "text": "Contains all stackup management capabilities.\nStackup.gen_stackup(project, cca_name, ...)\nGenerate a new stackup from given properties.\nStackup.get_layer_count(project, cca_name)\nGet the number of CCA layers in a stackup.\nStackup.get_stackup_props(project, cca_name)\nGet the stackup properties from a CCA.\nStackup.get_total_conductor_thickness(...)\nReturn the total conductor thickness.\nStackup.list_conductor_layers(project)\nList CCA conductor layers.\nStackup.list_laminate_layers(project)\nList all laminate layers and their properties.\nStackup.update_conductor_layer(project, ...)\nUpdate a conductor layer with given properties.\nStackup.update_laminate_layer(project, ...)\nUpdate a laminate layer with given properties.\nansys.sherlock.core.stackup.Stackup\nStackup.gen_stackup\nStackup.get_layer_count\nStackup.get_stackup_props\nStackup.get_total_conductor_thickness\nStackup.list_conductor_layers\nStackup.list_laminate_layers\nStackup.update_conductor_layer\nStackup.update_laminate_layer"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.html#ansys.sherlock.core.stackup.Stackup",
        "title": "ansys.sherlock.core.stackup.Stackup > ansys.sherlock.core.stackup.Stackup > Stackup",
        "section": "ansys.sherlock.core.stackup.Stackup > Stackup",
        "text": "class ansys.sherlock.core.stackup.Stackup(channel, server_version)\n\nContains all stackup management capabilities.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nStackup.gen_stackup(project, cca_name, ...)\n\nGenerate a new stackup from given properties.\n\nStackup.get_layer_count(project, cca_name)\n\nGet the number of CCA layers in a stackup.\n\nStackup.get_stackup_props(project, cca_name)\n\nGet the stackup properties from a CCA.\n\nStackup.get_total_conductor_thickness(...)\n\nReturn the total conductor thickness.\n\nStackup.list_conductor_layers(project)\n\nList CCA conductor layers.\n\nStackup.list_laminate_layers(project)\n\nList all laminate layers and their properties.\n\nStackup.update_conductor_layer(project, ...)\n\nUpdate a conductor layer with given properties.\n\nStackup.update_laminate_layer(project, ...)\n\nUpdate a laminate layer with given properties.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.html#ansyssherlockcorecommoncommon",
        "title": "ansys.sherlock.core.common.Common",
        "section": "ansys.sherlock.core.common.Common",
        "text": "Contains methods from the Sherlock Common service.\nCommon.check()\nPerform a health check on the gRPC connection.\nCommon.exit([close_sherlock_client])\nClose the gRPC connection.\nCommon.get_sherlock_info()\nGet server Sherlock version.\nCommon.get_solder_info()\nGet solder data from Sherlock.\nCommon.is_sherlock_client_loading()\nCheck if the Sherlock client is opened and done initializing.\nCommon.list_solder_materials()\nList valid solders.\nCommon.list_units(unit_type)\nList units for a unit type.\nansys.sherlock.core.common.Common\nCommon.check\nCommon.exit\nCommon.get_sherlock_info\nCommon.get_solder_info\nCommon.is_sherlock_client_loading\nCommon.list_solder_materials\nCommon.list_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.common.Common",
        "href": "api/_autosummary/ansys.sherlock.core.common.Common.html#ansys.sherlock.core.common.Common",
        "title": "ansys.sherlock.core.common.Common > ansys.sherlock.core.common.Common > Common",
        "section": "ansys.sherlock.core.common.Common > Common",
        "text": "class ansys.sherlock.core.common.Common(channel, server_version)\n\nContains methods from the Sherlock Common service.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCommon.check()\n\nPerform a health check on the gRPC connection.\n\nCommon.exit([close_sherlock_client])\n\nClose the gRPC connection.\n\nCommon.get_sherlock_info()\n\nGet server Sherlock version.\n\nCommon.get_solder_info()\n\nGet solder data from Sherlock.\n\nCommon.is_sherlock_client_loading()\n\nCheck if the Sherlock client is opened and done initializing.\n\nCommon.list_solder_materials()\n\nList valid solders.\n\nCommon.list_units(unit_type)\n\nList units for a unit type.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles.html#add_thermal_profiles",
        "title": "add_thermal_profiles",
        "section": "add_thermal_profiles",
        "text": "Add thermal profiles to a life cycle phase.\nAvailable Since: 2023R2\nName of the Sherlock project.\nThermal profiles consisting of these properties:\nName of the life cycle phase to add the thermal profile to.\nName of the thermal event.\nName of the thermal profile.\nTime units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\nTemperature units. Options are \"C\", \"F\", and \"K\".\nThermal profile entries consisting of these properties:\nName of the thermal step.\nType of the thermal step. Options are \"HOLD\" and \"RAMP\".\nDuration of the thermal step expressed in time units.\nTemperature of the step expressed in temperature units.\nStatus code of the response. 0 for success.\nint\nadd_thermal_profiles\n\"ms\"\n\"sec\"\n\"min\"\n\"hr\"\n\"day\"\n\"year\"\n\"C\"\n\"F\"\n\"K\"\n\"HOLD\"\n\"RAMP\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles.html#ansys.sherlock.core.lifecycle.Lifecycle.add_thermal_profiles",
        "title": "add_thermal_profiles > add_thermal_profiles > add_thermal_profiles",
        "section": "add_thermal_profiles > add_thermal_profiles",
        "text": "Lifecycle.add_thermal_profiles(project, thermal_profiles)\n\nAdd thermal profiles to a life cycle phase.\n\nAvailable Since: 2023R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nthermal_profiles: list[tuple[str, str, str, str, str, list[tuple[str, str, float, float]]]]\n\nThermal profiles consisting of these properties:\n\nphase_name: str\n\nName of the life cycle phase to add the thermal profile to.\n\nevent_name: str\n\nName of the thermal event.\n\nprofile_name: str\n\nName of the thermal profile.\n\ntime_units: str\n\nTime units. Options are \"ms\", \"sec\", \"min\", \"hr\",\n\"day\", and \"year\".\n\ntemp_units: str\n\nTemperature units. Options are \"C\", \"F\", and \"K\".\n\nthermal_profile_entries: list[tuple[str, str, float, float]]\n\nThermal profile entries consisting of these properties:\n\nstep: str\n\nName of the thermal step.\n\ntype: str\n\nType of the thermal step. Options are \"HOLD\" and \"RAMP\".\n\ntime: float\n\nDuration of the thermal step expressed in time units.\n\ntemperature: float\n\nTemperature of the step expressed in temperature units.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n)\n>>> sherlock.lifecycle.create_life_phase(\n    \"Test\",\n    \"Example\",\n    1.5,\n    \"year\",\n    4.0,\n    \"COUNT\",\n)\n>>> sherlock.lifecycle.add_thermal_event(\n    \"Test\",\n    \"Example\",\n    \"Event1\",\n    4.0,\n    \"PER YEAR\",\n    \"STORAGE\",\n)\n>>> sherlock.lifecycle.add_thermal_profiles(\n    \"Test\",\n    [(\n        \"Example\",\n        \"Event1\",\n        \"Profile1\",\n        \"sec\",\n        \"F\",\n        [\n            (\"Steady1\", \"HOLD\", 40, 40),\n            (\"Steady\", \"HOLD\", 20, 20),\n            (\"Back\", \"RAMP\", 20, 40),\n        ],\n    )]\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/parts",
        "href": "api/parts.html#parts",
        "title": "Parts",
        "section": "Parts",
        "text": "Module containing all parts management capabilities.\nParts(channel, server_version)\nContains all parts management capabilities.\nParts\nParts"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.parse_obj.html#ansys.sherlock.core.types.layer_types.PCBShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod PCBShape.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.copy.html#ansys.sherlock.core.types.layer_types.PolygonalShape.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PolygonalShape.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units.html#max_temperature_units",
        "title": "max_temperature_units",
        "section": "max_temperature_units",
        "text": "max_temperature_units\nstr\nmax_temperature_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units.html#ansys.sherlock.core.types.project_types.ImageFile.max_temperature_units",
        "title": "max_temperature_units > max_temperature_units > max_temperature_units",
        "section": "max_temperature_units > max_temperature_units",
        "text": "ImageFile.max_temperature_units\n\nmax_temperature_units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch.html#launch",
        "title": "launch",
        "section": "launch",
        "text": "Launch Sherlock using the specified host and port for the gRPC connection.\nAvailable Since: 2025R2\nIP address to start gRPC on.\nThe default is \"127.0.0.1\", which is the IP address for the local host.\nPort number for the connection.\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\nAdditional command arguments for launching Sherlock.\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nPath to the Sherlock installation directory.\nstr\nlaunch\n\"127.0.0.1\"\npython:str\noptional\npython:str\noptional\npython:str\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch.html#ansys.sherlock.core.launcher.launch",
        "title": "launch > launch > launch",
        "section": "launch > launch",
        "text": "ansys.sherlock.core.launcher.launch(host='127.0.0.1', port=9090, single_project_path='', sherlock_command_args='', year=None, release_number=None)\n\nLaunch Sherlock using the specified host and port for the gRPC connection.\n\nAvailable Since: 2025R2\n\nParameters\n\nhost: str, optional\n\nIP address to start gRPC on.\nThe default is \"127.0.0.1\", which is the IP address for the local host.\n\nport: int, optional\n\nPort number for the connection.\n\nsingle_project_path\n\npython:str, optional\n\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\n\nsherlock_command_args\n\npython:str, optional\n\nAdditional command arguments for launching Sherlock.\n\nyear: int, optional\n\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nrelease_number: int, optional\n\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nReturns\n\n:\n\n\n\npython:str\n\nPath to the Sherlock installation directory.\n\nReturn type\n\nstr\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> project = \"C:\\\\Default Projects Directory\\\\ODB++ Tutorial\"\n>>> ansys_install_path = launcher.launch(\n>>>     port=9092, single_project_path=project, year=2024, release_number=2)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegion.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "CopyPottingRegionRequest.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CopyPottingRegionRequest.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.export_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.export_project.html#export_project",
        "title": "export_project",
        "section": "export_project",
        "text": "Export a sherlock project.\nAvailable Since: 2025R1\nName of the project being exported.\nDetermines if design files should be exported.\nDetermines if all analysis module result files should be exported.\nDetermines if all archive result files should be exported.\nDetermines if user properties and custom data files should be exported.\nDetermines if Sherlock console and application log files should be exported.\nDetermines if system technical data should be exported.\nDestination of export file.\nName to be given to the exported file.\nDetermines if exported file will overwrite a previously existing file.\nStatus code of the response. 0 for success.\nint\nexport_project\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.export_project",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.export_project.html#ansys.sherlock.core.project.Project.export_project",
        "title": "export_project > export_project > export_project",
        "section": "export_project > export_project",
        "text": "Project.export_project(project_name, export_design_files, export_result_files, export_archive_results, export_user_files, export_log_files, export_system_data, export_file_dir, export_file_name, overwrite_existing_file)\n\nExport a sherlock project.\n\nAvailable Since: 2025R1\n\nParameters\n\nproject_name: str\n\nName of the project being exported.\n\nexport_design_files: bool\n\nDetermines if design files should be exported.\n\nexport_result_files: bool\n\nDetermines if all analysis module result files should be exported.\n\nexport_archive_results: bool\n\nDetermines if all archive result files should be exported.\n\nexport_user_files: bool\n\nDetermines if user properties and custom data files should be exported.\n\nexport_log_files: bool\n\nDetermines if Sherlock console and application log files should be exported.\n\nexport_system_data: bool\n\nDetermines if system technical data should be exported.\n\nexport_file_dir: str\n\nDestination of export file.\n\nexport_file_name: str\n\nName to be given to the exported file.\n\noverwrite_existing_file: bool\n\nDetermines if exported file will overwrite a previously existing file.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.export_project(\"Tutorial Project\",\nTrue,\nTrue,\nTrue,\nTrue,\nTrue,\nTrue,\n\"C:/Path/To/Exported/Project\",\n\"Exported_Project\",\nTrue)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property UpdatePottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height.html#height",
        "title": "height",
        "section": "height",
        "text": "height of the legend\nfloat\nheight"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.LegendBounds.height.html#ansys.sherlock.core.types.project_types.LegendBounds.height",
        "title": "height > height > height",
        "section": "height > height",
        "text": "LegendBounds.height\n\nheight of the legend\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod CopyPottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_extra.html#ansys.sherlock.core.types.layer_types.CircularShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property CircularShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile.html#load_random_vibe_profile",
        "title": "load_random_vibe_profile",
        "section": "load_random_vibe_profile",
        "text": "Load random vibe profile from .csv or .dat file.\nAvailable Since: 2023R1\nName of the Sherlock project\nName of the lifecycle phase to add this event to.\nName of the random vibe event.\nFile path for thermal profile .dat or .csv file\nStatus code of the response. 0 for success.\nint\nload_random_vibe_profile\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "href": "api/_autosummary/ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile.html#ansys.sherlock.core.lifecycle.Lifecycle.load_random_vibe_profile",
        "title": "load_random_vibe_profile > load_random_vibe_profile > load_random_vibe_profile",
        "section": "load_random_vibe_profile > load_random_vibe_profile",
        "text": "Lifecycle.load_random_vibe_profile(project, phase_name, event_name, file_path)\n\nLoad random vibe profile from .csv or .dat file.\n\nAvailable Since: 2023R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project\n\nphase_name: str\n\nName of the lifecycle phase to add this event to.\n\nevent_name: str\n\nName of the random vibe event.\n\nfile_path: str\n\nFile path for thermal profile .dat or .csv file\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\"\n)\n\n>>> sherlock.lifecycle.load_random_vibe_profile(\n        project=\"Tutorial\",\n        phase_name=\"Phase 1\",\n        event_name=\"Random Event\",\n        file_path=\"TestProfile.dat\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod DeletePottingRegionRequest.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw.html#parse_raw",
        "title": "parse_raw",
        "section": "parse_raw",
        "text": "Self\nparse_raw\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.parse_raw",
        "title": "parse_raw > parse_raw > parse_raw",
        "section": "parse_raw > parse_raw",
        "text": "classmethod UpdatePottingRegionRequest.parse_raw(b, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CopyPottingRegionRequest.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/99-teardown/index",
        "href": "examples/gallery_examples/99-teardown/index.html#teardown",
        "title": "Teardown",
        "section": "Teardown",
        "text": "Scripts to run after the examples.\nsphx_glr_examples_gallery_examples_99-teardown_teardown.py\nTeardown"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionCopyData.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_json.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod GerberOutlineFile.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_and_connect",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_and_connect.html#launch_and_connect",
        "title": "launch_and_connect",
        "section": "launch_and_connect",
        "text": "Launch Sherlock, start gRPC on a given host and port, and wait until connected to Sherlock.\nAvailable Since: 2025R2\nIP address to start gRPC on.\nThe default is \"127.0.0.1\", which is the IP address for the local host.\nPort number for the connection.\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\nAdditional command arguments for launching Sherlock.\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\nMaximum time (in seconds) to wait for the connection to Sherlock to be established.\nDefault is 120 seconds.\nThe instance of sherlock.\nPath to the Sherlock installation directory.\ntuple[Sherlock, str]\nlaunch_and_connect\n\"127.0.0.1\"\npython:str\noptional\npython:str\noptional\nSherlock\npython:str\ntuple\nSherlock\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.launcher.launch_and_connect",
        "href": "api/_autosummary/ansys.sherlock.core.launcher.launch_and_connect.html#ansys.sherlock.core.launcher.launch_and_connect",
        "title": "launch_and_connect > launch_and_connect > launch_and_connect",
        "section": "launch_and_connect > launch_and_connect",
        "text": "ansys.sherlock.core.launcher.launch_and_connect(host='127.0.0.1', port=9090, single_project_path='', sherlock_command_args='', year=None, release_number=None, timeout=120)\n\nLaunch Sherlock, start gRPC on a given host and port, and wait until connected to Sherlock.\n\nAvailable Since: 2025R2\n\nParameters\n\nhost: str, optional\n\nIP address to start gRPC on.\nThe default is \"127.0.0.1\", which is the IP address for the local host.\n\nport: int, optional\n\nPort number for the connection.\n\nsingle_project_path\n\npython:str, optional\n\nPath to the Sherlock project if invoking Sherlock in the single-project mode.\n\nsherlock_command_args\n\npython:str, optional\n\nAdditional command arguments for launching Sherlock.\n\nyear: int, optional\n\n4-digit year of the Sherlock release to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\nrelease_number: int, optional\n\nRelease number of Sherlock to launch. If not provided,\nthe latest installed version of Sherlock will be launched.\n\ntimeout: int, optional\n\nMaximum time (in seconds) to wait for the connection to Sherlock to be established.\nDefault is 120 seconds.\n\nReturns\n\n:\n\n\n\nSherlock\n\nThe instance of sherlock.\n\npython:str\n\nPath to the Sherlock installation directory.\n\nReturn type\n\ntuple[Sherlock, str]\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> project = \"C:\\\\Default Projects Directory\\\\ODB++ Tutorial\"\n>>> sherlock, ansys_install_path = launcher.launch_and_connect(\n>>>     port=9092,\n>>>     single_project_path=project,\n>>>     sherlock_command_args=\"-noGUI\",\n>>>     year=2025,\n>>>     release_number=1,\n>>>     timeout=30)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region.html#copy_modeling_region",
        "title": "copy_modeling_region",
        "section": "copy_modeling_region",
        "text": "Copy one or more modeling regions in a specific project.\nName of the Sherlock project.\nModeling regions to copy along with their corresponding “copy to” parameters.\nEach dictionary should contain:\nName of the CCA.\nRegion ID of the existing modeling region to copy.\nRegion ID of the modeling region copy. Must be unique.\nThe center x coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\nThe center y coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\nStatus code of the response. 0 for success.\nint\ncopy_modeling_region\npython:str\npython:list\npython:dict\npython:str\npython:float\npython:str\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "href": "api/_autosummary/ansys.sherlock.core.layer.Layer.copy_modeling_region.html#ansys.sherlock.core.layer.Layer.copy_modeling_region",
        "title": "copy_modeling_region > copy_modeling_region > copy_modeling_region",
        "section": "copy_modeling_region > copy_modeling_region",
        "text": "Layer.copy_modeling_region(project, copy_regions)\n\nCopy one or more modeling regions in a specific project.\n\nParameters\n\nproject\n\npython:str\n\nName of the Sherlock project.\n\ncopy_regions\n\npython:list[python:dict[python:str, python:float | python:str]]\n\nModeling regions to copy along with their corresponding “copy to” parameters.\nEach dictionary should contain:\n\ncca_name\n\nstr\n\nName of the CCA.\n\nregion_id\n\nstr\n\nRegion ID of the existing modeling region to copy.\n\nregion_id_copy\n\nstr\n\nRegion ID of the modeling region copy. Must be unique.\n\ncenter_x\n\nfloat\n\nThe center x coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\n\ncenter_y\n\nfloat\n\nThe center y coordinate of the modeling region copy. Used for location placement in\nthe Layer Viewer.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>>     \"ODB++ Tutorial.tgz\",\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     True,\n>>>     project=\"Tutorial Project\",\n>>>     cca_name=\"Card\",\n>>> )\n>>> modeling_regions = [\n>>>     {\n>>>         \"cca_name\": \"Card\",\n>>>         \"region_id\": \"Region001\",\n>>>         \"region_id_copy\": \"RegionCopy001\",\n>>>         \"center_x\": 10.0,\n>>>         \"center_y\": 20.0,\n>>>     }\n>>> ]\n>>> result = sherlock.layer.copy_modeling_region(\"Tutorial Project\", modeling_regions)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.model_fields.html#ansys.sherlock.core.types.layer_types.CircularShape.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CircularShape.model_fields = {'center_x': FieldInfo(annotation=float, required=True), 'center_y': FieldInfo(annotation=float, required=True), 'diameter': FieldInfo(annotation=float, required=True), 'node_count': FieldInfo(annotation=int, required=True), 'rotation': FieldInfo(annotation=float, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.html#ansyssherlockcoretypeslayer_typescopypottingregionrequest",
        "title": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "text": "Request to delete 1 or more potting regions.\nCopyPottingRegionRequest.construct([_fields_set])\n\nCopyPottingRegionRequest.copy(*[, include, ...])\nReturns a copy of the model.\nCopyPottingRegionRequest.dict(*[, include, ...])\n\nCopyPottingRegionRequest.from_orm(obj)\n\nCopyPottingRegionRequest.json(*[, include, ...])\n\nCopyPottingRegionRequest.model_construct([...])\nCreates a new instance of the Model class with validated data.\nCopyPottingRegionRequest.model_copy(*[, ...])\n!!! abstract \"Usage Documentation\"\nCopyPottingRegionRequest.model_dump(*[, ...])\n!!! abstract \"Usage Documentation\"\nCopyPottingRegionRequest.model_dump_json(*)\n!!! abstract \"Usage Documentation\"\nCopyPottingRegionRequest.model_json_schema([...])\nGenerates a JSON schema for a model class.\nCopyPottingRegionRequest.model_parametrized_name(params)\nCompute the class name for parametrizations of generic classes.\nCopyPottingRegionRequest.model_post_init(...)\nOverride this method to perform additional initialization after __init__ and model_construct.\nCopyPottingRegionRequest.model_rebuild(*[, ...])\nTry to rebuild the pydantic-core schema for the model.\nCopyPottingRegionRequest.model_validate(obj, *)\nValidate a pydantic model instance.\nCopyPottingRegionRequest.model_validate_json(...)\n!!! abstract \"Usage Documentation\"\nCopyPottingRegionRequest.model_validate_strings(obj, *)\nValidate the given object with string data against the Pydantic model.\nCopyPottingRegionRequest.parse_file(path, *)\n\nCopyPottingRegionRequest.parse_obj(obj)\n\nCopyPottingRegionRequest.parse_raw(b, *[, ...])\n\nCopyPottingRegionRequest.schema([by_alias, ...])\n\nCopyPottingRegionRequest.schema_json(*[, ...])\n\nCopyPottingRegionRequest.str_validation(...)\nValidate string fields listed.\nCopyPottingRegionRequest.update_forward_refs(...)\n\nCopyPottingRegionRequest.validate(value)\n\nCopyPottingRegionRequest.model_computed_fields\n\nCopyPottingRegionRequest.model_config\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nCopyPottingRegionRequest.model_extra\nGet extra fields set during validation.\nCopyPottingRegionRequest.model_fields\n\nCopyPottingRegionRequest.model_fields_set\nReturns the set of fields that have been explicitly set on this model instance.\nCopyPottingRegionRequest.project\nName of the project containing the potting region(s) to be copied.\nCopyPottingRegionRequest.potting_region_copy_data\nData identifying which potting regions to copy and what potting regions to copy from.\nansys.sherlock.core.types.layer_types.CopyPottingRegionRequest\nCopyPottingRegionRequest.construct\nCopyPottingRegionRequest.copy\nCopyPottingRegionRequest.dict\nCopyPottingRegionRequest.from_orm\nCopyPottingRegionRequest.json\nCopyPottingRegionRequest.model_construct\nCopyPottingRegionRequest.model_copy\nCopyPottingRegionRequest.model_dump\nCopyPottingRegionRequest.model_dump_json\nCopyPottingRegionRequest.model_json_schema\nCopyPottingRegionRequest.model_parametrized_name\nCopyPottingRegionRequest.model_post_init\nCopyPottingRegionRequest.model_rebuild\nCopyPottingRegionRequest.model_validate\nCopyPottingRegionRequest.model_validate_json\nCopyPottingRegionRequest.model_validate_strings\nCopyPottingRegionRequest.parse_file\nCopyPottingRegionRequest.parse_obj\nCopyPottingRegionRequest.parse_raw\nCopyPottingRegionRequest.schema\nCopyPottingRegionRequest.schema_json\nCopyPottingRegionRequest.str_validation\nCopyPottingRegionRequest.update_forward_refs\nCopyPottingRegionRequest.validate\nCopyPottingRegionRequest.model_computed_fields\nCopyPottingRegionRequest.model_config\nCopyPottingRegionRequest.model_extra\nCopyPottingRegionRequest.model_fields\nCopyPottingRegionRequest.model_fields_set\nCopyPottingRegionRequest.project\nCopyPottingRegionRequest.potting_region_copy_data"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest",
        "title": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > CopyPottingRegionRequest",
        "section": "ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest > CopyPottingRegionRequest",
        "text": "class ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest(**data)\n\nRequest to delete 1 or more potting regions.\n\n!! processed by numpydoc !!\n\nMethods\n\n\n\n\n\n\n\nCopyPottingRegionRequest.construct([_fields_set])\n\n\n\nCopyPottingRegionRequest.copy(*[, include, ...])\n\nReturns a copy of the model.\n\nCopyPottingRegionRequest.dict(*[, include, ...])\n\n\n\nCopyPottingRegionRequest.from_orm(obj)\n\n\n\nCopyPottingRegionRequest.json(*[, include, ...])\n\n\n\nCopyPottingRegionRequest.model_construct([...])\n\nCreates a new instance of the Model class with validated data.\n\nCopyPottingRegionRequest.model_copy(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCopyPottingRegionRequest.model_dump(*[, ...])\n\n!!! abstract \"Usage Documentation\"\n\nCopyPottingRegionRequest.model_dump_json(*)\n\n!!! abstract \"Usage Documentation\"\n\nCopyPottingRegionRequest.model_json_schema([...])\n\nGenerates a JSON schema for a model class.\n\nCopyPottingRegionRequest.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nCopyPottingRegionRequest.model_post_init(...)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\n\nCopyPottingRegionRequest.model_rebuild(*[, ...])\n\nTry to rebuild the pydantic-core schema for the model.\n\nCopyPottingRegionRequest.model_validate(obj, *)\n\nValidate a pydantic model instance.\n\nCopyPottingRegionRequest.model_validate_json(...)\n\n!!! abstract \"Usage Documentation\"\n\nCopyPottingRegionRequest.model_validate_strings(obj, *)\n\nValidate the given object with string data against the Pydantic model.\n\nCopyPottingRegionRequest.parse_file(path, *)\n\n\n\nCopyPottingRegionRequest.parse_obj(obj)\n\n\n\nCopyPottingRegionRequest.parse_raw(b, *[, ...])\n\n\n\nCopyPottingRegionRequest.schema([by_alias, ...])\n\n\n\nCopyPottingRegionRequest.schema_json(*[, ...])\n\n\n\nCopyPottingRegionRequest.str_validation(...)\n\nValidate string fields listed.\n\nCopyPottingRegionRequest.update_forward_refs(...)\n\n\n\nCopyPottingRegionRequest.validate(value)\n\n\n\n\n\nAttributes\n\n\n\n\n\n\n\nCopyPottingRegionRequest.model_computed_fields\n\n\n\nCopyPottingRegionRequest.model_config\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\nCopyPottingRegionRequest.model_extra\n\nGet extra fields set during validation.\n\nCopyPottingRegionRequest.model_fields\n\n\n\nCopyPottingRegionRequest.model_fields_set\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nCopyPottingRegionRequest.project\n\nName of the project containing the potting region(s) to be copied.\n\nCopyPottingRegionRequest.potting_region_copy_data\n\nData identifying which potting regions to copy and what potting regions to copy from.\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod RectangularShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#analysis-types",
        "title": "Analysis Types",
        "section": "Analysis Types",
        "text": "Module containing types for the Analysis Service.\nAnalysis Types"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#constants",
        "title": "Analysis Types > Constants",
        "section": "Constants",
        "text": "Constants for Element Order.\nLINEAR\nQUADRATIC\nSOLID_SHELL\nConstants for Model Source.\nGENERATED\nSTRAIN_MAP\nConstants for type of analysis in the Run Analysis request.\nCOMPONENT_FAILURE_MODE\nDFMEA\nHARMONIC_VIBE\nICT\nMECHANICAL_SHOCK\nNATURAL_FREQ\nPART_VALIDATION\nPTH_FATIQUE\nRANDOM_VIBE\nSEMICINDUCTOR_WEAROUT\nSOLDER_JOINT_FATIGUE\nTHERMAL_DERATING\nTHERMAL_MECH\nConstants for type of analysis in the Run Strain Map Analysis request.\nHARMONIC_VIBE\nMECHANICAL_SHOCK\nRANDOM_VIBE\nConstants for type of analysis in the Update PCB Modeling Properties Analysis request.\nHARMONIC_VIBE\nICT\nMECHANICAL_SHOCK\nNATURAL_FREQUENCY\nRANDOM_VIBE\nTHERMAL_MECH\nConstants for PCB Material Model in the Update PCB Modeling Properties Analysis request.\nLAYERED\nLAYERED_ELEMENTS\nUNIFORM\nUNIFORM_ELEMENTS\nConstants for PCB Model Type in the Update PCB Modeling Properties Analysis request.\nBONDED\nContains the properties of a component failure mechanism update request.\nName of the CCA.\nDefault part temperature rise.\nDefault part temperature rise units.\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nWhether part temperature rise value is applied to the minimum temperature defined in the\nthermal cycle.\nWhether part validation should be performed.\nValidate string fields listed.\nContains the properties of a component failure mechanism update per project.\nList of potting region data to update.\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nName of the Sherlock project.\nValidate string fields listed.\nConstants\nstr\nfloat\nstr\nbool\nbool\nlist\nComponentFailureMechanism\nstr"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder",
        "title": "Analysis Types > Constants > ElementOrder",
        "section": "Constants > ElementOrder",
        "text": "class ansys.sherlock.core.types.analysis_types.ElementOrder\n\nConstants for Element Order.\n\n!! processed by numpydoc !!\n\n\n\nLINEAR = 1\n\nLINEAR\n\n!! processed by numpydoc !!\n\n\n\nQUADRATIC = 2\n\nQUADRATIC\n\n!! processed by numpydoc !!\n\n\n\nSOLID_SHELL = 3\n\nSOLID_SHELL\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.LINEAR",
        "title": "Analysis Types > Constants > LINEAR",
        "section": "Constants > LINEAR",
        "text": "LINEAR = 1\n\nLINEAR\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.QUADRATIC",
        "title": "Analysis Types > Constants > QUADRATIC",
        "section": "Constants > QUADRATIC",
        "text": "QUADRATIC = 2\n\nQUADRATIC\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ElementOrder.SOLID_SHELL",
        "title": "Analysis Types > Constants > SOLID_SHELL",
        "section": "Constants > SOLID_SHELL",
        "text": "SOLID_SHELL = 3\n\nSOLID_SHELL\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource",
        "title": "Analysis Types > Constants > ModelSource",
        "section": "Constants > ModelSource",
        "text": "class ansys.sherlock.core.types.analysis_types.ModelSource\n\nConstants for Model Source.\n\n!! processed by numpydoc !!\n\n\n\nGENERATED = 1\n\nGENERATED\n\n!! processed by numpydoc !!\n\n\n\nSTRAIN_MAP = 2\n\nSTRAIN_MAP\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource.GENERATED",
        "title": "Analysis Types > Constants > GENERATED",
        "section": "Constants > GENERATED",
        "text": "GENERATED = 1\n\nGENERATED\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ModelSource.STRAIN_MAP",
        "title": "Analysis Types > Constants > STRAIN_MAP",
        "section": "Constants > STRAIN_MAP",
        "text": "STRAIN_MAP = 2\n\nSTRAIN_MAP\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType",
        "title": "Analysis Types > Constants > RunAnalysisRequestAnalysisType",
        "section": "Constants > RunAnalysisRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType\n\nConstants for type of analysis in the Run Analysis request.\n\n!! processed by numpydoc !!\n\n\n\nCOMPONENT_FAILURE_MODE = 7\n\nCOMPONENT_FAILURE_MODE\n\n!! processed by numpydoc !!\n\n\n\nDFMEA = 8\n\nDFMEA\n\n!! processed by numpydoc !!\n\n\n\nHARMONIC_VIBE = 2\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!\n\n\n\nICT = 3\n\nICT\n\n!! processed by numpydoc !!\n\n\n\nMECHANICAL_SHOCK = 4\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!\n\n\n\nNATURAL_FREQ = 1\n\nNATURAL_FREQ\n\n!! processed by numpydoc !!\n\n\n\nPART_VALIDATION = 10\n\nPART_VALIDATION\n\n!! processed by numpydoc !!\n\n\n\nPTH_FATIQUE = 9\n\nPTH_FATIQUE\n\n!! processed by numpydoc !!\n\n\n\nRANDOM_VIBE = 5\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!\n\n\n\nSEMICINDUCTOR_WEAROUT = 11\n\nSEMICINDUCTOR_WEAROUT\n\n!! processed by numpydoc !!\n\n\n\nSOLDER_JOINT_FATIGUE = 12\n\nSOLDER_JOINT_FATIGUE\n\n!! processed by numpydoc !!\n\n\n\nTHERMAL_DERATING = 13\n\nTHERMAL_DERATING\n\n!! processed by numpydoc !!\n\n\n\nTHERMAL_MECH = 14\n\nTHERMAL_MECH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.COMPONENT_FAILURE_MODE",
        "title": "Analysis Types > Constants > COMPONENT_FAILURE_MODE",
        "section": "Constants > COMPONENT_FAILURE_MODE",
        "text": "COMPONENT_FAILURE_MODE = 7\n\nCOMPONENT_FAILURE_MODE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.DFMEA",
        "title": "Analysis Types > Constants > DFMEA",
        "section": "Constants > DFMEA",
        "text": "DFMEA = 8\n\nDFMEA\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE = 2\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.ICT",
        "title": "Analysis Types > Constants > ICT",
        "section": "Constants > ICT",
        "text": "ICT = 3\n\nICT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK = 4\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.NATURAL_FREQ",
        "title": "Analysis Types > Constants > NATURAL_FREQ",
        "section": "Constants > NATURAL_FREQ",
        "text": "NATURAL_FREQ = 1\n\nNATURAL_FREQ\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.PART_VALIDATION",
        "title": "Analysis Types > Constants > PART_VALIDATION",
        "section": "Constants > PART_VALIDATION",
        "text": "PART_VALIDATION = 10\n\nPART_VALIDATION\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.PTH_FATIQUE",
        "title": "Analysis Types > Constants > PTH_FATIQUE",
        "section": "Constants > PTH_FATIQUE",
        "text": "PTH_FATIQUE = 9\n\nPTH_FATIQUE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE = 5\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.SEMICINDUCTOR_WEAROUT",
        "title": "Analysis Types > Constants > SEMICINDUCTOR_WEAROUT",
        "section": "Constants > SEMICINDUCTOR_WEAROUT",
        "text": "SEMICINDUCTOR_WEAROUT = 11\n\nSEMICINDUCTOR_WEAROUT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.SOLDER_JOINT_FATIGUE",
        "title": "Analysis Types > Constants > SOLDER_JOINT_FATIGUE",
        "section": "Constants > SOLDER_JOINT_FATIGUE",
        "text": "SOLDER_JOINT_FATIGUE = 12\n\nSOLDER_JOINT_FATIGUE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.THERMAL_DERATING",
        "title": "Analysis Types > Constants > THERMAL_DERATING",
        "section": "Constants > THERMAL_DERATING",
        "text": "THERMAL_DERATING = 13\n\nTHERMAL_DERATING\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunAnalysisRequestAnalysisType.THERMAL_MECH",
        "title": "Analysis Types > Constants > THERMAL_MECH",
        "section": "Constants > THERMAL_MECH",
        "text": "THERMAL_MECH = 14\n\nTHERMAL_MECH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType",
        "title": "Analysis Types > Constants > RunStrainMapAnalysisRequestAnalysisType",
        "section": "Constants > RunStrainMapAnalysisRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType\n\nConstants for type of analysis in the Run Strain Map Analysis request.\n\n!! processed by numpydoc !!\n\n\n\nHARMONIC_VIBE = 3\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!\n\n\n\nMECHANICAL_SHOCK = 2\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!\n\n\n\nRANDOM_VIBE = 1\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE = 3\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK = 2\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.RunStrainMapAnalysisRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE = 1\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestAnalysisType",
        "section": "Constants > UpdatePcbModelingPropsRequestAnalysisType",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType\n\nConstants for type of analysis in the Update PCB Modeling Properties Analysis request.\n\n!! processed by numpydoc !!\n\n\n\nHARMONIC_VIBE = 1\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!\n\n\n\nICT = 2\n\nICT\n\n!! processed by numpydoc !!\n\n\n\nMECHANICAL_SHOCK = 3\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!\n\n\n\nNATURAL_FREQUENCY = 4\n\nNATURAL_FREQUENCY\n\n!! processed by numpydoc !!\n\n\n\nRANDOM_VIBE = 5\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!\n\n\n\nTHERMAL_MECH = 6\n\nTHERMAL_MECH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.HARMONIC_VIBE",
        "title": "Analysis Types > Constants > HARMONIC_VIBE",
        "section": "Constants > HARMONIC_VIBE",
        "text": "HARMONIC_VIBE = 1\n\nHARMONIC_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.ICT",
        "title": "Analysis Types > Constants > ICT",
        "section": "Constants > ICT",
        "text": "ICT = 2\n\nICT\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.MECHANICAL_SHOCK",
        "title": "Analysis Types > Constants > MECHANICAL_SHOCK",
        "section": "Constants > MECHANICAL_SHOCK",
        "text": "MECHANICAL_SHOCK = 3\n\nMECHANICAL_SHOCK\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.NATURAL_FREQUENCY",
        "title": "Analysis Types > Constants > NATURAL_FREQUENCY",
        "section": "Constants > NATURAL_FREQUENCY",
        "text": "NATURAL_FREQUENCY = 4\n\nNATURAL_FREQUENCY\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.RANDOM_VIBE",
        "title": "Analysis Types > Constants > RANDOM_VIBE",
        "section": "Constants > RANDOM_VIBE",
        "text": "RANDOM_VIBE = 5\n\nRANDOM_VIBE\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestAnalysisType.THERMAL_MECH",
        "title": "Analysis Types > Constants > THERMAL_MECH",
        "section": "Constants > THERMAL_MECH",
        "text": "THERMAL_MECH = 6\n\nTHERMAL_MECH\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestPcbMaterialModel",
        "section": "Constants > UpdatePcbModelingPropsRequestPcbMaterialModel",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel\n\nConstants for PCB Material Model in the Update PCB Modeling Properties Analysis request.\n\n!! processed by numpydoc !!\n\n\n\nLAYERED = 2\n\nLAYERED\n\n!! processed by numpydoc !!\n\n\n\nLAYERED_ELEMENTS = 4\n\nLAYERED_ELEMENTS\n\n!! processed by numpydoc !!\n\n\n\nUNIFORM = 1\n\nUNIFORM\n\n!! processed by numpydoc !!\n\n\n\nUNIFORM_ELEMENTS = 3\n\nUNIFORM_ELEMENTS\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.LAYERED",
        "title": "Analysis Types > Constants > LAYERED",
        "section": "Constants > LAYERED",
        "text": "LAYERED = 2\n\nLAYERED\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.LAYERED_ELEMENTS",
        "title": "Analysis Types > Constants > LAYERED_ELEMENTS",
        "section": "Constants > LAYERED_ELEMENTS",
        "text": "LAYERED_ELEMENTS = 4\n\nLAYERED_ELEMENTS\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM",
        "title": "Analysis Types > Constants > UNIFORM",
        "section": "Constants > UNIFORM",
        "text": "UNIFORM = 1\n\nUNIFORM\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbMaterialModel.UNIFORM_ELEMENTS",
        "title": "Analysis Types > Constants > UNIFORM_ELEMENTS",
        "section": "Constants > UNIFORM_ELEMENTS",
        "text": "UNIFORM_ELEMENTS = 3\n\nUNIFORM_ELEMENTS\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType",
        "title": "Analysis Types > Constants > UpdatePcbModelingPropsRequestPcbModelType",
        "section": "Constants > UpdatePcbModelingPropsRequestPcbModelType",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType\n\nConstants for PCB Model Type in the Update PCB Modeling Properties Analysis request.\n\n!! processed by numpydoc !!\n\n\n\nBONDED = 1\n\nBONDED\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdatePcbModelingPropsRequestPcbModelType.BONDED",
        "title": "Analysis Types > Constants > BONDED",
        "section": "Constants > BONDED",
        "text": "BONDED = 1\n\nBONDED\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism",
        "title": "Analysis Types > Constants > ComponentFailureMechanism",
        "section": "Constants > ComponentFailureMechanism",
        "text": "class ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism(**data)\n\nContains the properties of a component failure mechanism update request.\n\n!! processed by numpydoc !!\n\n\n\ncca_name: str\n\nName of the CCA.\n\n!! processed by numpydoc !!\n\n\n\ndefault_part_temp_rise: float\n\nDefault part temperature rise.\n\n!! processed by numpydoc !!\n\n\n\ndefault_part_temp_rise_units: str\n\nDefault part temperature rise units.\n\n!! processed by numpydoc !!\n\n\n\nmodel_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!\n\n\n\npart_temp_rise_min_enabled: bool\n\nWhether part temperature rise value is applied to the minimum temperature defined in the\nthermal cycle.\n\n!! processed by numpydoc !!\n\n\n\npart_validation_enabled: bool\n\nWhether part validation should be performed.\n\n!! processed by numpydoc !!\n\n\n\nclassmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.cca_name",
        "title": "Analysis Types > Constants > cca_name",
        "section": "Constants > cca_name",
        "text": "cca_name: str\n\nName of the CCA.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.default_part_temp_rise",
        "title": "Analysis Types > Constants > default_part_temp_rise",
        "section": "Constants > default_part_temp_rise",
        "text": "default_part_temp_rise: float\n\nDefault part temperature rise.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.default_part_temp_rise_units",
        "title": "Analysis Types > Constants > default_part_temp_rise_units",
        "section": "Constants > default_part_temp_rise_units",
        "text": "default_part_temp_rise_units: str\n\nDefault part temperature rise units.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.model_config",
        "title": "Analysis Types > Constants > model_config",
        "section": "Constants > model_config",
        "text": "model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.part_temp_rise_min_enabled",
        "title": "Analysis Types > Constants > part_temp_rise_min_enabled",
        "section": "Constants > part_temp_rise_min_enabled",
        "text": "part_temp_rise_min_enabled: bool\n\nWhether part temperature rise value is applied to the minimum temperature defined in the\nthermal cycle.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.part_validation_enabled",
        "title": "Analysis Types > Constants > part_validation_enabled",
        "section": "Constants > part_validation_enabled",
        "text": "part_validation_enabled: bool\n\nWhether part validation should be performed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.ComponentFailureMechanism.str_validation",
        "title": "Analysis Types > Constants > str_validation",
        "section": "Constants > str_validation",
        "text": "classmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest",
        "title": "Analysis Types > Constants > UpdateComponentFailureMechanismPropsRequest",
        "section": "Constants > UpdateComponentFailureMechanismPropsRequest",
        "text": "class ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest(**data)\n\nContains the properties of a component failure mechanism update per project.\n\n!! processed by numpydoc !!\n\n\n\ncomponent_failure_mechanism_properties_per_cca: list[ComponentFailureMechanism]\n\nList of potting region data to update.\n\n!! processed by numpydoc !!\n\n\n\nmodel_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!\n\n\n\nproject: str\n\nName of the Sherlock project.\n\n!! processed by numpydoc !!\n\n\n\nclassmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest.component_failure_mechanism_properties_per_cca",
        "title": "Analysis Types > Constants > component_failure_mechanism_properties_per_cca",
        "section": "Constants > component_failure_mechanism_properties_per_cca",
        "text": "component_failure_mechanism_properties_per_cca: list[ComponentFailureMechanism]\n\nList of potting region data to update.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest.model_config",
        "title": "Analysis Types > Constants > model_config",
        "section": "Constants > model_config",
        "text": "model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest.project",
        "title": "Analysis Types > Constants > project",
        "section": "Constants > project",
        "text": "project: str\n\nName of the Sherlock project.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/analysis_types",
        "href": "api/analysis_types.html#ansys.sherlock.core.types.analysis_types.UpdateComponentFailureMechanismPropsRequest.str_validation",
        "title": "Analysis Types > Constants > str_validation",
        "section": "Constants > str_validation",
        "text": "classmethod str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project.html#project",
        "title": "project",
        "section": "project",
        "text": "Name of the Sherlock project.\nproject\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.project",
        "title": "project > project > project",
        "section": "project > project",
        "text": "UpdatePottingRegionRequest.project: str\n\nName of the Sherlock project.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.schema.html#ansys.sherlock.core.types.project_types.OutlineFile.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod OutlineFile.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod DeletePottingRegionRequest.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_odb_archive",
        "href": "examples/gallery_examples/02-importing/import_odb_archive.html#import-odb-archive",
        "title": "Import ODB++ Archive",
        "section": "Import ODB++ Archive",
        "text": "This example demonstrates how to launch the Sherlock gRPC service, import an ODB++ archive,\nand handle common exceptions during the import process.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including importing ODB++ archives.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import an ODB++ archive.\n- Handle import errors gracefully.\nImport ODB++ Archive"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_odb_archive",
        "href": "examples/gallery_examples/02-importing/import_odb_archive.html#connect-to-sherlock",
        "title": "Import ODB++ Archive > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_odb_archive",
        "href": "examples/gallery_examples/02-importing/import_odb_archive.html#delete-project",
        "title": "Import ODB++ Archive > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/02-importing/import_odb_archive",
        "href": "examples/gallery_examples/02-importing/import_odb_archive.html#import-odb-archive",
        "title": "Import ODB++ Archive",
        "section": "Import ODB++ Archive",
        "text": "Import an ODB++ archive provided with the Sherlock installation.\nDownload Jupyter notebook: import_odb_archive.ipynb\nDownload Python source code: import_odb_archive.py\nDownload zipped: import_odb_archive.zip\nImport ODB++ Archive\nDownload Jupyter notebook: import_odb_archive.ipynb\nDownload Python source code: import_odb_archive.py\nDownload zipped: import_odb_archive.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation.html#rotation",
        "title": "rotation",
        "section": "rotation",
        "text": "float\nrotation (in degrees)\nrotation\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.rotation.html#ansys.sherlock.core.types.layer_types.RectangularShape.rotation",
        "title": "rotation > rotation > rotation",
        "section": "rotation > rotation",
        "text": "RectangularShape.rotation: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nrotation (in degrees)"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionDeleteData.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling.html#enable_lead_modeling",
        "title": "enable_lead_modeling",
        "section": "enable_lead_modeling",
        "text": "Enable lead modeling for leaded parts.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nStatus code of the response. 0 for success.\nenable_lead_modeling\npython:int"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.enable_lead_modeling.html#ansys.sherlock.core.parts.Parts.enable_lead_modeling",
        "title": "enable_lead_modeling > enable_lead_modeling > enable_lead_modeling",
        "section": "enable_lead_modeling > enable_lead_modeling",
        "text": "Parts.enable_lead_modeling(project, cca_name)\n\nEnable lead modeling for leaded parts.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.enable_lead_modeling(\n    \"Test\",\n    \"Card\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.CircularShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CircularShape.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json.html#ansys.sherlock.core.types.layer_types.SlotShape.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "SlotShape.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "GerberOutlineFile.model_fields = {'parse_decimal_first': FieldInfo(annotation=bool, required=False, default=False)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_strings.html#model_validate_strings",
        "title": "model_validate_strings",
        "section": "model_validate_strings",
        "text": "Validate the given object with string data against the Pydantic model.\nobj (Any) – The object containing string data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nmodel_validate_strings\nAny\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_strings",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_strings.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate_strings",
        "title": "model_validate_strings > model_validate_strings > model_validate_strings",
        "section": "model_validate_strings > model_validate_strings",
        "text": "classmethod CsvExcelOutlineFile.model_validate_strings(obj, *, strict=None, context=None, by_alias=None, by_name=None)\n\nValidate the given object with string data against the Pydantic model.\n\nParameters\n\nobj (Any) – The object containing string data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.construct.html#ansys.sherlock.core.types.layer_types.PCBShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PCBShape.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers.html#list_laminate_layers",
        "title": "list_laminate_layers",
        "section": "list_laminate_layers",
        "text": "List all laminate layers and their properties.\nAvailable Since: 2021R1\nName of the Sherlock project.\nThe laminate layers of all CCAs in the project.\nlist[CCALaminateProp]\nlist_laminate_layers\npython:list\nSherlockStackupService_pb2.ListLaminatesResponse.CCALaminateProp\nlist\nCCALaminateProp"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.list_laminate_layers.html#ansys.sherlock.core.stackup.Stackup.list_laminate_layers",
        "title": "list_laminate_layers > list_laminate_layers > list_laminate_layers",
        "section": "list_laminate_layers > list_laminate_layers",
        "text": "Stackup.list_laminate_layers(project)\n\nList all laminate layers and their properties.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\nReturns\n\n:\n\n\n\npython:list[SherlockStackupService_pb2.ListLaminatesResponse.CCALaminateProp]\n\nThe laminate layers of all CCAs in the project.\n\nReturn type\n\nlist[CCALaminateProp]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> laminateLayers = sherlock.stackup.list_laminate_layers(project=\"Tutorial\")\n>>> for layer in laminateLayers:\n>>>     properties = layer.laminateProps\n>>>     for prop in properties:\n>>>     print(f\"{prop}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields.html#get_harmonic_vibe_input_fields",
        "title": "get_harmonic_vibe_input_fields",
        "section": "get_harmonic_vibe_input_fields",
        "text": "Get harmonic vibe property fields based on the user configuration.\nAvailable Since: 2024R1\nModel source to get the harmonic vibe property fields from.\nThe default is None.\nHarmonic vibe property fields based on the user configuration.\nlist[str]\nget_harmonic_vibe_input_fields\nNone\npython:list\npython:str\nlist\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "href": "api/_autosummary/ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields.html#ansys.sherlock.core.analysis.Analysis.get_harmonic_vibe_input_fields",
        "title": "get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields",
        "section": "get_harmonic_vibe_input_fields > get_harmonic_vibe_input_fields",
        "text": "Analysis.get_harmonic_vibe_input_fields(model_source=None)\n\nGet harmonic vibe property fields based on the user configuration.\n\nAvailable Since: 2024R1\n\nParameters\n\nmodel_source: ModelSource, optional\n\nModel source to get the harmonic vibe property fields from.\nThe default is None.\n\nReturns\n\n:\n\n\n\npython:list[python:str]\n\nHarmonic vibe property fields based on the user configuration.\n\nReturn type\n\nlist[str]\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.analysis.get_harmonic_vibe_input_fields(ModelSource.GENERATED)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_GDSII_file",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_GDSII_file.html#import_gdsii_file",
        "title": "import_GDSII_file",
        "section": "import_GDSII_file",
        "text": "Import a GDSII project file and any optional config files.\nAvailable Since: 2025R2\nContains the information needed to import the GDSII project file and any optional\nconfig files.\nStatus of the GDSII file import.\nint\nimport_GDSII_file\nImportGDSIIRequest\nReturnCode\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_GDSII_file",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_GDSII_file.html#ansys.sherlock.core.project.Project.import_GDSII_file",
        "title": "import_GDSII_file > import_GDSII_file > import_GDSII_file",
        "section": "import_GDSII_file > import_GDSII_file",
        "text": "Project.import_GDSII_file(request)\n\nImport a GDSII project file and any optional config files.\n\nAvailable Since: 2025R2\n\nParameters\n\nrequest\n\nImportGDSIIRequest\n\nContains the information needed to import the GDSII project file and any optional\nconfig files.\n\nReturns\n\n:\n\n\n\nReturnCode\n\nStatus of the GDSII file import.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.types.project_types import ImportGDSIIRequest\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> return_code = sherlock.project.import_GDSII_file(\n>>>     ImportGDSIIRequest(\n>>>         gdsii_file=\"path/to/design.gds\",\n>>>         technology_file=\"path/to/tech.xml\",\n>>>         layer_map_file=\"path/to/layer.map\",\n>>>         project=\"TestProject\",\n>>>         cca_name=\"TestCCA\",\n>>>         guess_part_properties=True,\n>>>         polyline_simplification_enabled=True,\n>>>         polyline_tolerance=0.01,\n>>>         polyline_tolerance_units=\"mm\",\n>>>     )\n>>> )\n>>> print(f\"Import result: {return_code}\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "DeletePottingRegionRequest.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.model_extra.html#ansys.sherlock.core.types.project_types.OutlineFile.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property OutlineFile.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.model_construct.html#ansys.sherlock.core.types.layer_types.PCBShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod PCBShape.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "CopyPottingRegionRequest.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property DeletePottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width.html#width",
        "title": "width",
        "section": "width",
        "text": "float\nwidth\nwidth\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.width.html#ansys.sherlock.core.types.layer_types.RectangularShape.width",
        "title": "width > width > width",
        "section": "width > width",
        "text": "RectangularShape.width: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\nwidth"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb.html#export_aedb",
        "title": "export_aedb",
        "section": "export_aedb",
        "text": "Export an Electronics Desktop model.\nAvailable Since: 2024R2\nName of the Sherlock project to generate the EDB model for.\nName of the CCA to generate the EDB model from.\nDirectory for saving exported model to.\nWhether to overwrite an existing file having the same file name.\nThe default is True.\nWhether to launch and display the exported model in Ansys Electronics\nDesktop once the export finishes. The default is False.\nStatus code of the response. 0 for success.\nint\nexport_aedb\nTrue\nFalse\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb",
        "href": "api/_autosummary/ansys.sherlock.core.model.Model.export_aedb.html#ansys.sherlock.core.model.Model.export_aedb",
        "title": "export_aedb > export_aedb > export_aedb",
        "section": "export_aedb > export_aedb",
        "text": "Model.export_aedb(project_name, cca_name, export_file, overwrite=True, display_model=False)\n\nExport an Electronics Desktop model.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject_name: str\n\nName of the Sherlock project to generate the EDB model for.\n\ncca_name: str\n\nName of the CCA to generate the EDB model from.\n\nexport_file: str\n\nDirectory for saving exported model to.\n\noverwrite: bool, optional\n\nWhether to overwrite an existing file having the same file name.\nThe default is True.\n\ndisplay_model: bool, optional\n\nWhether to launch and display the exported model in Ansys Electronics\nDesktop once the export finishes. The default is False.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core import launcher\n>>> from ansys.sherlock.core import model\n>>> sherlock = launcher.launch_sherlock()\n>>> sherlock.model.export_aedb(\n    'Tutorial Project', 'Main Board', 'c:\\Temp\\export.aedb',\n    True, False)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property CopyPottingRegionRequest.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.dict.html#ansys.sherlock.core.types.layer_types.SlotShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "SlotShape.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#project-types",
        "title": "Project Types",
        "section": "Project Types",
        "text": "Classes used for the Project API.\nBoardBounds(bounds)\nContains the properties of the board bounds.\nCsvExcelFile(header_row_count, ...)\nContains the properties for a thermal map, CSV, or Excel file.\nCsvExcelOutlineFile(**data)\nContains the properties for a CSV or Excel outline file.\nGerberOutlineFile(**data)\nContains the properties for a Gerber outline file.\nIcepakFile(temperature_offset, ...)\nContains the properties for a thermal map Icepak file.\nImageBounds(image_x, image_y, height, width)\nContains the properties of the image bounds.\nImageFile(board_bounds, coordinate_units, ...)\nContains the properties for a thermal map image file.\nLegendBounds(legend_x, legend_y, height, width)\nContains the properties of the legend bounds.\nOutlineFile(**data)\nContains the properties for an outline file.\nProject Types\nBoardBounds\nCsvExcelFile\nCsvExcelOutlineFile\nGerberOutlineFile\nIcepakFile\nImageBounds\nImageFile\nLegendBounds\nOutlineFile"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#constants",
        "title": "Project Types > Constants",
        "section": "Constants",
        "text": "Constants for legend orientation in the update thermal maps request.\nHorizontal\nVertical\nConstants for File Type in the Update Outline request.\nCSV Excel\nGerber\nIPC2581\nConstants for File Type in the Add Strain Maps request.\nCSV\nExcel\nImage\nConstants for legend orientation in the add strain maps request.\nHorizontal\nVertical\nConstants for thermal board side in the update thermal maps request.\nBoth\nBottom\nTop\nConstants for File Type in the Update Thermal Maps request.\nCSV\nExcel\nImage\nIcepak Thermal Map (.TMAP)\nConstants"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation",
        "title": "Project Types > Constants > LegendOrientation",
        "section": "Constants > LegendOrientation",
        "text": "class ansys.sherlock.core.types.project_types.LegendOrientation\n\nConstants for legend orientation in the update thermal maps request.\n\n!! processed by numpydoc !!\n\n\n\nHORIZONTAL = 0\n\nHorizontal\n\n!! processed by numpydoc !!\n\n\n\nVERTICAL = 1\n\nVertical\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation.HORIZONTAL",
        "title": "Project Types > Constants > HORIZONTAL",
        "section": "Constants > HORIZONTAL",
        "text": "HORIZONTAL = 0\n\nHorizontal\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.LegendOrientation.VERTICAL",
        "title": "Project Types > Constants > VERTICAL",
        "section": "Constants > VERTICAL",
        "text": "VERTICAL = 1\n\nVertical\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.OutlineFileType",
        "title": "Project Types > Constants > OutlineFileType",
        "section": "Constants > OutlineFileType",
        "text": "class ansys.sherlock.core.types.project_types.OutlineFileType(value, names=<not given>, *values, module=None, qualname=None, type=None, start=1, boundary=None)\n\nConstants for File Type in the Update Outline request.\n\n!! processed by numpydoc !!\n\n\n\nCSV_EXCEL = 1\n\nCSV Excel\n\n!! processed by numpydoc !!\n\n\n\nGERBER = 2\n\nGerber\n\n!! processed by numpydoc !!\n\n\n\nIPC2581 = 3\n\nIPC2581\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.OutlineFileType.CSV_EXCEL",
        "title": "Project Types > Constants > CSV_EXCEL",
        "section": "Constants > CSV_EXCEL",
        "text": "CSV_EXCEL = 1\n\nCSV Excel\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.OutlineFileType.GERBER",
        "title": "Project Types > Constants > GERBER",
        "section": "Constants > GERBER",
        "text": "GERBER = 2\n\nGerber\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.OutlineFileType.IPC2581",
        "title": "Project Types > Constants > IPC2581",
        "section": "Constants > IPC2581",
        "text": "IPC2581 = 3\n\nIPC2581\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType",
        "title": "Project Types > Constants > StrainMapsFileType",
        "section": "Constants > StrainMapsFileType",
        "text": "class ansys.sherlock.core.types.project_types.StrainMapsFileType\n\nConstants for File Type in the Add Strain Maps request.\n\n!! processed by numpydoc !!\n\n\n\nCSV = 0\n\nCSV\n\n!! processed by numpydoc !!\n\n\n\nEXCEL = 1\n\nExcel\n\n!! processed by numpydoc !!\n\n\n\nIMAGE = 2\n\nImage\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.CSV",
        "title": "Project Types > Constants > CSV",
        "section": "Constants > CSV",
        "text": "CSV = 0\n\nCSV\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.EXCEL",
        "title": "Project Types > Constants > EXCEL",
        "section": "Constants > EXCEL",
        "text": "EXCEL = 1\n\nExcel\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapsFileType.IMAGE",
        "title": "Project Types > Constants > IMAGE",
        "section": "Constants > IMAGE",
        "text": "IMAGE = 2\n\nImage\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation",
        "title": "Project Types > Constants > StrainMapLegendOrientation",
        "section": "Constants > StrainMapLegendOrientation",
        "text": "class ansys.sherlock.core.types.project_types.StrainMapLegendOrientation\n\nConstants for legend orientation in the add strain maps request.\n\n!! processed by numpydoc !!\n\n\n\nHORIZONTAL = 0\n\nHorizontal\n\n!! processed by numpydoc !!\n\n\n\nVERTICAL = 1\n\nVertical\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation.HORIZONTAL",
        "title": "Project Types > Constants > HORIZONTAL",
        "section": "Constants > HORIZONTAL",
        "text": "HORIZONTAL = 0\n\nHorizontal\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.StrainMapLegendOrientation.VERTICAL",
        "title": "Project Types > Constants > VERTICAL",
        "section": "Constants > VERTICAL",
        "text": "VERTICAL = 1\n\nVertical\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide",
        "title": "Project Types > Constants > ThermalBoardSide",
        "section": "Constants > ThermalBoardSide",
        "text": "class ansys.sherlock.core.types.project_types.ThermalBoardSide\n\nConstants for thermal board side in the update thermal maps request.\n\n!! processed by numpydoc !!\n\n\n\nBOTH = 1\n\nBoth\n\n!! processed by numpydoc !!\n\n\n\nBOTTOM = 0\n\nBottom\n\n!! processed by numpydoc !!\n\n\n\nTOP = 2\n\nTop\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.BOTH",
        "title": "Project Types > Constants > BOTH",
        "section": "Constants > BOTH",
        "text": "BOTH = 1\n\nBoth\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.BOTTOM",
        "title": "Project Types > Constants > BOTTOM",
        "section": "Constants > BOTTOM",
        "text": "BOTTOM = 0\n\nBottom\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalBoardSide.TOP",
        "title": "Project Types > Constants > TOP",
        "section": "Constants > TOP",
        "text": "TOP = 2\n\nTop\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType",
        "title": "Project Types > Constants > ThermalMapsFileType",
        "section": "Constants > ThermalMapsFileType",
        "text": "class ansys.sherlock.core.types.project_types.ThermalMapsFileType\n\nConstants for File Type in the Update Thermal Maps request.\n\n!! processed by numpydoc !!\n\n\n\nCSV = 0\n\nCSV\n\n!! processed by numpydoc !!\n\n\n\nEXCEL = 1\n\nExcel\n\n!! processed by numpydoc !!\n\n\n\nIMAGE = 2\n\nImage\n\n!! processed by numpydoc !!\n\n\n\nTMAP = 3\n\nIcepak Thermal Map (.TMAP)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.CSV",
        "title": "Project Types > Constants > CSV",
        "section": "Constants > CSV",
        "text": "CSV = 0\n\nCSV\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.EXCEL",
        "title": "Project Types > Constants > EXCEL",
        "section": "Constants > EXCEL",
        "text": "EXCEL = 1\n\nExcel\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.IMAGE",
        "title": "Project Types > Constants > IMAGE",
        "section": "Constants > IMAGE",
        "text": "IMAGE = 2\n\nImage\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/project_types",
        "href": "api/project_types.html#ansys.sherlock.core.types.project_types.ThermalMapsFileType.TMAP",
        "title": "Project Types > Constants > TMAP",
        "section": "Constants > TMAP",
        "text": "TMAP = 3\n\nIcepak Thermal Map (.TMAP)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegionCopyData.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset.html#temperature_offset",
        "title": "temperature_offset",
        "section": "temperature_offset",
        "text": "temperature_offset\nfloat\ntemperature_offset"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset.html#ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset",
        "title": "temperature_offset > temperature_offset > temperature_offset",
        "section": "temperature_offset > temperature_offset",
        "text": "IcepakFile.temperature_offset\n\ntemperature_offset\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL.html#update_parts_from_avl",
        "title": "update_parts_from_AVL",
        "section": "update_parts_from_AVL",
        "text": "Update the parts list from the Approved Vendor List (AVL).\nAvailable Since: 2024R1\nName of the Sherlock project.\nName of the CCA.\nDetermines how parts are matched against the AVL\nDetermines how duplicate part matches are handled when found\nDetermines what part number info in the parts list is updated from the AVL\nDetermines if the part description is updated or not\nStatus code of the response. 0 for success.\nIndicates general errors that occurred while attempting to update parts\nNumber of parts updated\nErrors found when updating part\nUpdatePartsListFromAVLResponse\nupdate_parts_from_AVL\nUpdatePartsListFromAVLResponse\nUpdatePartsListFromAVLResponse"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_from_AVL.html#ansys.sherlock.core.parts.Parts.update_parts_from_AVL",
        "title": "update_parts_from_AVL > update_parts_from_AVL > update_parts_from_AVL",
        "section": "update_parts_from_AVL > update_parts_from_AVL",
        "text": "Parts.update_parts_from_AVL(project, cca_name, matching_mode, duplication_mode, avl_part_num, avl_description)\n\nUpdate the parts list from the Approved Vendor List (AVL).\n\nAvailable Since: 2024R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nmatching_mode: str\n\nDetermines how parts are matched against the AVL\n\nduplication_mode: PartsListSearchDuplicationMode\n\nDetermines how duplicate part matches are handled when found\n\navl_part_num: AVLPartNum\n\nDetermines what part number info in the parts list is updated from the AVL\n\navl_description: AVLDescription\n\nDetermines if the part description is updated or not\n\nReturns\n\n:\n\n\n\nUpdatePartsListFromAVLResponse\n\nreturnCode: ReturnCode\n\nvalue: int\n\nStatus code of the response. 0 for success.\n\nmessage: str\n\nIndicates general errors that occurred while attempting to update parts\n\nnumPartsUpdated: int\n\nNumber of parts updated\n\nupdateErrors: list<str>\n\nErrors found when updating part\n\nReturn type\n\nUpdatePartsListFromAVLResponse\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> from ansys.sherlock.core.types.parts_types import (\n    AVLDescription,\n    AVLPartNum,\n    PartsListSearchDuplicationMode,\n)\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"C:\\\\Program Files\\\\ANSYS Inc\\\\v241\\\\sherlock\\\\tutorial\\\\ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.update_parts_from_AVL(\n    project=\"Test\",\n    cca_name=\"Card\",\n    matching_mode=\"Both\",\n    duplication=PartsListSearchDuplicationMode.FIRST,\n    avl_part_num=AVLPartNum.ASSIGN_INTERNAL_PART_NUM,\n    avl_description=AVLDescription.ASSIGN_APPROVED_DESCRIPTION\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.parse_file.html#ansys.sherlock.core.types.layer_types.CircularShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod CircularShape.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod CopyPottingRegionRequest.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list.html#export_net_list",
        "title": "export_net_list",
        "section": "export_net_list",
        "text": "Export a net list to a delimited output file.\nAvailable Since: 2024R2\nName of the Sherlock project.\nName of the CCA.\nFull path for the output file where the net list will be written.\nThe delimiter character to be used. Defaults to TableDelimiter.COMMA.\nFlag to determine if existing .CSV files should be overwritten\nif they match the output_file. Defaults to False.\nFlag that specifies if UTF-8 will be used for .CSV files. Defaults to False.\nStatus code of the response. 0 for success.\nint\nexport_net_list\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_net_list.html#ansys.sherlock.core.parts.Parts.export_net_list",
        "title": "export_net_list > export_net_list > export_net_list",
        "section": "export_net_list > export_net_list",
        "text": "Parts.export_net_list(project, cca_name, output_file, col_delimiter=0, overwrite_existing=False, utf8_enabled=False)\n\nExport a net list to a delimited output file.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\noutput_file: str\n\nFull path for the output file where the net list will be written.\n\ncol_delimiter: TableDelimiter, optional\n\nThe delimiter character to be used. Defaults to TableDelimiter.COMMA.\n\noverwrite_existing: bool, optional\n\nFlag to determine if existing .CSV files should be overwritten\nif they match the output_file. Defaults to False.\n\nutf8_enabled: bool, optional\n\nFlag that specifies if UTF-8 will be used for .CSV files. Defaults to False.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.export_net_list(\n    \"Test\",\n    \"Card\",\n    \"Net List.csv\",\n    col_delimiter=TableDelimiter.TAB,\n    overwrite_existing=True,\n    utf8_enabled=True\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.json.html#ansys.sherlock.core.types.layer_types.PottingRegion.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "PottingRegion.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count.html#node_count",
        "title": "node_count",
        "section": "node_count",
        "text": "int\nnode count\nnode_count\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.node_count.html#ansys.sherlock.core.types.layer_types.SlotShape.node_count",
        "title": "node_count > node_count > node_count",
        "section": "node_count > node_count",
        "text": "SlotShape.node_count: int\n\nint\n\n!! processed by numpydoc !!\n\nType\n\nnode count"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod UpdatePottingRegionRequest.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json.html#json",
        "title": "json",
        "section": "json",
        "text": "str\njson\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.json.html#ansys.sherlock.core.types.layer_types.SlotShape.json",
        "title": "json > json > json",
        "section": "json > json",
        "text": "SlotShape.json(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False, encoder=PydanticUndefined, models_as_dict=PydanticUndefined, **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name.html#model_parametrized_name",
        "title": "model_parametrized_name",
        "section": "model_parametrized_name",
        "text": "Compute the class name for parametrizations of generic classes.\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\nstr\nString representing the new class where params are passed to cls as type variables.\nTypeError – Raised when trying to generate concrete names for non-generic models.\nmodel_parametrized_name\ntuple\ntype\nAny\n...\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_parametrized_name",
        "title": "model_parametrized_name > model_parametrized_name > model_parametrized_name",
        "section": "model_parametrized_name > model_parametrized_name",
        "text": "classmethod PolygonalShape.model_parametrized_name(params)\n\nCompute the class name for parametrizations of generic classes.\n\nThis method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\nParameters\n\nparams (tuple[type[Any], ...]) – Tuple of types of the class. Given a generic class\nModel with 2 type variables and a concrete model Model[str, int],\nthe value (str, int) would be passed to params.\n\nReturn type\n\nstr\n\nReturns\n\nString representing the new class where params are passed to cls as type variables.\n\nRaises\n\nTypeError – Raised when trying to generate concrete names for non-generic models.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "DeletePottingRegionRequest.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs.html#ansys.sherlock.core.types.layer_types.UpdatePottingRegionRequest.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod UpdatePottingRegionRequest.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.from_orm.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod GerberOutlineFile.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj.html#parse_obj",
        "title": "parse_obj",
        "section": "parse_obj",
        "text": "Self\nparse_obj\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_obj",
        "title": "parse_obj > parse_obj > parse_obj",
        "section": "parse_obj > parse_obj",
        "text": "classmethod RectangularShape.parse_obj(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/index",
        "href": "examples/gallery_examples/03-exporting/index.html#exporting-projects-and-files",
        "title": "Exporting Projects and Files",
        "section": "Exporting Projects and Files",
        "text": "Examples on how to export projects and files using PySherlock.\nsphx_glr_examples_gallery_examples_03-exporting_export_aedb.py\nsphx_glr_examples_gallery_examples_03-exporting_export_all_mount_points.py\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_fixtures.py\nsphx_glr_examples_gallery_examples_03-exporting_export_all_test_points.py\nsphx_glr_examples_gallery_examples_03-exporting_export_fea_model.py\nsphx_glr_examples_gallery_examples_03-exporting_export_net_list.py\nsphx_glr_examples_gallery_examples_03-exporting_export_part_list.py\nsphx_glr_examples_gallery_examples_03-exporting_export_project.py\nsphx_glr_examples_gallery_examples_03-exporting_export_trace_model.py\nExporting Projects and Files"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_config.html#model_config",
        "title": "model_config",
        "section": "model_config",
        "text": "Configuration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\nmodel_config"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_config",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_config.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_config",
        "title": "model_config > model_config > model_config",
        "section": "model_config > model_config",
        "text": "GerberOutlineFile.model_config: ClassVar[ConfigDict] = {}\n\nConfiguration for the model, should be a dictionary conforming to [ConfigDict][pydantic.config.ConfigDict].\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.model_construct.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod GerberOutlineFile.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds.html#board_bounds",
        "title": "board_bounds",
        "section": "board_bounds",
        "text": "board_bounds\nBoardBounds\nboard_bounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.board_bounds.html#ansys.sherlock.core.types.project_types.ImageFile.board_bounds",
        "title": "board_bounds > board_bounds > board_bounds",
        "section": "board_bounds > board_bounds",
        "text": "ImageFile.board_bounds\n\nboard_bounds\n\n!! processed by numpydoc !!\n\nType\n\nBoardBounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump.html#model_dump",
        "title": "model_dump",
        "section": "model_dump",
        "text": "[model_dump](../concepts/serialization.md#modelmodel_dump)\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\ndict[str, Any]\nA dictionary representation of the model.\nmodel_dump\nUnion\nLiteral\n'json'\n'python'\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_dump.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_dump",
        "title": "model_dump > model_dump > model_dump",
        "section": "model_dump > model_dump",
        "text": "PottingRegion.model_dump(*, mode='python', include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump](../concepts/serialization.md#modelmodel_dump)\n\nGenerate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\nParameters\n\nmode (Union[Literal['json', 'python'], str]) – The mode in which to_python should run.\nIf mode is ‘json’, the output will only contain JSON serializable types.\nIf mode is ‘python’, the output may contain non-JSON-serializable Python objects.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to include in the output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – A set of fields to exclude from the output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to use the field’s alias in the dictionary key if defined.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nA dictionary representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.dict.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "CsvExcelOutlineFile.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list.html#update_parts_list",
        "title": "update_parts_list",
        "section": "update_parts_list",
        "text": "Update a parts list based on matching and duplication preferences.\nAvailable Since: 2021R1\nName of the Sherlock project.\nName of the CCA.\nName of the parts library.\nMatching mode for updates.\nHow to handle duplication during the update.\nStatus code of the response. 0 for success.\nint\nupdate_parts_list\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.update_parts_list.html#ansys.sherlock.core.parts.Parts.update_parts_list",
        "title": "update_parts_list > update_parts_list > update_parts_list",
        "section": "update_parts_list > update_parts_list",
        "text": "Parts.update_parts_list(project, cca_name, part_library, matching_mode, duplication_mode)\n\nUpdate a parts list based on matching and duplication preferences.\n\nAvailable Since: 2021R1\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\npart_library: str\n\nName of the parts library.\n\nmatching_mode: str\n\nMatching mode for updates.\n\nduplication_mode: PartsListSearchDuplicationMode\n\nHow to handle duplication during the update.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> import SherlockCommonService_pb2\n>>> import SherlockPartsService_pb2\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n>>> \"ODB++ Tutorial.tgz\",\n>>> True,\n>>> True,\n>>> True,\n>>> True,\n>>> project=\"Test\",\n>>> cca_name=\"Card\",\n>>> )\n>>> sherlock.parts.update_parts_list(\n>>> \"Test\",\n>>> \"Card\",\n>>> \"Sherlock Part Library\",\n>>> SherlockCommonService_pb2.MatchingMode.Both,\n>>> SherlockPartsService_pb2.DuplicationMode.Error,\n>>> )\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild.html#model_rebuild",
        "title": "model_rebuild",
        "section": "model_rebuild",
        "text": "Try to rebuild the pydantic-core schema for the model.\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\nraise_errors (bool) – Whether to raise errors, defaults to True.\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\nbool | None\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\nmodel_rebuild\nbool\nbool\nint\nMapping\nstr\nAny\nNone\nbool\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_rebuild",
        "title": "model_rebuild > model_rebuild > model_rebuild",
        "section": "model_rebuild > model_rebuild",
        "text": "classmethod PottingRegionUpdateData.model_rebuild(*, force=False, raise_errors=True, _parent_namespace_depth=2, _types_namespace=None)\n\nTry to rebuild the pydantic-core schema for the model.\n\nThis may be necessary when one of the annotations is a ForwardRef which could not be resolved during\nthe initial attempt to build the schema, and automatic rebuilding fails.\n\nParameters\n\nforce (bool) – Whether to force the rebuilding of the model schema, defaults to False.\n\nraise_errors (bool) – Whether to raise errors, defaults to True.\n\n_parent_namespace_depth (int) – The depth level of the parent namespace, defaults to 2.\n\n_types_namespace (Mapping[str, Any] | None) – The types namespace, defaults to None.\n\nReturn type\n\nbool | None\n\nReturns\n\nReturns None if the schema is already “complete” and rebuilding was not required.\nIf rebuilding _was_ required, returns True if rebuilding was successful, otherwise False.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.from_orm.html#ansys.sherlock.core.types.layer_types.PottingRegion.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod PottingRegion.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer.html#update_conductor_layer",
        "title": "update_conductor_layer",
        "section": "update_conductor_layer",
        "text": "Update a conductor layer with given properties.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nLayer ID associated with the conductor layer.\nLayer type. The default is \"\". For example,\n\"SIGNAL\", \"POWER\", or \"SUBSTRATE\".\nConductor material. The default is \"\".\nConductor layer thickness. The default is 0.\nUnits for the conductor layer thickness. The\ndefault is \"\".\nConductor percentage. The default is \"\".\nResin material. The default is \"\".\nStatus code of the response. 0 for success.\nint\nupdate_conductor_layer\n\"\"\n\"SIGNAL\"\n\"POWER\"\n\"SUBSTRATE\"\n\"\"\n0\n\"\"\n\"\"\n\"\"\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "href": "api/_autosummary/ansys.sherlock.core.stackup.Stackup.update_conductor_layer.html#ansys.sherlock.core.stackup.Stackup.update_conductor_layer",
        "title": "update_conductor_layer > update_conductor_layer > update_conductor_layer",
        "section": "update_conductor_layer > update_conductor_layer",
        "text": "Stackup.update_conductor_layer(project, cca_name, layer, layer_type='', material='', thickness=0, thickness_unit='', conductor_percent='', resin_material='')\n\nUpdate a conductor layer with given properties.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nlayer: str\n\nLayer ID associated with the conductor layer.\n\nlayer_type: str, optional\n\nLayer type. The default is \"\". For example,\n\"SIGNAL\", \"POWER\", or \"SUBSTRATE\".\n\nmaterial: str, optional\n\nConductor material. The default is \"\".\n\nthickness: float, optional\n\nConductor layer thickness. The default is 0.\n\nthickness_unit: str, optional\n\nUnits for the conductor layer thickness. The\ndefault is \"\".\n\nconductor_percent: str, optional\n\nConductor percentage. The default is \"\".\n\nresin_material: str, optional\n\nResin material. The default is \"\".\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.stackup.update_conductor_layer(\n    \"Test\",\n    \"Card\",\n    \"3\",\n    \"POWER\",\n    \"COPPER\",\n    1.0,\n    \"oz\",\n    \"94.2\",\n    \"Generic FR-4 Generic FR-4\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json.html#model_validate_json",
        "title": "model_validate_json",
        "section": "model_validate_json",
        "text": "[JSON Parsing](../concepts/json.md#json-parsing)\nValidate the given JSON data against the Pydantic model.\njson_data (str | bytes | bytearray) – The JSON data to validate.\nstrict (bool | None) – Whether to enforce types strictly.\ncontext (Any | None) – Extra variables to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nSelf\nThe validated Pydantic model.\nValidationError – If json_data is not a JSON string or the object could not be validated.\nmodel_validate_json\nstr\nbytes\nbytearray\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.model_validate_json",
        "title": "model_validate_json > model_validate_json > model_validate_json",
        "section": "model_validate_json > model_validate_json",
        "text": "classmethod PottingRegionCopyData.model_validate_json(json_data, *, strict=None, context=None, by_alias=None, by_name=None)\n\n!!! abstract “Usage Documentation”\n\n[JSON Parsing](../concepts/json.md#json-parsing)\n\nValidate the given JSON data against the Pydantic model.\n\nParameters\n\njson_data (str | bytes | bytearray) – The JSON data to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\ncontext (Any | None) – Extra variables to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated Pydantic model.\n\nRaises\n\nValidationError – If json_data is not a JSON string or the object could not be validated.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.dict.html#ansys.sherlock.core.types.layer_types.RectangularShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "RectangularShape.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive.html#import_project_zip_archive",
        "title": "import_project_zip_archive",
        "section": "import_project_zip_archive",
        "text": "Import a zipped project archive – multiple project mode.\nAvailable Since: 2024R2\nName of the Sherlock project.\nSherlock project category.\nFull path to the .zip archive file containing the project data.\nStatus code of the response. 0 for success.\nint\nimport_project_zip_archive\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_project_zip_archive.html#ansys.sherlock.core.project.Project.import_project_zip_archive",
        "title": "import_project_zip_archive > import_project_zip_archive > import_project_zip_archive",
        "section": "import_project_zip_archive > import_project_zip_archive",
        "text": "Project.import_project_zip_archive(project, category, archive_file)\n\nImport a zipped project archive – multiple project mode.\n\nAvailable Since: 2024R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncategory: str\n\nSherlock project category.\n\narchive_file: str\n\nFull path to the .zip archive file containing the project data.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_project_zip_archive(\"Tutorial Project\", \"Demos\",\n\"Tutorial Project.zip\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#update-thermal-maps",
        "title": "Update Thermal Maps",
        "section": "Update Thermal Maps",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand update thermal maps.\nUpdate Thermal Maps"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#description",
        "title": "Update Thermal Maps > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating thermal maps for printed\ncircuit boards (PCBs).\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Update thermal maps.\nThe updated thermal maps ensure the accuracy of thermal profiles and board configurations.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#connect-to-sherlock",
        "title": "Update Thermal Maps > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#delete-project",
        "title": "Update Thermal Maps > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#import-tutorial-project",
        "title": "Update Thermal Maps > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_thermal_maps",
        "href": "examples/gallery_examples/01-project-configuration/update_thermal_maps.html#update-thermal-maps",
        "title": "Update Thermal Maps",
        "section": "Update Thermal Maps",
        "text": "Update the thermal maps for the “Tutorial Project”.\nDownload Jupyter notebook: update_thermal_maps.ipynb\nDownload Python source code: update_thermal_maps.py\nDownload zipped: update_thermal_maps.zip\nUpdate Thermal Maps\nDownload Jupyter notebook: update_thermal_maps.ipynb\nDownload Python source code: update_thermal_maps.py\nDownload zipped: update_thermal_maps.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields.html#model_fields",
        "title": "model_fields",
        "section": "model_fields",
        "text": "model_fields"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_fields",
        "title": "model_fields > model_fields > model_fields",
        "section": "model_fields > model_fields",
        "text": "CsvExcelOutlineFile.model_fields = {'header_row_count': FieldInfo(annotation=int, required=True), 'location_units': FieldInfo(annotation=str, required=True), 'x_location_column': FieldInfo(annotation=str, required=True), 'y_location_column': FieldInfo(annotation=str, required=True)}\n\n"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.validate.html#ansys.sherlock.core.types.layer_types.PCBShape.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod PCBShape.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema.html#schema",
        "title": "schema",
        "section": "schema",
        "text": "Dict[str, Any]\nschema\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.schema",
        "title": "schema > schema > schema",
        "section": "schema > schema",
        "text": "classmethod PottingRegionCopyData.schema(by_alias=True, ref_template='#/$defs/{model}')\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive.html#import_odb_archive",
        "title": "import_odb_archive",
        "section": "import_odb_archive",
        "text": "Import an ODB++ archive file.\nAvailable Since: 2021R1\nFull path to the ODB++ archive file.\nWhether to assign stackup thickness.\nWhether to include other layers.\nWhether to process cutouts.\nWhether to guess part properties.\nWhether to generate an IMS stackup\nName of the Sherlock project. The default is None, in which\ncase the name of the ODB++ archive file is used for the project name.\nName of the CCA name. The default is None, in which case the\nname of the ODB++ archive file is used for the CCA name.\nWhether to enable polyline simplification\nPolyline simplification tolerance\nPolyline simplification tolerance units\nStatus code of the response. 0 for success.\nint\nimport_odb_archive\nNone\nNone\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive",
        "href": "api/_autosummary/ansys.sherlock.core.project.Project.import_odb_archive.html#ansys.sherlock.core.project.Project.import_odb_archive",
        "title": "import_odb_archive > import_odb_archive > import_odb_archive",
        "section": "import_odb_archive > import_odb_archive",
        "text": "Project.import_odb_archive(archive_file, process_layer_thickness, include_other_layers, process_cutout_file, guess_part_properties, ims_stackup=False, project=None, cca_name=None, polyline_simplification=False, polyline_tolerance=0.1, polyline_tolerance_units='mm')\n\nImport an ODB++ archive file.\n\nAvailable Since: 2021R1\n\nParameters\n\narchive_file: str\n\nFull path to the ODB++ archive file.\n\nprocess_layer_thickness: bool\n\nWhether to assign stackup thickness.\n\ninclude_other_layers: bool\n\nWhether to include other layers.\n\nprocess_cutout_file: bool\n\nWhether to process cutouts.\n\nguess_part_properties: bool\n\nWhether to guess part properties.\n\nims_stackup: bool, optional\n\nWhether to generate an IMS stackup\n\nproject: str, optional\n\nName of the Sherlock project. The default is None, in which\ncase the name of the ODB++ archive file is used for the project name.\n\ncca_name: str, optional\n\nName of the CCA name. The default is None, in which case the\nname of the ODB++ archive file is used for the CCA name.\n\npolyline_simplification: bool, optional\n\nWhether to enable polyline simplification\n\npolyline_tolerance: float, optional\n\nPolyline simplification tolerance\n\npolyline_tolerance_units: str, optional\n\nPolyline simplification tolerance units\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\"ODB++ Tutorial.tgz\", True, True,\n                        True, True,\n                        ims_stackup=True,\n                        project=\"Tutorial\",\n                        cca_name=\"Card\",\n                        polyline_simplification=True,\n                        polyline_tolerance=0.1,\n                        polyline_tolerance_units=\"mm\")\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CopyPottingRegionRequest.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.dict.html#ansys.sherlock.core.types.layer_types.PolygonalShape.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PolygonalShape.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_validate.html#ansys.sherlock.core.types.layer_types.SlotShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod SlotShape.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.update_forward_refs.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod CsvExcelOutlineFile.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#update-parts-list",
        "title": "Update Parts List",
        "section": "Update Parts List",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nupdate the parts list, and properly close the connection.\nUpdate Parts List"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#description",
        "title": "Update Parts List > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating the\nparts list for printed circuit boards (PCBs). This script shows how to:\nLaunch the Sherlock service.\nImport a project.\nUpdate the parts list.\nProperly close the gRPC connection.\nThe updated parts list ensures alignment with a specified library for consistency and accuracy.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#connect-to-sherlock",
        "title": "Update Parts List > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#delete-project",
        "title": "Update Parts List > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#import-tutorial-project",
        "title": "Update Parts List > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_parts_list",
        "href": "examples/gallery_examples/01-project-configuration/update_parts_list.html#update-parts-list",
        "title": "Update Parts List",
        "section": "Update Parts List",
        "text": "Update the parts list for the “Auto Relay” CCA of the “Test” project.\nDownload Jupyter notebook: update_parts_list.ipynb\nDownload Python source code: update_parts_list.py\nDownload zipped: update_parts_list.zip\nUpdate Parts List\nDownload Jupyter notebook: update_parts_list.ipynb\nDownload Python source code: update_parts_list.py\nDownload zipped: update_parts_list.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod DeletePottingRegionRequest.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema.html#ansys.sherlock.core.types.layer_types.PottingRegionUpdateData.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PottingRegionUpdateData.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init.html#model_post_init",
        "title": "model_post_init",
        "section": "model_post_init",
        "text": "Override this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\nNone\nmodel_post_init\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.model_post_init",
        "title": "model_post_init > model_post_init > model_post_init",
        "section": "model_post_init > model_post_init",
        "text": "PottingRegionDeleteData.model_post_init(context, /)\n\nOverride this method to perform additional initialization after __init__ and model_construct.\nThis is useful if you want to do some validation that requires the entire model to be initialized.\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/model",
        "href": "api/model.html#model",
        "title": "Model",
        "section": "Model",
        "text": "Module containing all model generation capabilities.\nModel(channel, server_version)\nContains all model generation capabilities.\nModel\nModel"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_extra.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property CsvExcelOutlineFile.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy.html#copy",
        "title": "copy",
        "section": "copy",
        "text": "Returns a copy of the model.\nThis method is now deprecated; use model_copy instead.\nIf you need include or exclude, use:\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\ninclude – Optional set or mapping specifying which fields to include in the copied model.\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\nA copy of the model with included, excluded and updated fields as specified.\ncopy\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.copy",
        "title": "copy > copy > copy",
        "section": "copy > copy",
        "text": "PottingRegionCopyData.copy(*, include=None, exclude=None, update=None, deep=False)\n\nReturns a copy of the model.\n\n!!! warning “Deprecated”\n\nThis method is now deprecated; use model_copy instead.\n\nIf you need include or exclude, use:\n\n`python {test=\"skip\" lint=\"skip\"}\ndata = self.model_dump(include=include, exclude=exclude, round_trip=True)\ndata = {**data, **(update or {})}\ncopied = self.model_validate(data)\n`\n\nParameters\n\ninclude – Optional set or mapping specifying which fields to include in the copied model.\n\nexclude – Optional set or mapping specifying which fields to exclude in the copied model.\n\nupdate – Optional dictionary of field-value pairs to override field values in the copied model.\n\ndeep – If True, the values of fields that are Pydantic models will be deep-copied.\n\nReturns\n\nA copy of the model with included, excluded and updated fields as specified.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_net_list",
        "href": "examples/gallery_examples/03-exporting/export_net_list.html#export-net-list",
        "title": "Export Net List",
        "section": "Export Net List",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand export the net list associated with the imported project.\nDescription\nSherlock’s gRPC API enables automation of various workflows, including net list export.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Export the net list from the project.\nExport Net List"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_net_list",
        "href": "examples/gallery_examples/03-exporting/export_net_list.html#connect-to-sherlock",
        "title": "Export Net List > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_net_list",
        "href": "examples/gallery_examples/03-exporting/export_net_list.html#delete-project",
        "title": "Export Net List > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_net_list",
        "href": "examples/gallery_examples/03-exporting/export_net_list.html#import-tutorial-project",
        "title": "Export Net List > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/03-exporting/export_net_list",
        "href": "examples/gallery_examples/03-exporting/export_net_list.html#export-net-list",
        "title": "Export Net List",
        "section": "Export Net List",
        "text": "Export the net list from the imported project.\nDownload Jupyter notebook: export_net_list.ipynb\nDownload Python source code: export_net_list.py\nDownload zipped: export_net_list.zip\nExport Net List\nDownload Jupyter notebook: export_net_list.ipynb\nDownload Python source code: export_net_list.py\nDownload zipped: export_net_list.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct.html#model_construct",
        "title": "model_construct",
        "section": "model_construct",
        "text": "Creates a new instance of the Model class with validated data.\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\nvalues (Any) – Trusted or pre-validated data dictionary.\nSelf\nA new instance of the Model class with validated data.\nmodel_construct\nset\nstr\nNone\nAny\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.model_construct.html#ansys.sherlock.core.types.layer_types.SlotShape.model_construct",
        "title": "model_construct > model_construct > model_construct",
        "section": "model_construct > model_construct",
        "text": "classmethod SlotShape.model_construct(_fields_set=None, **values)\n\nCreates a new instance of the Model class with validated data.\n\nCreates a new model setting __dict__ and __pydantic_fields_set__ from trusted or pre-validated data.\nDefault values are respected, but no other validation is performed.\n\n!!! note\n\nmodel_construct() generally respects the model_config.extra setting on the provided model.\nThat is, if model_config.extra == ‘allow’, then all extra passed values are added to the model instance’s __dict__\nand __pydantic_extra__ fields. If model_config.extra == ‘ignore’ (the default), then all extra passed values are ignored.\nBecause no validation is performed with a call to model_construct(), having model_config.extra == ‘forbid’ does not result in\nan error if extra values are passed, but they will be ignored.\n\nParameters\n\n_fields_set (set[str] | None) – A set of field names that were originally explicitly set during instantiation. If provided,\nthis is directly used for the [model_fields_set][pydantic.BaseModel.model_fields_set] attribute.\nOtherwise, the field names from the values argument will be used.\n\nvalues (Any) – Trusted or pre-validated data dictionary.\n\nReturn type\n\nSelf\n\nReturns\n\nA new instance of the Model class with validated data.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set.html#model_fields_set",
        "title": "model_fields_set",
        "section": "model_fields_set",
        "text": "Returns the set of fields that have been explicitly set on this model instance.\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\ni.e. that were not filled from defaults.\nmodel_fields_set"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set.html#ansys.sherlock.core.types.layer_types.PottingRegion.model_fields_set",
        "title": "model_fields_set > model_fields_set > model_fields_set",
        "section": "model_fields_set > model_fields_set",
        "text": "property PottingRegion.model_fields_set: set[str]\n\nReturns the set of fields that have been explicitly set on this model instance.\n\nReturns\n\nA set of strings representing the fields that have been set,\n\ni.e. that were not filled from defaults.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema_json.html#schema_json",
        "title": "schema_json",
        "section": "schema_json",
        "text": "str\nschema_json\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.GerberOutlineFile.schema_json.html#ansys.sherlock.core.types.project_types.GerberOutlineFile.schema_json",
        "title": "schema_json > schema_json > schema_json",
        "section": "schema_json > schema_json",
        "text": "classmethod GerberOutlineFile.schema_json(*, by_alias=True, ref_template='#/$defs/{model}', **dumps_kwargs)\n\nReturn type\n\nstr\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x.html#image_x",
        "title": "image_x",
        "section": "image_x",
        "text": "x coordinate of the upper left corner\nfloat\nimage_x"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageBounds.image_x.html#ansys.sherlock.core.types.project_types.ImageBounds.image_x",
        "title": "image_x > image_x > image_x",
        "section": "image_x > image_x",
        "text": "ImageBounds.image_x\n\nx coordinate of the upper left corner\n\n!! processed by numpydoc !!\n\nType\n\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm.html#from_orm",
        "title": "from_orm",
        "section": "from_orm",
        "text": "Self\nfrom_orm\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.from_orm",
        "title": "from_orm > from_orm > from_orm",
        "section": "from_orm > from_orm",
        "text": "classmethod DeletePottingRegionRequest.from_orm(obj)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.SlotShape.construct.html#ansys.sherlock.core.types.layer_types.SlotShape.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod SlotShape.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#update-mount-points-by-file",
        "title": "Update Mount Points by File",
        "section": "Update Mount Points by File",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nupdate mount points using a file, and properly close the connection.\nUpdate Mount Points by File"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#description",
        "title": "Update Mount Points by File > Description",
        "section": "Description",
        "text": "Sherlock’s gRPC API allows users to automate workflows such as updating mount points\nfor a CCA using a CSV file.\nThis script demonstrates how to:\n- Connect to the Sherlock service.\n- Import a project.\n- Update mount points using a CSV file.\nThe updated mount points can be used for further structural analysis and validation.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#connect-to-sherlock",
        "title": "Update Mount Points by File > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#delete-project",
        "title": "Update Mount Points by File > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#import-tutorial-project",
        "title": "Update Mount Points by File > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file",
        "href": "examples/gallery_examples/01-project-configuration/update_mount_points_by_file.html#update-mount-points-by-file",
        "title": "Update Mount Points by File",
        "section": "Update Mount Points by File",
        "text": "Update the mount points for the “Card” of the “Tutorial” project using a CSV file.\nDownload Jupyter notebook: update_mount_points_by_file.ipynb\nDownload Python source code: update_mount_points_by_file.py\nDownload zipped: update_mount_points_by_file.zip\nUpdate Mount Points by File\nDownload Jupyter notebook: update_mount_points_by_file.ipynb\nDownload Python source code: update_mount_points_by_file.py\nDownload zipped: update_mount_points_by_file.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs.html#update_forward_refs",
        "title": "update_forward_refs",
        "section": "update_forward_refs",
        "text": "None\nupdate_forward_refs\nNone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs.html#ansys.sherlock.core.types.layer_types.PCBShape.update_forward_refs",
        "title": "update_forward_refs > update_forward_refs > update_forward_refs",
        "section": "update_forward_refs > update_forward_refs",
        "text": "classmethod PCBShape.update_forward_refs(**localns)\n\nReturn type\n\nNone\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#update-harmonic-vibration-analysis-properties",
        "title": "Update Harmonic Vibration Analysis properties",
        "section": "Update Harmonic Vibration Analysis properties",
        "text": "This example demonstrates how to connect to the Sherlock gRPC service, import a project,\nand configure harmonic vibration analysis properties.\nUpdate Harmonic Vibration Analysis properties"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#description",
        "title": "Update Harmonic Vibration Analysis properties > Description",
        "section": "Description",
        "text": "Sherlock allows you to perform harmonic vibration analysis.\nThis script performs the following steps:\n- Connect to the Sherlock service.\n- Import a project.\n- Configure the properties for harmonic vibration analysis.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#connect-to-sherlock",
        "title": "Update Harmonic Vibration Analysis properties > Connect to Sherlock",
        "section": "Connect to Sherlock",
        "text": "Connect to the Sherlock service and ensure proper initialization.\nConnect to Sherlock"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#delete-project",
        "title": "Update Harmonic Vibration Analysis properties > Delete Project",
        "section": "Delete Project",
        "text": "Delete the project if it already exists.\nDelete Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#import-tutorial-project",
        "title": "Update Harmonic Vibration Analysis properties > Import Tutorial Project",
        "section": "Import Tutorial Project",
        "text": "Import the tutorial project zip archive from the Sherlock tutorial directory.\nImport Tutorial Project"
    },
    {
        "objectID": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties",
        "href": "examples/gallery_examples/04-analyses/update_harmonic_vibe_properties.html#update-harmonic-vibration-properties",
        "title": "Update Harmonic Vibration Analysis properties > Update Harmonic Vibration Properties",
        "section": "Update Harmonic Vibration Properties",
        "text": "Configure properties for harmonic vibration analysis.\nDownload Jupyter notebook: update_harmonic_vibe_properties.ipynb\nDownload Python source code: update_harmonic_vibe_properties.py\nDownload zipped: update_harmonic_vibe_properties.zip\nUpdate Harmonic Vibration Properties\nDownload Jupyter notebook: update_harmonic_vibe_properties.ipynb\nDownload Python source code: update_harmonic_vibe_properties.py\nDownload zipped: update_harmonic_vibe_properties.zip"
    },
    {
        "objectID": "api/stackup",
        "href": "api/stackup.html#stackup",
        "title": "Stackup",
        "section": "Stackup",
        "text": "Module containing all stackup management capabilities.\nStackup(channel, server_version)\nContains all stackup management capabilities.\nStackup\nStackup"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y.html#center_y",
        "title": "center_y",
        "section": "center_y",
        "text": "float\ny coordinate of center\ncenter_y\nfloat"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CircularShape.center_y.html#ansys.sherlock.core.types.layer_types.CircularShape.center_y",
        "title": "center_y > center_y > center_y",
        "section": "center_y > center_y",
        "text": "CircularShape.center_y: float\n\nfloat\n\n!! processed by numpydoc !!\n\nType\n\ny coordinate of center"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json.html#model_dump_json",
        "title": "model_dump_json",
        "section": "model_dump_json",
        "text": "[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\nGenerates a JSON representation of the model using Pydantic’s to_json method.\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\ncontext (Any | None) – Additional context to pass to the serializer.\nby_alias (bool | None) – Whether to serialize using field aliases.\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\nexclude_none (bool) – Whether to exclude fields that have a value of None.\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\nstr\nA JSON string representation of the model.\nmodel_dump_json\nint\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nMapping\nstr\nUnion\nset\nint\nset\nstr\nMapping\nint\nUnion\nbool\nMapping\nstr\nUnion\nbool\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nbool\nbool\nbool\nUnion\nbool\nLiteral\n'none'\n'warn'\n'error'\nOptional\nCallable\nAny\nAny\nbool\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json.html#ansys.sherlock.core.types.layer_types.DeletePottingRegionRequest.model_dump_json",
        "title": "model_dump_json > model_dump_json > model_dump_json",
        "section": "model_dump_json > model_dump_json",
        "text": "DeletePottingRegionRequest.model_dump_json(*, indent=None, include=None, exclude=None, context=None, by_alias=None, exclude_unset=False, exclude_defaults=False, exclude_none=False, round_trip=False, warnings=True, fallback=None, serialize_as_any=False)\n\n!!! abstract “Usage Documentation”\n\n[model_dump_json](../concepts/serialization.md#modelmodel_dump_json)\n\nGenerates a JSON representation of the model using Pydantic’s to_json method.\n\nParameters\n\nindent (int | None) – Indentation to use in the JSON output. If None is passed, the output will be compact.\n\ninclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to include in the JSON output.\n\nexclude (Union[set[int], set[str], Mapping[int, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], Mapping[str, Union[set[int], set[str], Mapping[int, Union[IncEx, bool]], Mapping[str, Union[IncEx, bool]], bool]], None]) – Field(s) to exclude from the JSON output.\n\ncontext (Any | None) – Additional context to pass to the serializer.\n\nby_alias (bool | None) – Whether to serialize using field aliases.\n\nexclude_unset (bool) – Whether to exclude fields that have not been explicitly set.\n\nexclude_defaults (bool) – Whether to exclude fields that are set to their default value.\n\nexclude_none (bool) – Whether to exclude fields that have a value of None.\n\nround_trip (bool) – If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n\nwarnings (Union[bool, Literal['none', 'warn', 'error']]) – How to handle serialization errors. False/”none” ignores them, True/”warn” logs errors,\n“error” raises a [PydanticSerializationError][pydantic_core.PydanticSerializationError].\n\nfallback (Optional[Callable[[Any], Any]]) – A function to call when an unknown value is encountered. If not provided,\na [PydanticSerializationError][pydantic_core.PydanticSerializationError] error is raised.\n\nserialize_as_any (bool) – Whether to serialize fields with duck-typing serialization behavior.\n\nReturn type\n\nstr\n\nReturns\n\nA JSON string representation of the model.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra.html#ansys.sherlock.core.types.layer_types.CopyPottingRegionRequest.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property CopyPottingRegionRequest.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units.html#potting_units",
        "title": "potting_units",
        "section": "potting_units",
        "text": "The units to use for the potting region.\npotting_units\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegion.potting_units.html#ansys.sherlock.core.types.layer_types.PottingRegion.potting_units",
        "title": "potting_units > potting_units > potting_units",
        "section": "potting_units > potting_units",
        "text": "PottingRegion.potting_units: str\n\nThe units to use for the potting region.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod CsvExcelOutlineFile.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation.html#legend_orientation",
        "title": "legend_orientation",
        "section": "legend_orientation",
        "text": "legend_orientation\nLegendOrientation\nlegend_orientation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.ImageFile.legend_orientation.html#ansys.sherlock.core.types.project_types.ImageFile.legend_orientation",
        "title": "legend_orientation > legend_orientation > legend_orientation",
        "section": "legend_orientation > legend_orientation",
        "text": "ImageFile.legend_orientation\n\nlegend_orientation\n\n!! processed by numpydoc !!\n\nType\n\nLegendOrientation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list.html#export_parts_list",
        "title": "export_parts_list",
        "section": "export_parts_list",
        "text": "Export a parts list for a CCA.\nAvailable Since: 2021R2\nName of the Sherlock project.\nName of the CCA.\nFull path for the CSV file to export the parts list to.\nStatus code of the response. 0 for success.\nint\nexport_parts_list\npython:int\nint"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list",
        "href": "api/_autosummary/ansys.sherlock.core.parts.Parts.export_parts_list.html#ansys.sherlock.core.parts.Parts.export_parts_list",
        "title": "export_parts_list > export_parts_list > export_parts_list",
        "section": "export_parts_list > export_parts_list",
        "text": "Parts.export_parts_list(project, cca_name, export_file)\n\nExport a parts list for a CCA.\n\nAvailable Since: 2021R2\n\nParameters\n\nproject: str\n\nName of the Sherlock project.\n\ncca_name: str\n\nName of the CCA.\n\nexport_file: str\n\nFull path for the CSV file to export the parts list to.\n\nReturns\n\n:\n\n\n\npython:int\n\nStatus code of the response. 0 for success.\n\nReturn type\n\nint\n\nExamples\n\n>>> from ansys.sherlock.core.launcher import launch_sherlock\n>>> sherlock = launch_sherlock()\n>>> sherlock.project.import_odb_archive(\n    \"ODB++ Tutorial.tgz\",\n    True,\n    True,\n    True,\n    True,\n    project=\"Test\",\n    cca_name=\"Card\",\n)\n>>> sherlock.parts.export_parts_list(\n    \"Test\",\n    \"Card\",\n    \"Parts List.csv\"\n)\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_type",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_type.html#file_type",
        "title": "file_type",
        "section": "file_type",
        "text": "The type of outline file.\nfile_type\nOutlineFileType"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_type",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.OutlineFile.file_type.html#ansys.sherlock.core.types.project_types.OutlineFile.file_type",
        "title": "file_type > file_type > file_type",
        "section": "file_type > file_type",
        "text": "OutlineFile.file_type: OutlineFileType\n\nThe type of outline file.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema.html#model_json_schema",
        "title": "model_json_schema",
        "section": "model_json_schema",
        "text": "Generates a JSON schema for a model class.\nby_alias (bool) – Whether to use attribute aliases or not.\nref_template (str) – The reference template.\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\ndict[str, Any]\nThe JSON schema for the given model class.\nmodel_json_schema\nbool\nstr\ntype\nGenerateJsonSchema\nLiteral\n'validation'\n'serialization'\ndict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_json_schema",
        "title": "model_json_schema > model_json_schema > model_json_schema",
        "section": "model_json_schema > model_json_schema",
        "text": "classmethod PolygonalShape.model_json_schema(by_alias=True, ref_template='#/$defs/{model}', schema_generator=<class 'pydantic.json_schema.GenerateJsonSchema'>, mode='validation')\n\nGenerates a JSON schema for a model class.\n\nParameters\n\nby_alias (bool) – Whether to use attribute aliases or not.\n\nref_template (str) – The reference template.\n\nschema_generator (type[GenerateJsonSchema]) – To override the logic used to generate the JSON schema, as a subclass of\nGenerateJsonSchema with your desired modifications\n\nmode (Literal['validation', 'serialization']) – The mode in which to generate the schema.\n\nReturn type\n\ndict[str, Any]\n\nReturns\n\nThe JSON schema for the given model class.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "getting_started/installation",
        "href": "getting_started/installation.html#install-packages",
        "title": "Install packages",
        "section": "Install packages",
        "text": "The ansys-sherlock-core package supports Python 3.10 through Python 3.13 on Windows and Linux.\nTo use PySherlock, you must download and install both the ansys-api-sherlock\nand ansys-sherlock-core packages. By using pip, ansys-api-sherlock is\ninstalled as part of ansys-sherlock-core.\nRun the following to install the latest publicly distributed version of the package.\nThe following table shows the version of PySherlock to use for each release of Sherlock:\nPySherlock\nSherlock\n0.4\n2024 R1\n0.6\n2024 R2\n0.8\n2025 R1\n0.9\n2025 R2\nTo install a specific version of PySherlock, use the following command, where the <version> is one\nof the values in the table above:\nIf you want to install the ansys-api-sherlock and ansys-sherlock-core packages\nfrom its source code directly, follow these instructions.\nDownload the latest ansys-api-sherlock package by running this\ngit clone command:\nAlternatively, you can download the ZIP file from the Release area of the\nansys-api-sherlock GitHub\nrepository and unzip it before proceeding with the installation.\nAfter the package is downloaded, execute these commands to install it:\nDownload the latest ansys-sherlock-core package by running this\ngit clone command:\nAlternatively, you can download the ZIP file from the Release area of the\npysherlock GitHub repository\nand unzip it before proceeding with the installation.\nAfter the package is downloaded, execute these commands to install it:\nInstall packages\nansys-sherlock-core\nansys-api-sherlock\nansys-sherlock-core\npip\nansys-api-sherlock\nansys-sherlock-core\nansys-api-sherlock\nansys-sherlock-core\nansys-api-sherlock\ngit clone\nansys-sherlock-core\ngit clone"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy.html#model_copy",
        "title": "model_copy",
        "section": "model_copy",
        "text": "[model_copy](../concepts/serialization.md#model_copy)\nReturns a copy of the model.\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\ndeep (bool) – Set to True to make a deep copy of the model.\nSelf\nNew model instance.\nmodel_copy\nMapping\nstr\nAny\nNone\nbool\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_copy",
        "title": "model_copy > model_copy > model_copy",
        "section": "model_copy > model_copy",
        "text": "PolygonalShape.model_copy(*, update=None, deep=False)\n\n!!! abstract “Usage Documentation”\n\n[model_copy](../concepts/serialization.md#model_copy)\n\nReturns a copy of the model.\n\n!!! note\n\nThe underlying instance’s [__dict__][object.__dict__] attribute is copied. This\nmight have unexpected side effects if you store anything in it, on top of the model\nfields (e.g. the value of [cached properties][functools.cached_property]).\n\nParameters\n\nupdate (Mapping[str, Any] | None) – Values to change/add in the new model. Note: the data is not validated\nbefore creating the new model. You should trust this data.\n\ndeep (bool) – Set to True to make a deep copy of the model.\n\nReturn type\n\nSelf\n\nReturns\n\nNew model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate.html#model_validate",
        "title": "model_validate",
        "section": "model_validate",
        "text": "Validate a pydantic model instance.\nobj (Any) – The object to validate.\nstrict (bool | None) – Whether to enforce types strictly.\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\ncontext (Any | None) – Additional context to pass to the validator.\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\nValidationError – If the object could not be validated.\nSelf\nThe validated model instance.\nmodel_validate\nAny\nbool\nNone\nbool\nNone\nAny\nNone\nbool\nNone\nbool\nNone\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate.html#ansys.sherlock.core.types.layer_types.PolygonalShape.model_validate",
        "title": "model_validate > model_validate > model_validate",
        "section": "model_validate > model_validate",
        "text": "classmethod PolygonalShape.model_validate(obj, *, strict=None, from_attributes=None, context=None, by_alias=None, by_name=None)\n\nValidate a pydantic model instance.\n\nParameters\n\nobj (Any) – The object to validate.\n\nstrict (bool | None) – Whether to enforce types strictly.\n\nfrom_attributes (bool | None) – Whether to extract data from object attributes.\n\ncontext (Any | None) – Additional context to pass to the validator.\n\nby_alias (bool | None) – Whether to use the field’s alias when validating against the provided input data.\n\nby_name (bool | None) – Whether to use the field’s name when validating against the provided input data.\n\nRaises\n\nValidationError – If the object could not be validated.\n\nReturn type\n\nSelf\n\nReturns\n\nThe validated model instance.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct.html#construct",
        "title": "construct",
        "section": "construct",
        "text": "Self\nconstruct\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct.html#ansys.sherlock.core.types.layer_types.PottingRegionCopyData.construct",
        "title": "construct > construct > construct",
        "section": "construct > construct",
        "text": "classmethod PottingRegionCopyData.construct(_fields_set=None, **values)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra.html#model_extra",
        "title": "model_extra",
        "section": "model_extra",
        "text": "Get extra fields set during validation.\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\nmodel_extra"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.model_extra.html#ansys.sherlock.core.types.layer_types.RectangularShape.model_extra",
        "title": "model_extra > model_extra > model_extra",
        "section": "model_extra > model_extra",
        "text": "property RectangularShape.model_extra: dict[str, Any] | None\n\nGet extra fields set during validation.\n\nReturns\n\nA dictionary of extra fields, or None if config.extra is not set to “allow”.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "examples/gallery_examples/00-setup/setup",
        "href": "examples/gallery_examples/00-setup/setup.html#setup",
        "title": "Setup",
        "section": "Setup",
        "text": "This prepares the environment for running the examples.\nSetup"
    },
    {
        "objectID": "examples/gallery_examples/00-setup/setup",
        "href": "examples/gallery_examples/00-setup/setup.html#description",
        "title": "Setup > Description",
        "section": "Description",
        "text": "Perform the following steps to set up the environment:\n- Launch Sherlock.\n- Store the Sherlock tutorial path.\nDescription"
    },
    {
        "objectID": "examples/gallery_examples/00-setup/setup",
        "href": "examples/gallery_examples/00-setup/setup.html#launch-sherlock",
        "title": "Setup > Launch Sherlock",
        "section": "Launch Sherlock",
        "text": "Launch the Sherlock service and ensure proper initialization.\nDownload Jupyter notebook: setup.ipynb\nDownload Python source code: setup.py\nDownload zipped: setup.zip\nLaunch Sherlock\nDownload Jupyter notebook: setup.ipynb\nDownload Python source code: setup.py\nDownload zipped: setup.zip"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds.html#bounds",
        "title": "bounds",
        "section": "bounds",
        "text": "bounds (two tuples of the form (x, y)\nlist[tuple[float, float]]\nbounds"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.BoardBounds.bounds.html#ansys.sherlock.core.types.project_types.BoardBounds.bounds",
        "title": "bounds > bounds > bounds",
        "section": "bounds > bounds",
        "text": "BoardBounds.bounds\n\nbounds (two tuples of the form (x, y)\n\n!! processed by numpydoc !!\n\nType\n\nlist[tuple[float, float]]"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset_units.html#temperature_offset_units",
        "title": "temperature_offset_units",
        "section": "temperature_offset_units",
        "text": "temperature_offset_units\nstr\ntemperature_offset_units"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset_units",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset_units.html#ansys.sherlock.core.types.project_types.IcepakFile.temperature_offset_units",
        "title": "temperature_offset_units > temperature_offset_units > temperature_offset_units",
        "section": "temperature_offset_units > temperature_offset_units",
        "text": "IcepakFile.temperature_offset_units\n\ntemperature_offset_units\n\n!! processed by numpydoc !!\n\nType\n\nstr"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.str_validation.html#str_validation",
        "title": "str_validation",
        "section": "str_validation",
        "text": "Validate string fields listed.\nstr_validation"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.str_validation",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.str_validation.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.str_validation",
        "title": "str_validation > str_validation > str_validation",
        "section": "str_validation > str_validation",
        "text": "classmethod CsvExcelOutlineFile.str_validation(value, info)\n\nValidate string fields listed.\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict.html#dict",
        "title": "dict",
        "section": "dict",
        "text": "Dict[str, Any]\ndict\nDict\nstr\nAny"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict.html#ansys.sherlock.core.types.layer_types.PottingRegionDeleteData.dict",
        "title": "dict > dict > dict",
        "section": "dict > dict",
        "text": "PottingRegionDeleteData.dict(*, include=None, exclude=None, by_alias=False, exclude_unset=False, exclude_defaults=False, exclude_none=False)\n\nReturn type\n\nDict[str, Any]\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file.html#parse_file",
        "title": "parse_file",
        "section": "parse_file",
        "text": "Self\nparse_file\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "href": "api/_autosummary/ansys.sherlock.core.types.layer_types.RectangularShape.parse_file.html#ansys.sherlock.core.types.layer_types.RectangularShape.parse_file",
        "title": "parse_file > parse_file > parse_file",
        "section": "parse_file > parse_file",
        "text": "classmethod RectangularShape.parse_file(path, *, content_type=None, encoding='utf8', proto=None, allow_pickle=False)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.validate.html#validate",
        "title": "validate",
        "section": "validate",
        "text": "Self\nvalidate\nSelf"
    },
    {
        "objectID": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.validate",
        "href": "api/_autosummary/ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.validate.html#ansys.sherlock.core.types.project_types.CsvExcelOutlineFile.validate",
        "title": "validate > validate > validate",
        "section": "validate > validate",
        "text": "classmethod CsvExcelOutlineFile.validate(value)\n\nReturn type\n\nSelf\n\n!! processed by numpydoc !!"
    }
]